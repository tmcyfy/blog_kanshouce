<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>手册</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kanshouce.com/"/>
  <updated>2018-04-03T14:44:53.000Z</updated>
  <id>https://www.kanshouce.com/</id>
  
  <author>
    <name>Louis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ethereum以太坊白皮书 中文译版</title>
    <link href="https://www.kanshouce.com/2018/04/03/eth-whitebook/"/>
    <id>https://www.kanshouce.com/2018/04/03/eth-whitebook/</id>
    <published>2018-04-03T14:06:22.000Z</published>
    <updated>2018-04-03T14:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊（Ethereum ）:下一代智能合约和去中心化应用平台</p>
<p>当中本聪在2009年1月启动比特币区块链时，他同时向世界引入了两种未经测试的革命性的新概念。第一种就是比特币（bitcoin），一种去中心化的点对点的网上货币，在没有任何资产担保、内在价值或者中心发行者的情况下维持着价值。到目前为止，比特币已经吸引了大量的公众注意力, 就政治方面而言它是一种没有中央银行的货币并且有着剧烈的价格波动。然而，中本聪的伟大试验还有与比特币同等重要的一部分：基于工作量证明的区块链概念使得人们可以就交易顺序达成共识。作为应用的比特币可以被描述为一个先申请（first-to-file）系统：如果某人有50BTC并且同时向A和B发送这50BTC，只有被首先被确认的交易才会生效。没有固有方法可以决定两笔交易哪一笔先到，这个问题阻碍了去中心化数字货币的发展许多年。中本聪的区块链是第一个可靠的去中心化解决办法。现在，开发者们的注意力开始迅速地转向比特币技术的第二部分，区块链怎样应用于货币以外的领域。</p>
<p>常被提及的应用包括使用链上数字资产来代表定制货币和金融工具（彩色币），某种基础物理设备的所有权（智能资产），如域名一样的没有可替代性的资产（域名币）以及如去中心化交易所，金融衍生品，点到点赌博和链上身份和信誉系统等更高级的应用。另一个常被问询的重要领域是“智能合约”- 根据事先任意制订的规则来自动转移数字资产的系统。例如，一个人可能有一个存储合约，形式为“A可以每天最多提现X个币，B每天最多Y个，A和B一起可以随意提取，A可以停掉B的提现权”。这种合约的符合逻辑的扩展就是去中心化自治组织（DAOs）-长期的包含一个组织的资产并把组织的规则编码的智能合约。以太坊的目标就是提供一个带有内置的成熟的图灵完备语言的区块链，用这种语言可以创建合约来编码任意状态转换功能，用户只要简单地用几行代码来实现逻辑，就能够创建以上提及的所有系统以及许多我们还想象不到的的其它系统。</p>
<h1><span id="li-shi">历史</span></h1><p>去中心化的数字货币概念，正如财产登记这样的替代应用一样，早在几十年以前就被提出来了。1980和1990年代的匿名电子现金协议，大部分是以乔姆盲签技术（Chaumian blinding）为基础的。这些电子现金协议提供具有高度隐私性的货币，但是这些协议都没有流行起来，因为它们都依赖于一个中心化的中介机构。1998年，戴伟（Wei Dai）的b-money首次引入了通过解决计算难题和去中心化共识创造货币的思想，但是该建议并未给出如何实现去中心化共识的具体方法。2005年，芬尼（Hal Finney）引入了“可重复使用的工作量证明机制”（reusable proofs of work）概念，它同时使用b-money的思想和Adam Back提出的计算困难的哈希现金（Hashcash）难题来创造密码学货币。但是，这种概念再次迷失于理想化，因为它依赖于可信任的计算作为后端。</p>
<p>因为货币是一个先申请应用，交易的顺序至关重要，所以去中心化的货币需要找到实现去中心化共识的方法。比特币以前的所有电子货币协议所遇到的主要障碍是，尽管对如何创建安全的拜占庭问题容错（Byzantine-fault-tolerant）多方共识系统的研究已经历时多年，但是上述协议只解决了问题的一半。这些协议假设系统的所有参与者是已知的，并产生如“如果有N方参与到系统中，那么系统可以容忍N/4的恶意参与者”这样形式的安全边界。然而这个假设的问题在于，在匿名的情况下，系统设置的安全边界容易遭受女巫攻击，因为一个攻击者可以在一台服务器或者僵尸网络上创建数以千计的节点，从而单方面确保拥有多数份额。</p>
<p>中本聪的创新是引入这样一个理念：将一个非常简单的基于节点的去中心化共识协议与工作量证明机制结合在一起。节点通过工作量证明机制获得参与到系统的权利，每十分钟将交易打包到“区块”中，从而创建出不断增长的区块链。拥有大量算力的节点有更大的影响力，但获得比整个网络更多的算力比创建一百万个节点困难得多。尽管比特币区块链模型非常简陋，但是实践证明它已经足够好用了，在未来五年，它将成为全世界两百个以上的货币和协议的基石。</p>
<h2><span id="zuo-wei-zhuang-tai-zhuan-huan-xi-tong-de-bi-te-bi">作为状态转换系统的比特币</span></h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fpztno4mdwj30ph06baai.jpg" alt=""><br>从技术角度讲，比特币账本可以被认为是一个状态转换系统，该系统包括所有现存的比特币所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。例如，在标准的银行系统中，状态就是一个资产负债表，一个从A账户向B账户转账X美元的请求是一笔交易，状态转换函数将从A账户中减去X美元，向B账户增加X美元。如果A账户的余额小于X美元，状态转换函数就会返回错误提示。所以我们可以如下定义状态转换函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">APPLY(S,TX) ­&gt; S&apos; or ERROR</div></pre></td></tr></table></figure>
<p>在上面提到的银行系统中，状态转换函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">APPLY(&#123; Alice: $50, Bob: $50 &#125;,&quot;send $20 from Alice to Bob&quot;) = &#123; Alice: $30,Bob: $70 &#125;</div></pre></td></tr></table></figure>
<p>但是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">APPLY(&#123; Alice: $50, Bob: $50 &#125;,&quot;send $70 from Alice to Bob&quot;) = ERROR</div></pre></td></tr></table></figure>
<p>比特币系统的“状态”是所有已经被挖出的、没有花费的比特币（技术上称为“未花费的交易输出，unspent transaction outputs 或UTXO”）的集合。每个UTXO都有一个面值和所有者（由20个字节的本质上是密码学公钥的地址所定义[1]）。一笔交易包括一个或多个输入和一个或多个输出。每个输入包含一个对现有UTXO的引用和由与所有者地址相对应的私钥创建的密码学签名。每个输出包含一个新的加入到状态中的UTXO。</p>
<p>在比特币系统中，状态转换函数<code>APPLY(S,TX)-&gt;S’</code>大体上可以如下定义：</p>
<ol>
<li>交易的每个输入：<ul>
<li>如果引用的UTXO不存在于现在的状态中<code>（S）</code>，返回错误提示</li>
<li>如果签名与UTXO所有者的签名不一致，返回错误提示</li>
</ul>
</li>
<li>如果所有的UTXO输入面值总额小于所有的UTXO输出面值总额，返回错误提示</li>
<li>返回新状态<code>S’</code>,新状态S中移除了所有的输入UTXO，增加了所有的输出UTXO。</li>
</ol>
<p>第一步的第一部分防止交易的发送者花费不存在的比特币，第二部分防止交易的发送者花费其他人的比特币。第二步确保价值守恒。比特币的支付协议如下。假设Alice想给Bob发送11.7BTC。事实上，Alice不可能正好有11.7BTC。假设，她能得到的最小数额比特币的方式是：6+4+2=12。所以，她可以创建一笔有3个输入，2个输出的交易。第一个输出的面值是11.7BTC，所有者是Bob（Bob的比特币地址），第二个输出的面值是0.3BTC，所有者是Alice自己，也就是找零。</p>
<h2><span id="wa-kuang">挖矿</span></h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fpztr9d4tmj30tu09ct9a.jpg" alt=""></p>
<p>一个区块，每个区块包含一个时间戳、一个随机数、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表。这样随着时间流逝就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。</p>
<p>依照这个范式，检查一个区块是否有效的算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在且有效。</li>
<li>检查区块的时间戳是否晚于以前的区块的时间戳，而且早于未来2小时[2]。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将上一个区块的最终状态赋于<code>S[0]</code>。</li>
<li>假设TX是区块的交易列表，包含n笔交易。对于属于0……n-1的所有i,进行状态转换<code>S[i+1] = APPLY(S[i],TX[i])</code>。如果任何一笔交易i在状态转换中出错，退出程序，返回错误。</li>
<li>返回正确，状态<code>S[n]</code>是这一区块的最终状态。</li>
</ol>
<p>本质上，区块中的每笔交易必须提供一个正确的状态转换，要注意的是，“状态”并不是编码到区块的。它纯粹只是被校验节点记住的抽象概念，对于任意区块都可以从创世状态开始，按顺序加上每一个区块的每一笔交易，（妥妥地）计算出当前的状态。另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有A、B两笔交易，B花费的是A创建的UTXO，如果A在B以前，这个区块是有效的，否则，这个区块是无效的。</p>
<p>区块验证算法的有趣部分是“工作量证明”概念：对每个区块进行SHA256哈希处理，将得到的哈希视为长度为256比特的数值，该数值必须小于不断动态调整的目标数值，本书写作时目标数值大约是2^190。工作量证明的目的是使区块的创建变得困难，从而阻止女巫攻击者恶意重新生成区块链。因为SHA256是完全不可预测的伪随机函数，创建有效区块的唯一方法就是简单地不断试错，不断地增加随机数的数值，查看新的哈希数值是否小于目标数值。如果当前的目标数值是2^192，就意味着平均需要尝试2^64次才能生成有效的区块。一般而言，比特币网络每隔2016个区块重新设定目标数值，保证平均每十分钟生成一个区块。为了对矿工的计算工作进行奖励，每一个成功生成区块的矿工有权在区块中包含一笔凭空发给他们自己25BTC的交易。另外，如果交易的输入大于输出，差额部分就作为“交易费用”付给矿工。顺便提一下，对矿工的奖励是比特币发行的唯一机制，创世状态中并没有比特币。</p>
<p>为了更好地理解挖矿的目的，让我们分析比特币网络出现恶意攻击者时会发生什么。因为比特币的密码学基础是非常安全的，所以攻击者会选择攻击没有被密码学直接保护的部分：交易顺序。攻击者的策略非常简单：</p>
<ol>
<li>向卖家发送100BTC购买商品（尤其是无需邮寄的电子商品）。</li>
<li>等待直至商品发出。</li>
<li>创建另一笔交易，将相同的100BTC发送给自己的账户。</li>
<li>使比特币网络相信发送给自己账户的交易是最先发出的。</li>
</ol>
<p>一旦步骤（1）发生，几分钟后矿工将把这笔交易打包到区块，假设是第270000个区块。大约一个小时以后，在此区块后面将会有五个区块，每个区块间接地指向这笔交易，从而确认这笔交易。这时卖家收到货款，并向买家发货。因为我们假设这是数字商品，攻击者可以即时收到货。现在，攻击者创建另一笔交易，将相同的100BTC发送到自己的账户。如果攻击者只是向全网广播这一消息，这一笔交易不会被处理。矿工会运行状态转换函数APPLY(S,TX)，发现这笔交易将花费已经不在状态中的UTXO。所以，攻击者会对区块链进行分叉，将第269999个区块作为父区块重新生成第270000个区块，在此区块中用新的交易取代旧的交易。因为区块数据是不同的，这要求重新进行工作量证明。另外，因为攻击者生成的新的第270000个区块有不同的哈希，所以原来的第270001到第270005的区块不指向它，因此原有的区块链和攻击者的新区块是完全分离的。在发生区块链分叉时，区块链长的分支被认为是诚实的区块链，合法的的矿工将会沿着原有的第270005区块后挖矿，只有攻击者一人在新的第270000区块后挖矿。攻击者为了使得他的区块链最长，他需要拥有比除了他以外的全网更多的算力来追赶（即51%攻击）。</p>
<h2><span id="mo-ke-er-shu">默克尔树</span></h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fpzttqkaaqj30dq08ft9r.jpg" alt=""></p>
<p>左：仅提供默克尔树（Merkle tree）上的少量节点已经足够给出分支的合法证明。<br>右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。</p>
<p>比特币系统的一个重要的可扩展特性是：它的区块存储在多层次的数据结构中。一个区块的哈希实际上只是区块头的哈希，区块头是包含时间戳、随机数、上个区块哈希和存储了所有的区块交易的默克尔树的根哈希的长度大约为200字节的一段数据。</p>
<p>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。</p>
<p>默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。目前，这一存储空间对台式计算机来说尚可接受，但是手机已经负载不了如此巨大的数据了。未来只有商业机构和爱好者才会充当完整节点。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。</p>
<h2><span id="qi-ta-de-qu-kuai-lian-ying-yong">其它的区块链应用</span></h2><p>将区块链的思想应用到其它领域的想法早就出现了。在2005年，尼克萨博提出了“用所有权为财产冠名”的概念，文中描述了复制数据库技术的发展如何使基于区块链的系统可以应用于登记土地所有权，创建包括例如房产权、违法侵占和乔治亚州土地税等概念的详细框架。然而，不幸的是在那时还没有实用的复制数据库系统，所以这个协议被没有被付诸实践。不过，自2009年比特币系统的去中心化共识开发成功以来，许多区块链的其它应用开始快速出现。</p>
<ul>
<li><strong>域名币（namecoin）</strong>- 创建于2010年，被称为去中心化的名称注册数据库。像Tor、Bitcoin和BitMessage这样的去中心化协议，需要一些确认账户的方法，这样其他人才能够与用户进行交互。但是，在所有的现存的解决方案中仅有的可用的身份标识是象1LW79wp5ZBqaHW1jL5TciBCrhQYtHagUWy这样的伪随机哈希。理想的情况下，人们希望拥有一个带有象“george”这样的名称的账户。然而，问题是如果有人可以创建“george”账户，那么其他人同样也可以创建“george”账户来假扮。唯一的解决方法是先申请原则（first-to-file），只有第一个注册者可以成功注册，第二个不能再次注册同一个账户。这一问题就可以利用比特币的共识协议。域名币是利用区块链实现名称注册系统的最早的、最成功的系统。</li>
<li><strong>彩色币（Colored coins）</strong>- 彩色币的目的是为人们在比特币区块链上创建自己的数字货币，或者，在更重要的一般意义上的货币 – 数字令牌提供服务。依照彩色币协议，人们可以通过为某一特别的比特币UTXO指定颜色，发行新的货币。该协议递归地将其它UTXO定义为与交易输入UTXO相同的颜色。这就允许用户保持只包含某一特定颜色的UTXO，发送这些UTXO就像发送普通的比特币一样，通过回溯全部的区块链判断收到的UTXO颜色。</li>
<li><strong>元币（Metacoins）</strong>- 元币的理念是在比特币区块链上创建新的协议，利用比特币的交易保存元币的交易，但是采用了不同的状态转换函数APPLY’。因为元币协议不能阻止比特币区块链上的无效的元币交易，所以增加一个规则如果APPLY’(S,TX)返回错误，这一协议将默认APPLY’(S,TX) = S。这为创建任意的、先进的不能在比特币系统中实现的密码学货币协议提供了一个简单的解决方法，而且开发成本非常低，因为挖矿和网络的问题已经由比特币协议处理好了。</li>
</ul>
<p>因此，一般而言，建立共识协议有两种方法：建立一个独立的网络和在比特币网络上建立协议。虽然像域名币这样的应用使用第一种方法已经获得了成功，但是该方法的实施非常困难，因为每一个应用需要创建独立的区块链和建立、测试所有状态转换和网络代码。另外，我们预测去中心化共识技术的应用将会服从幂律分布，大多数的应用太小不足以保证自由区块链的安全，我们还注意到大量的去中心化应用，尤其是去中心化自治组织，需要进行应用之间的交互。</p>
<p>另一方面，基于比特币的方法存在缺点，它没有继承比特币可以进行简化确认支付（SPV) 的特性。比特币可以实现简化确认支付，因为比特币可以将区块链深度作为有效性确认代理。在某一点上，一旦一笔交易的祖先们距离现在足够远时，就可以认为它们是合法状态的一部分。与之相反，基于比特币区块链的元币协议不能强迫区块链不包括不符合元币协议的交易。因此，安全的元币协议的简化支付确认需要后向扫描所有的区块，直到区块链的初始点，以确认某一交易是否有效。目前，所有基于比特币的元币协议的“轻”实施都依赖可信任的服务器提供数据，这对主要目的之一是消除信任需要的密码学货币而言，只是一个相当次优的结果。</p>
<h2><span id="jiao-ben">脚本</span></h2><p>即使不对比特币协议进行扩展，它也能在一定程度上实现”智能合约”。比特币的UTXO可以被不只被一个公钥拥有，也可以被用基于堆栈的编程语言所编写的更加复杂的脚本所拥有。在这一模式下，花费这样的UTXO，必须提供满足脚本的数据。事实上，基本的公钥所有权机制也是通过脚本实现的：脚本将椭圆曲线签名作为输入，验证交易和拥有这一UTXO的地址，如果验证成功，返回1，否则返回0。更加复杂的脚本用于其它不同的应用情况。例如，人们可以创建要求集齐三把私钥中的两把才能进行交易确认的脚本（多重签名），对公司账户、储蓄账户和某些商业代理来说，这种脚本是非常有用的。脚本也能用来对解决计算问题的用户发送奖励。人们甚至可以创建这样的脚本“如果你能够提供你已经发送一定数额的的狗币给我的简化确认支付证明，这一比特币UTXO就是你的了”，本质上，比特币系统允许不同的密码学货币进行去中心化的兑换。</p>
<p>然而，比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><strong>缺少图灵完备性</strong> – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。</li>
<li><strong>价值盲（Value-blindness）</strong>。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。</li>
<li><strong>缺少状态</strong> – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。</li>
<li><strong>区块链盲（Blockchain-blindness）</strong>- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</li>
</ul>
<p>我们已经考察了在密码学货币上建立高级应用的三种方法：建立一个新的区块链，在比特币区块链上使用脚本，在比特币区块链上建立元币协议。建立新区块链的方法可以自由地实现任意的特性，成本是开发时间和培育努力。使用脚本的方法非常容易实现和标准化，但是它的能力有限。元币协议尽管非常容易实现，但是存在扩展性差的缺陷。在以太坊系统中，我们的目的是建立一个能够同时具有这三种模式的所有优势的通用框架。</p>
<h1><span id="yi-tai-fang">以太坊</span></h1><p>以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。</p>
<h2><span id="yi-tai-fang-zhang-hu">以太坊账户</span></h2><p>在以太坊系统中，状态是由被称为“账户”（每个账户由一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换构成的。以太坊的账户包含四个部分：</p>
<ul>
<li>随机数，用于确定每笔交易只能被处理一次的计数器</li>
<li>账户目前的以太币余额</li>
<li>账户的合约代码，如果有的话</li>
<li>账户的存储（默认为空）</li>
</ul>
<p>以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<h2><span id="xiao-xi-he-jiao-yi">消息和交易</span></h2><p>以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同。第一，以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。第二，以太坊消息可以选择包含数据。第三，如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</p>
<p>以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和两个被称为STARTGAS和GASPRICE的数值。为了防止代码的指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤-包括初始消息和所有执行中引发的消息-做出限制。STARTGAS就是限制，GASPRICE是每一计算步骤需要支付矿工的费用。如果执行交易的过程中，“用完了瓦斯”，所有的状态改变恢复原状态，但是已经支付的交易费用不可收回了。如果执行交易中止时还剩余瓦斯，那么这些瓦斯将退还给发送者。创建合约有单独的交易类型和相应的消息类型；合约的地址是基于账号随机数和交易数据的哈希计算出来的。</p>
<p>消息机制的一个重要后果是以太坊的“头等公民”财产-合约与外部账户拥有同样权利，包括发送消息和创建其它合约的权利。这使得合约可以同时充当多个不同的角色，例如，用户可以使去中心化组织（一个合约）的一个成员成为一个中介账户（另一个合约），为一个偏执的使用定制的基于量子证明的兰波特签名（第三个合约）的个人和一个自身使用由五个私钥保证安全的账户（第四个合约）的共同签名实体提供居间服务。以太坊平台的强大之处在于去中心化的组织和代理合约不需要关心合约的每一参与方是什么类型的账户。</p>
<h2><span id="yi-tai-fang-zhuang-tai-zhuan-huan-han-shu">以太坊状态转换函数</span></h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fpztyib91wj30qv0e90ts.jpg" alt=""></p>
<p>以太坊的状态转换函数：<code>APPLY(S,TX) -&gt; S&#39;</code>，可以定义如下：</p>
<ol>
<li>检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误。</li>
<li>计算交易费用:<code>fee=STARTGAS * GASPRICE</code>，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。</li>
<li>设定初值<code>GAS = STARTGAS</code>，并根据交易中的字节数减去一定量的瓦斯值。</li>
<li>从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者瓦斯用完。</li>
<li>如果因为发送者账户没有足够的钱或者代码执行耗尽瓦斯导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。</li>
<li><p>否则，将所有剩余的瓦斯归还给发送者，消耗掉的瓦斯作为交易费用发送给矿工。 例如，假设合约的代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if !self.storage[calldataload(0)]:</div><div class="line">self.storage[calldataload(0)] = calldataload(32)</div></pre></td></tr></table></figure>
<p> 需要注意的是，在现实中合约代码是用底层以太坊虚拟机（EVM）代码写成的。上面的合约是用我们的高级语言Serpent语言写成的，它可以被编译成EVM代码。假设合约存储器开始时是空的，一个值为10以太，瓦斯为2000，瓦斯价格为0.001以太并且64字节数据，第一个三十二字节的快代表号码2和第二个代表词CHARLIE。的交易发送后，状态转换函数的处理过程如下：</p>
<pre><code>1. 检查交易是否有效、格式是否正确。
2. 检查交易发送者至少有`2000*0.001=2`个以太币。如果有，从发送者账户中减去2个以太币。
3. 初始设定`gas=2000`,假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。
4. 从发送者账户减去10个以太币，为合约账户增加10个以太币。
5. 运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的瓦斯，于是剩余的瓦斯为`1150 - 187 = 963`.
6. 向发送者的账户增加`963*0.001=0.963`个以太币，返回最终状态。 如果没有合约接收交易，那么所有的交易费用就等于GASPRICE乘以交易的字节长度，交易的数据就与交易费用无关了。另外，需要注意的是，合约发起的消息可以对它们产生的计算分配瓦斯限额，如果子计算的瓦斯用完了，它只恢复到消息发出时的状态。因此，就像交易一样，合约也可以通过对它产生的子计算设置严格的限制，保护它们的计算资源。
</code></pre></li>
</ol>
<h2><span id="dai-ma-zhi-xing">代码执行</span></h2><p>以太坊合约的代码使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。一般而言，代码执行是无限循环，程序计数器每增加一（初始值为零）就执行一次操作，直到代码执行完毕或者遇到错误，<code>STOP</code>或者<code>RETURN</code>指令。操作可以访问三种存储数据的空间：</p>
<ul>
<li><strong>堆栈</strong>，一种后进先出的数据存储，32字节的数值可以入栈，出栈。</li>
<li><strong>内存</strong>，可无限扩展的字节队列。</li>
<li><strong>合约的长期存储</strong>，一个秘钥/数值的存储，其中秘钥和数值都是32字节大小，与计算结束即重置的堆栈和内存不同，存储内容将长期保持。</li>
</ul>
<p>代码可以象访问区块头数据一样访问数值，发送者和接受到的消息中的数据，代码还可以返回数据的字节队列作为输出。</p>
<p>EVM代码的正式执行模型令人惊讶地简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组<code>(block_state, transaction, message, code, memory, stack, pc, gas)</code>来定义，这里block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，当前指令被找到，每个指令都有定义自己如何影响元组。例如，ADD将两个元素出栈并将它们的和入栈，将gas（瓦斯）减一并将pc加一，SSTORE将顶部的两个元素出栈并将第二个元素插入到由第一个元素定义的合约存储位置，同样减少最多200的gas值并将pc加一，虽然有许多方法通过即时编译去优化以太坊，但以太坊的基础性的实施可以用几百行代码实现。</p>
<h2><span id="qu-kuai-lian-he-wa-kuang">区块链和挖矿</span></h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fpzu3bl6crj30ta077mx6.jpg" alt=""></p>
<p>虽然有一些不同，但以太坊的区块链在很多方面类似于比特币区块链。它们的区块链架构的不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。以太坊中的区块确认算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在和有效。</li>
<li>检查区块的时间戳是否比引用的上一个区块大，而且小于15分钟。</li>
<li>检查区块序号、难度值、 交易根，叔根和瓦斯限额（许多以太坊特有的底层概念）是否有效。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将<code>S[0]</code>赋值为上一个区块的STATE_ROOT。</li>
<li>将TX赋值为区块的交易列表，一共有n笔交易。对于属于<code>0……n-1</code>的i，进行状态转换<code>S[i+1] = APPLY(S[i],TX[i])</code>。如果任何一个转换发生错误，或者程序执行到此处所花费的瓦斯（gas）超过了GASLIMIT，返回错误。</li>
<li>用<code>S[n]</code>给<code>S_FINAL</code>赋值, 向矿工支付区块奖励。 8 检查S-FINAL是否与STATE_ROOT相同。如果相同，区块是有效的。否则，区块是无效的。</li>
</ol>
<p>这一确认方法乍看起来似乎效率很低，因为它需要存储每个区块的所有状态，但是事实上以太坊的确认效率可以与比特币相提并论。原因是状态存储在树结构中（tree structure），每增加一个区块只需要改变树结构的一小部分。因此，一般而言，两个相邻的区块的树结构的大部分应该是相同的，因此存储一次数据，可以利用指针（即子树哈希）引用两次。一种被称为“帕特里夏树”（“Patricia Tree”）的树结构可以实现这一点，其中包括了对默克尔树概念的修改，不仅允许改变节点，而且还可以插入和删除节点。另外，因为所有的状态信息是最后一个区块的一部分，所以没有必要存储全部的区块历史-这一方法如果能够可以应用到比特币系统中，经计算可以对存储空间有10-20倍的节省。</p>
<p>#应用<br>一般来讲，以太坊之上有三种应用。第一类是金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法。包括子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，甚至一些种类的全面的雇佣合约。第二类是半金融应用，这里有钱的存在但也有很重的非金钱的方面，一个完美的例子是为解决计算问题而设的自我强制悬赏。最后，还有在线投票和去中心化治理这样的完全的非金融应用。</p>
<p>##令牌系统<br>链上令牌系统有很多应用，从代表如美元或黄金等资产的子货币到公司股票，单独的令牌代表智能资产，安全的不可伪造的优惠券，甚至与传统价值完全没有联系的用来进行积分奖励的令牌系统。在以太坊中实施令牌系统容易得让人吃惊。关键的一点是理解，所有的货币或者令牌系统，从根本上来说是一个带有如下操作的数据库：从A中减去X单位并把X单位加到B上，前提条件是(1)A在交易之前有至少X单位以及(2)交易被A批准。实施一个令牌系统就是把这样一个逻辑实施到一个合约中去。</p>
<p>用Serpent语言实施一个令牌系统的基本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def send(to, value):</div><div class="line">    if self.storage[from] &gt;= value:</div><div class="line">        self.storage[from] = self.storage[from] value</div><div class="line">        self.storage[to] = self.storage[to] + value</div></pre></td></tr></table></figure>
<p>这从本质上来说是本文将要进一步描述的“银行系统”状态转变功能的一个最小化实施。需要增加一些额外的代码以提供在初始和其它一些边缘情况下分发货币的功能，理想情况下会增加一个函数让其它合约来查询一个地址的余额。就足够了。理论上，基于以太坊的充当子货币的令牌系统可能包括一个基于比特币的链上元币所缺乏的重要功能：直接用这种货币支付交易费的能力。实现这种能力的方法是在合约里维护一个以太币账户以用来为发送者支付交易费，通过收集被用来充当交易费用的内部货币并把它们在一个不断运行的拍卖中拍卖掉，合约不断为该以太币账户注资。这样用户需要用以太币“激活”他们的账户，但一旦账户中有以太币它将会被重复使用因为每次合约都会为其充值。</p>
<h2><span id="jin-rong-yan-sheng-pin-he-jie-zhi-wen-ding-de-huo-bi">金融衍生品和价值稳定的货币</span></h2><p>金融衍生品是“智能合约”的最普遍的应用，也是最易于用代码实现的之一。实现金融合约的主要挑战是它们中的大部分需要参照一个外部的价格发布器；例如，一个需求非常大的应用是一个用来对冲以太币（或其它密码学货币）相对美元价格波动的智能合约，但该合约需要知道以太币相对美元的价格。最简单地方法是通过由某特定机构（例如纳斯达克）维护的“数据提供“合约进行，该合约的设计使得该机构能够根据需要更新合约，并提供一个接口使得其它合约能够通过发送一个消息给该合约以获取包含价格信息的回复。</p>
<p>当这些关键要素都齐备，对冲合约看起来会是下面的样子：</p>
<ol>
<li>等待A输入1000以太币。</li>
<li>等待B 输入1000以太币。</li>
<li>通过查询数据提供合约，将1000以太币的美元价值，例如，x美元，记录至存储器。</li>
<li>30天后，允许A或B“重新激活“合约以发送价值x美元的以太币（重新查询数据提供合约以获取新价格并计算）给A并将剩余的以太币发送给B。 这样的合约在密码学商务中有非同寻常的潜力。密码学货币经常被诟病的一个问题就是其价格的波动性；虽然大量的用户和商家可能需要密码学资产所带来的安全和便利，可他们不太会乐意面对一天中资产跌去23%价值的情形。直到现在，最为常见的推荐方案是发行者背书资产；思想是发行者创建一种子货币，对此种子货币他们有权发行和赎回，给予（线下）提供给他们一个单位特定相关资产（例如黄金，美元）的人一个单位子货币。发行者承诺当任何人送还一个单位密码学资产时。发还一个单位的相关资产。这种机制能够使任何非密码学资产被“升级“为密码学资产，如果发行者值得信任的话。 然而实践中发行者并非总是值得信任的，并且一些情况下银行体系太脆弱，或者不够诚实守信从而使这样的服务无法存在。金融衍生品提供了一种替代方案。这里将不再有提供储备以支撑一种资产的单独的发行者，取而代之的是一个由赌一种密码学资产的价格会上升的投机者构成的去中心化市场。与发行者不同，投机者一方没有讨价还价的权利，因为对冲合约把他们的储备冻结在了契约中。注意这种方法并非是完全去中心化的，因为依然需要一个可信任的提供价格信息的数据源，尽管依然有争议这依然是在降低基础设施需求（与发行者不同，一个价格发布器不需要牌照并且似乎可归为自由言论一类）和降低潜在欺诈风险方面的一个巨大的进步。</li>
</ol>
<h2><span id="shen-fen-he-xin-yu-xi-tong">身份和信誉系统</span></h2><p>最早的替代币，域名币，尝试使用一个类比特币块链来提供一个名称注册系统，在那里用户可以将他们的名称和其它数据一起在一个公共数据库注册。最常用的应用案例把象“bitcoin.org“（或者再域名币中，”bitcoin.bit“）一样的域名与一个IP地址对应的域名系统。其它的应用案例包括电子邮件验证系统和潜在的更先进的信誉系统。这里是以太坊中提供与域名币类似的的名称注册系统的基础合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def register(name, value):</div><div class="line">    if !self.storage[name]:</div><div class="line">        self.storage[name] = value</div></pre></td></tr></table></figure>
<p>合约非常简单；就是一个以太坊网络中的可以被添加但不能被修改或移除的数据库。任何人都可以把一个名称注册为一个值并永远不变。一个更复杂的名称注册合约将包含允许其他合约查询的“功能条款“，以及一个让一个名称的”拥有者“（即第一个注册者）修改数据或者转让所有权的机制。甚至可以在其上添加信誉和信任网络功能。</p>
<h2><span id="qu-zhong-xin-hua-cun-chu">去中心化存储</span></h2><p>在过去的几年里出现了一些大众化的在线文件存储初创公司，最突出的是Dropbox，它寻求允许用户上传他们的硬盘备份，提供备份存储服务并允许用户访问从而按月向用户收取费用。然而，在这一点上这个文件存储市场有时相对低效；对现存服务的粗略观察表明，特别地在“神秘谷“20-200GB这一既没有免费空间也没有企业级用户折扣的水平上，主流文件存储成本每月的价格意味着支付在一个月里支付整个硬盘的成本。以太坊合约允许去中心化存储生态的开发，这样用户通过将他们自己的硬盘或未用的网络空间租出去以获得少量收益，从而降低了文件存储的成本。</p>
<p>这样的设施的基础性构件就是我们所谓的“去中心化Dropbox合约“。这个合约工作原理如下。首先，某人将需要上传的数据分成快，对每一块数据加密以保护隐私，并且以此构建一个默克尔树。然后创建一个含以下规则的合约，每N个块，合约将从默克尔树中抽取一个随机索引（使用能够被合约代码访问的上一个块的哈希来提供随机性）， 然后给第一个实体X以太以支撑一个带有类似简化验证支付（SPV）的在树中特定索引处的块的所有权证明。当一个用户想重新下载他的文件，他可以使用微支付通道协议（例如每32k字节支付1萨博）恢复文件；从费用上讲最高效的方法是支付者不到最后不发布交易，而是用一个略微更合算的带有同样随机数的交易在每32k字节之后来代替原交易。</p>
<p>这个协议的一个重要特征是，虽然看起来象是一个人信任许多不准备丢失文件的随机节点，但是他可以通过秘密分享把文件分成许多小块，然后通过监视合同得知每个小块都还被某个节点的保存着。如果一个合约依然在付款，那么就提供了某个人依然在保存文件的证据。</p>
<h2><span id="qu-zhong-xin-hua-zi-zhi-zu-zhi">去中心化自治组织</span></h2><p>通常意义上“去中心化自治组织（DAO, decentralized autonomous organization）”的概念指的是一个拥有一定数量成员或股东的虚拟实体，依靠比如67%多数来决定花钱以及修改代码。成员会集体决定组织如何分配资金。分配资金的方法可能是悬赏，工资或者更有吸引力的机制比如用内部货币奖励工作。这仅仅使用密码学块链技术就从根本上复制了传统公司或者非营利组织的法律意义以实现强制执行。至此许多围绕DAO的讨论都是围绕一个带有接受分红的股东和可交易的股份的“去中心化自治公司（DAC，decentralized autonomous corporation）”的“资本家”模式；作为替代者，一个被描述为“去中心化自治社区（decentralized autonomous community）”的实体将使所有成员都在决策上拥有同等的权利并且在增减成员时要求67%多数同意。每个人都只能拥有一个成员资格这一规则需要被群体强制实施。</p>
<p>下面是一个如何用代码实现DO的纲要。最简单地设计就是一段如果三分之二成员同意就可以自我修改的代码。虽然理论上代码是不可更改的，然而通过把代码主干放在一个单独的合约内并且把合约调用的地址指向一个可更改的存储依然可以容易地绕开障碍而使代码变得可修改，在一个这样的DAO合约的简单实现中有三种交易类型，由交易提供的数据区分：</p>
<ul>
<li><code>[0,i,K,V]</code> 注册索引为i 的对存储地址索引为K 至 v 的内容的更改建议。</li>
<li><code>[0,i]</code> 注册对建议i 的投票。</li>
<li><code>[2,i]</code> 如有足够投票则确认建议i。</li>
</ul>
<p>然后合约对每一项都有具体的条款。它将维护一个所有开放存储的更改记录以及一个谁投票表决的表。还有一个所有成员的表。当任何存储内容的更改获得了三分之二多数同意，一个最终的交易将执行这项更改。一个更加复杂的框架会增加内置的选举功能以实现如发送交易，增减成员，甚至提供委任制民主一类的投票代表（即任何人都可以委托另外一个人来代表自己投票，而且这种委托关系是可以传递的，所以如果A委托了B然后B委托了C那么C将决定A的投票）。这种设计将使DAO作为一个去中心化社区有机地成长， 使人们最终能够把挑选合适人选的任务交给专家，与当前系统不同，随着社区成员不断改变他们的站队假以时日专家会容易地出现和消失。 一个替代的模式是去中心化公司，那里任何账户可以拥有0到更多的股份，决策需要三分之二多数的股份同意。一个完整的框架将包括资产管理功能-可以提交买卖股份的订单以及接受这种订单的功能（前提是合约里有订单匹配机制）。代表依然以委任制民主的方式存在，产生了“董事会”的概念。</p>
<p>更先进的组织治理机制可能会在将来实现；现在一个去中心化组织（DO）可以从去中心化自治组织（DAO）开始描述。DO和DAO的区别是模糊的，一个大致的分割线是治理是否可以通过一个类似政治的过程或者一个“自动”过程实现，一个不错的直觉测试是“无通用语言”标准：如果两个成员不说同样的语言组织还能正常运行吗？显然，一个简单的传统的持股式公司会失败，而象比特币协议这样的却很可能成功，罗宾·汉森的“futarchy”，一个通过预测市场实现组织化治理的机制是一个真正的说明“自治”式治理可能是什么样子的好例子。注意一个人无需假设所有DAO比所有DO优越；自治只是一个在一些特定场景下有很大优势的，但在其它地方未必可行的范式，许多半DAO可能存在。</p>
<h2><span id="jin-yi-bu-de-ying-yong">进一步的应用</span></h2><ol>
<li><strong>储蓄钱包</strong>。 假设Alice想确保她的资金安全，但她担心丢失或者被黑客盗走私钥。她把以太币放到和Bob签订的一个合约里，如下所示，这合同是一个银行：<ul>
<li>Alice单独每天最多可提取1%的资金。</li>
<li>Bob单独每天最多可提取1%的资金，但Alice可以用她的私钥创建一个交易取消Bob的提现权限。</li>
<li>Alice 和 Bob 一起可以任意提取资金。 一般来讲，每天1%对Alice足够了，如果Alice想提现更多她可以联系Bob寻求帮助。如果Alice的私钥被盗，她可以立即找到Bob把她的资金转移到一个新合同里。如果她弄丢了她的私钥，Bob可以慢慢地把钱提出。如果Bob表现出了恶意，她可以关掉他的提现权限。</li>
</ul>
</li>
<li><strong>作物保险</strong>。一个人可以很容易地以天气情况而不是任何价格指数作为数据输入来创建一个金融衍生品合约。如果一个爱荷华的农民购买了一个基于爱荷华的降雨情况进行反向赔付的金融衍生品，那么如果遇到干旱，该农民将自动地收到赔付资金而如果有足量的降雨他会很开心因为他的作物收成会很好。</li>
<li><strong>一个去中心化的数据发布器</strong>。 对于基于差异的金融合约，事实上通过过“谢林点”协议将数据发布器去中心化是可能的。谢林点的工作原理如下：N方为某个指定的数据提供输入值到系统（例如ETH/USD价格），所有的值被排序，每个提供25%到75%之间的值的节点都会获得奖励，每个人都有激励去提供他人将提供的答案，大量玩家可以真正同意的答案明显默认就是正确答案，这构造了一个可以在理论上提供很多数值，包括ETH/USD价格，柏林的温度甚至某个特别困难的计算的结果的去中心化协议。   </li>
<li><strong>云计算</strong>。EVM技术还可被用来创建一个可验证的计算环境，允许用户邀请他人进行计算然后选择性地要求提供在一定的随机选择的检查点上计算被正确完成的证据。这使得创建一个任何用户都可以用他们的台式机，笔记本电脑或者专用服务器参与的云计算市场成为可能，现场检查和安全保证金可以被用来确保系统是值得信任的（即没有节点可以因欺骗获利）。虽然这样一个系统可能并不适用所有任务；例如，需要高级进程间通信的任务就不易在一个大的节点云上完成。然而一些其它的任务就很容易实现并行；SETI@home, folding@home和基因算法这样的项目就很容易在这样的平台上进行。</li>
<li><strong>点对点赌博</strong>。任意数量的点对点赌博协议都可以搬到以太坊的区块链上，例如Frank Stajano和Richard Clayton的Cyberdice。 最简单的赌博协议事实上是这样一个简单的合约，它用来赌下一个区块的哈稀值与猜测值之间的差额, 据此可以创建更复杂的赌博协议，以实现近乎零费用和无欺骗的赌博服务。</li>
<li><strong>预测市场</strong>。 不管是有神谕还是有谢林币，预测市场都会很容易实现，带有谢林币的预测市场可能会被证明是第一个主流的作为去中心化组织管理协议的“futarchy”应用。</li>
<li>链上去中心化市场，以身份和信誉系统为基础。</li>
</ol>
<h1><span id="za-xiang-he-guan-zhu">杂项和关注</span></h1><h2><span id="gai-jin-ban-you-ling-xie-yi-de-shi-shi">改进版幽灵协议的实施</span></h2><p>“幽灵“协议（”Greedy Heaviest Observed Subtree” (GHOST) protocol）是由Yonatan Sompolinsky 和 Aviv Zohar在2013年12月引入的创新。幽灵协议提出的动机是当前快速确认的块链因为区块的高作废率而受到低安全性困扰；因为区块需要花一定时间（设为t）扩散至全网，如果矿工A挖出了一个区块然后矿工B碰巧在A的区块扩散至B之前挖出了另外一个区块，矿工B的区块就会作废并且没有对网络安全作出贡献。此外，这里还有中心化问题：如果A是一个拥有全网30%算力的矿池而B拥有10%的算力，A将面临70%的时间都在产生作废区块的风险而B在90%的时间里都在产生作废区块。因此，如果作废率高，A将简单地因为更高的算力份额而更有效率，综合这两个因素，区块产生速度快的块链很可能导致一个矿池拥有实际上能够控制挖矿过程的算力份额。</p>
<p>正如Sompolinsky 和 Zohar所描述的，通过在计算哪条链“最长”的时候把废区块也包含进来，幽灵协议解决了降低网络安全性的第一个问题；这就是说，不仅一个区块的父区块和更早的祖先块，祖先块的作废的后代区块（以太坊术语中称之为“叔区块”）也被加进来以计算哪一个区块拥有支持其的最大工作量证明。我们超越了Sompolinsky 和 Zohar所描述的协议以解决第二个问题 – 中心化倾向，以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励，把它们纳入计算的“侄子区块”将获得奖励的12.5%，不过，交易费用不奖励给叔区块。 以太坊实施了一个只下探到第五层的简化版本的幽灵协议。其特点是，废区块只能以叔区块的身份被其父母的第二代至第五代后辈区块，而不是更远关系的后辈区块（例如父母区块的第六代后辈区块，或祖父区块的第三代后辈区块）纳入计算。这样做有几个原因。首先，无条件的幽灵协议将给计算给定区块的哪一个叔区块合法带来过多的复杂性。其次，带有以太坊所使用的补偿的无条件的幽灵协议剥夺了矿工在主链而不是一个公开攻击者的链上挖矿的激励。最后，计算表明带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%。</p>
<h2><span id="fei-yong">费用</span></h2><p>因为每个发布的到区块链的交易都占用了下载和验证的成本，需要有一个包括交易费的规范机制来防范滥发交易。比特币使用的默认方法是纯自愿的交易费用，依靠矿工担当守门人并设定动态的最低费用。因为这种方法是“基于市场的”，使得矿工和交易发送者能够按供需来决定价格，所以这种方法在比特币社区被很顺利地接受了。然而，这个逻辑的问题在于，交易处理并非一个市场；虽然根据直觉把交易处理解释成矿工给发送者提供的服务是很有吸引力的，但事实上一个矿工收录的交易是需要网络中每个节点处理的，所以交易处理中最大部分的成本是由第三方而不是决定是否收录交易的矿工承担的。于是，非常有可能发生公地悲剧。</p>
<p>然而，当给出一个特殊的不够精确的简化假设时，这个基于市场的机制的漏洞很神奇地消除了自己的影响。论证如下。假设：</p>
<ol>
<li>一个交易带来 k 步操作, 提供奖励 kR给任何收录该交易的矿工，这里 R 由交易发布者设定， k 和 R 对于矿工都是事先（大致上）可见的。</li>
<li>每个节点处理每步操作的成本都是 C (即所有节点的效率一致)。</li>
<li>有 N 个挖矿节点，每个算力一致(即全网算力的1/N)。</li>
<li>没有不挖矿的全节点。</li>
</ol>
<p>当预期奖励大于成本时，矿工愿意挖矿。这样，因为矿工有1/N 的机会处理下一个区块，所以预期的收益是 kR/N , 矿工的处理成本简单为 kC. 这样当 kR/N &gt; kC， 即 R &gt; NC时。矿工愿意收录交易。注意 R 是由交易发送者提供的每步费用，是矿工从处理交易中获益的下限。 NC 是全网处理一个操作的成本。所以，矿工仅有动机去收录那些收益大于成本的交易。 然而，这些假设与实际情况有几点重要的偏离：</p>
<ol>
<li>因为额外的验证时间延迟了块的广播因而增加了块成为废块的机会，处理交易的矿工比其它的验证节点付出了更高的成本。</li>
<li>不挖矿的全节点是存在的。</li>
<li>实践中算力分布可能最后是极端不平均的。</li>
<li>以破坏网络为己任的投机者，政敌和疯子确实存在，并且他们能够聪明地设置合同使得他们的成本比其它验证节点低得多。 上面第1点驱使矿工收录更少的交易，第2点增加了 NC; 因此这两点的影响至少部分互相抵消了. 第3点和第4点是主要问题；作为解决方案我们简单地建立了一个浮动的上限：没有区块能够包含比BLK_LIMIT_FACTOR 倍长期指数移动平均值更多的操作数。具体地：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) /EMA_FACTOR)</div></pre></td></tr></table></figure>
<p>BLK_LIMIT_FACTOR 和 EMA_FACTOR 是暂且被设为 65536 和 1.5 的常数，但可能会在更深入的分析后调整。</p>
<h2><span id="ji-suan-he-tu-ling-wan-bei">计算和图灵完备</span></h2><p>需要强调的是以太坊虚拟机是图灵完备的； 这意味着EVM代码可以实现任何可以想象的计算，包括无限循环。EVM代码有两种方式实现循环。首先， JUMP 指令可以让程序跳回至代码前面某处，还有允许如<code>while x &lt; 27: x = x * 2</code>一样的条件语句的JUMPI 指令实现条件跳转。其次，合约可以调用其它合约，有通过递归实现循环的潜力。这很自然地导致了一个问题：恶意用户能够通过迫使矿工和全节点进入无限循环而不得不关机吗？ 这问题出现是因为计算机科学中一个叫停机问题的问题：一般意义上没有办法知道，一个给定的程序是否能在有限的时间内结束运行。</p>
<p>正如在状态转换章节所述，我们的方案通过为每一个交易设定运行执行的最大计算步数来解决问题，如果超过则计算被恢复原状但依然要支付费用。消息以同样的方式工作。为显示这一方案背后的动机，请考虑下面的例子：</p>
<ul>
<li>一个攻击者创建了一个运行无限循环的合约，然后发送了一个激活循环的交易给矿工，矿工将处理交易，运行无限循环直到瓦斯耗尽。即使瓦斯耗尽交易半途停止，交易依然正确（回到原处）并且矿工依然从攻击者哪里挣到了每一步计算的费用。</li>
<li>一个攻击者创建一个非常长的无限循环意图迫使矿工长时间内一直计算致使在计算结束前若干区块已经产生于是矿工无法收录交易以赚取费 用。然而，攻击者需要发布一个 STARTGAS 值以限制可执行步数，因而矿工将提前知道计算将耗费过多的步数。</li>
<li>一个攻击者看到一个包含诸如 send(A,self.storage); self.storage = 0格式的合约然后发送带有只够执行第一步的费用的而不够执行第二步的交易（即提现但不减少账户余额）。合约作者无需担心防卫类似攻击，因为如果执行中途停止则所有变更都被回复。</li>
<li>一个金融合约靠提取九个专用数据发布器的中值来工作以最小化风险，一个攻击者接管了其中一个数据提供器，然后把这个按DAO章节所述的可变地址调用机制设计成可更改的数据提供器转为运行一个无限循环，以求尝试逼迫任何从此金融合约索要资金的尝试都会因瓦斯耗尽而中止。然而，该金融合约可以在消息里设置瓦斯限制以防范此类问题。 图灵完备的替代是图灵不完备，这里 JUMP 和 JUMPI 指令不存在并且在某个给定时间每个合约只允许有一个拷贝存在于调用堆栈内。在这样的系统里，上述的费用系统和围绕我们的方案的效率的不确定性可能都是不需要的，因为执行一个合约的成本将被它的大小决定。此外，图灵不完备甚至不是一个大的限制，在我们内部设想的所有合约例子中，至今只有一个需要循环，而且即使这循环也可以被26个单行代码段的重复所代替。考虑到图灵完备带来的严重的麻烦和有限的益处，为什么不简单地使用一种图灵不完备语言呢？事实上图灵不完备远非一个简洁的解决方案。为什么？请考虑下面的合约：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C0: call(C1); call(C1);</div><div class="line">C1: call(C2); call(C2);</div><div class="line">C2: call(C3); call(C3);</div><div class="line">...</div><div class="line">C49: call(C50); call(C50);</div><div class="line">C50: (作一个图灵机的步计算和记录结果在合约的长期存储)</div></pre></td></tr></table></figure>
<p>现在，发送一个这样的交易给A，这样，在51个交易中，我们有了一个需要花费2^50 步计算的合约，矿工可能尝试通过为每一个合约维护一个最高可执行步数并且对于递归调用其它合约的合约计算可能执行步数从而预先检测这样的逻辑炸弹，但是这会使矿工禁止创建其它合约的合约（因为上面26个合约的创建和执行可以很容易地放入一个单独合约内）。另外一个问题点是一个消息的地址字段是一个变量，所以通常来讲可能甚至无法预先知道一个合约将要调用的另外一个合约是哪一个。于是，最终我们有了一个惊人的结论：图灵完备的管理惊人地容易，而在缺乏同样的控制时图灵不完备的管理惊人地困难- 那为什么不让协议图灵完备呢？</p>
<h2><span id="huo-bi-he-fa-xing">货币和发行</span></h2><p>以太坊网络包含自身的内置货币以太币，以太币扮演双重角色，为各种数字资产交易提供主要的流动性，更重要的是提供了了支付交易费用的一种机制。为便利及避免将来的争议期间（参见当前的mBTC/uBTC/聪的争论），不同面值的名称将被提前设置：</p>
<ul>
<li>1: 伟</li>
<li>10^12: 萨博</li>
<li>10^15: 芬尼</li>
<li>10^18: 以太</li>
</ul>
<p>这应该被当作是“元”和“分”或者“比特币”和“聪”的概念的扩展版，在不远的将来，我们期望“以太”被用作普通交易，“芬尼”用来进行微交易，“萨博”和“伟”用来进行关于费用和协议实施的讨论。</p>
<p>发行模式如下：</p>
<ul>
<li>通过发售活动，以太币将以每BTC 1337-2000以太的价格发售，一个旨在为以太坊组织筹资并且为开发者支付报酬的机制已经在其它一些密码学货币平台上成功使用。早期购买者会享受较大的折扣，发售所得的BTC将完全用来支付开发者和研究者的工资和悬赏，以及投入密码学货币生态系统的项目。</li>
<li>0.099x （x为发售总量）将被分配给BTC融资或其它的确定性融资成功之前参与开发的早期贡献者，另外一个0.099x将分配给长期研究项目。</li>
<li>自上线时起每年都将有0.26x（x为发售总量）被矿工挖出。</li>
</ul>
<h2><span id="fa-xing-fen-jie">发行分解</span></h2><p>永久线性增长模型降低了在比特币中出现的财富过于集中的风险，并且给予了活在当下和将来的人公平的机会去获取货币，同时保持了对获取和持有以太币的激励，因为长期来看“货币供应增长率”是趋于零的。我们还推断，随着时间流逝总会发生因为粗心和死亡等原因带来的币的遗失，假设币的遗失是每年货币供应量的一个固定比例，则最终总的流通中的货币供应量会稳定在一个等于年货币发行量除以遗失率的值上（例如，当遗失率为1%时，当供应量达到30x时，每年有0.3x被挖出同时有0.3x丢失，达到一个均衡）。</p>
<table>
<thead>
<tr>
<th>Group</th>
<th>At launch</th>
<th>After 1 yea</th>
<th>After 5 years</th>
</tr>
</thead>
<tbody>
<tr>
<td>Currency units</td>
<td>1.198X</td>
<td>1.458X</td>
<td>2.498X</td>
</tr>
<tr>
<td>Purchasers</td>
<td>83.5%</td>
<td>68.6%</td>
<td>40.0%</td>
</tr>
<tr>
<td>Reserve spent pre-sale</td>
<td>8.26%</td>
<td>6.79%</td>
<td>3.96%</td>
</tr>
<tr>
<td>Reserve used post-sale</td>
<td>8.26%</td>
<td>6.79%</td>
<td>3.96%</td>
</tr>
<tr>
<td>Miners</td>
<td>0%</td>
<td>17.8%</td>
<td>52.0%</td>
</tr>
</tbody>
</table>
<p>除了线性的发行方式外，和比特币一样以太币的的供应量增长率长期来看也趋于零。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fpzuj8fmy4j30qb0e5wi4.jpg" alt=""></p>
<h2><span id="wa-kuang-de-zhong-xin-hua">挖矿的中心化</span></h2><p>比特币挖矿算法基本上是让矿工千万次地轻微改动区块头，直到最终某个节点的改动版本的哈希小于目标值（目前是大约2190）。然而，这种挖矿算法容易被两种形式的中心化攻击。第一种，挖矿生态系统被专门设计的因而在比特币挖矿这一特殊任务上效率提高上千倍的ASICs（专用集成电路）和电脑芯片控制。这意味着比特币挖矿不再是高度去中心化的和追求平等主义的，而是需要巨额资本的有效参与。第二种，大部分比特币矿工事实上不再在本地完成区块验证；而是依赖中心化的矿池提供区块头。这个问题可以说很严重：在本文写作时，最大的两个矿池间接地控制了大约全网50%的算力，虽然当一个矿池或联合体尝试51%攻击时矿工可以转换到其它矿池这一事实减轻了问题的严重性。</p>
<p>以太坊现在的目的是使用一个基于为每1000个随机数随机产生唯一哈希的函数的挖矿算法，用足够宽的计算域，去除专用硬件的优势。这样的策略当然不会使中心化的收益减少为零，但是也不需要。注意每单个用户使用他们的私人笔记本电脑或台式机就可以几乎免费地完成一定量的挖矿活动，但当到了100%的CPU使用率之后更多地挖矿就会需要他们支付电力和硬件成本。ASIC挖矿公司需要从第一个哈希开始就为电力和硬件支付成本。所以，如果中心化收益能够保持在(E + H) /E 以下，那么即使ASICs被制造出来普通矿工依然有生存空间。另外，我们计划将挖矿算法设计成挖矿需要访问整个区块链，迫使矿工存储完成的区块链或者至少能够验证每笔交易。这去除了对中心化矿池的需要；虽然矿池依然可以扮演平滑收益分配的随机性的角色，但这功能可以被没有中心化控制的P2P矿池完成地同样好。这样即使大部分普通用户依然倾向选择轻客户端，通过增加网络中的全节点数量也有助于抵御中心化。</p>
<h2><span id="kuo-zhan-xing">扩展性</span></h2><p>扩展性问题是以太坊常被关注的地方，与比特币一样，以太坊也遭受着每个交易都需要网络中的每个节点处理这一困境的折磨。比特币的当前区块链大小约为20GB，以每小时1MB的速度增长。如果比特币网络处理Visa级的2000tps的交易，它将以每三秒1MB的速度增长（1GB每小时，8TB每年）。以太坊可能也会经历相似的甚至更糟的增长模式，因为在以太坊区块链之上还有很多应用，而不是像比特币只是简单的货币，但以太坊全节点只需存储状态而不是完整的区块链历史这一事实让情况得到了改善。</p>
<p>大区块链的问题是中心化风险。如果块链大小增加至比如100TB，可能的场景将是只有非常小数目的大商家会运行全节点，而常规用户使用轻的SPV节点。这会增加对全节点合伙欺诈牟利（例如更改区块奖励，给他们自己BTC）的风险的担忧。轻节点将没有办法立刻检测到这种欺诈。当然，至少可能存在一个诚实的全节点，并且几个小时之后有关诈骗的信息会通过Reddit这样的渠道泄露，但这时已经太晚：任凭普通用户做出怎样的努力去废除已经产生的区块，他们都会遇到与发动一次成功的51%攻击同等规模的巨大的不可行的协调问题。在比特币这里，现在这是一个问题，但Peter Todd建议的一个改动可以缓解这个问题。</p>
<p>近期，以太坊会使用两个附加的策略以应对此问题。首先，因为基于区块链的挖矿算法，至少每个矿工会被迫成为一个全节点，这保证了一定数量的全节点。其次，更重要的是，处理完每笔交易后，我们会把一个中间状态树的根包含进区块链。即使区块验证是中心化的，只要有一个诚实的验证节点存在，中心化的问题就可以通过一个验证协议避免。如果一个矿工发布了一个不正确的区块，这区块要么是格式错，要么状态<code>S[n]</code>是错的。因为<code>S[0]</code>是正确的，必然有第一个错误状态S[i]但<code>S[i-1]</code>是正确的，验证节点将提供索引i，一起提供的还有处理<code>APPLY(S[i-1],TX[i]) -&gt; S[i]</code>所需的帕特里夏树节点的子集。这些节点将受命进行这部分计算，看产生的S[i]与先前提供的值是否一致。</p>
<p>另外，更复杂的是恶意矿工发布不完整区块进行攻击，造成没有足够的信息去确定区块是否正确。解决方案是质疑-回应协议：验证节点对目标交易索引发起质疑，接受到质疑信息的轻节点会对相应的区块取消信任，直到另外一个矿工或者验证者提供一个帕特里夏节点子集作为正确的证据。</p>
<h1><span id="zong-shu-qu-zhong-xin-hua-ying-yong">综述：去中心化应用</span></h1><p>上述合约机制使得任何一个人能够在一个虚拟机上建立通过全网共识来运行命令行应用（从根本上来说是），它能够更改一个全网可访问的状态作为它的“硬盘”。然而，对于多数人来说，用作交易发送机制的命令行接口缺乏足够的用户友好使得去中心化成为有吸引力的替代方案。最后，一个完整的“去中心化应用”应该包括底层的商业逻辑组件【无论是否在以太坊完整实施，使用以太坊和其它系统组合（如一个P2P消息层，其中一个正在计划放入以太坊客户端）或者仅有其它系统的方式】和上层的图形用户接口组件。以太坊客户端被设计成一个网络浏览器，但包括对“eth” Javascript API对象的支持，可被客户端里看到的特定的网页用来与以太坊区块链交互。从“传统”网页的角度看来，这些网页是完全静态的内容，因为区块链和其它去中心化协议将完全代替服务器来处理用户发起的请求。最后，去中心化协议有希望自己利用某种方式使用以太坊来存储网页。</p>
<h1><span id="jie-lun">结论</span></h1><p>以太坊协议最初是作为一个通过高度通用的语言提供如链上契约，提现限制和金融合约，赌博市场等高级功能的升级版密码学货币来构思的。以太坊协议将不直接“支持”任何应用，但图灵完备编程语言的存在意味着理论上任意的合约都可以为任何交易类型和应用创建出来。然而关于以太坊更有趣的是，以太坊协议比单纯的货币走得更远，围绕去中心化存储，去中心化计算和去中心化预测市场以及数十个类似概念建立的协议和去中心化应用，有潜力从根本上提升计算行业的效率，并通过首次添加经济层为其它的P2P协议提供有力支撑，最终，同样会有大批与金钱毫无关系的应用出现。</p>
<p>以太坊协议实现的任意状态转换概念提供了一个具有独特潜力的平台；与封闭式的，为诸如数据存储，赌博或金融等单一目的设计的协议不同，以太坊从设计上是开放式的，并且我们相信它极其适合作为基础层服务于在将来的年份里出现的极其大量的金融和非金融协议。</p>
<h1><span id="zhu-jie-yu-jin-jie-yue-du">注解与进阶阅读</span></h1><h2><span id="zhu-jie">注解</span></h2><ol>
<li><p>一个有经验的读者会注意到事实上比特币地址是椭圆曲线公钥的哈希，而非公钥本身，然而事实上从密码学术语角度把公钥哈希称为公钥完全合理。这是因为比特币密码学可以被认为是一个定制的数字签名算法，公钥由椭圆曲线公钥的哈希组成，签名由椭圆曲线签名连接的椭圆曲线公钥组成，而验证算法包括用作为公钥提供的椭圆曲线公钥哈希来检查椭圆曲线公钥，以及之后的用椭圆曲线公钥来验证椭圆曲线签名。</p>
</li>
<li><p>技术上来说，前11个区块的中值。</p>
</li>
<li><p>在内部，2和<code>“CHARLIE”</code>都是数字，后一个有巨大的base256编码格式，数字可以从0到<code>2^256-1</code>。</p>
</li>
</ol>
<h2><span id="jin-jie-yue-du">进阶阅读</span></h2><h2><span id="jin-jie-yue-du">进阶阅读</span></h2><ol>
<li><p>Intrinsic value:<a href="https://tinyurl.com/BitcoinMag-IntrinsicValue" target="_blank" rel="external">https://tinyurl.com/BitcoinMag-IntrinsicValue</a></p>
</li>
<li><p>Smart property: <a href="https://en.bitcoin.it/wiki/Smart_Property" target="_blank" rel="external">https://en.bitcoin.it/wiki/Smart_Property</a></p>
</li>
<li><p>Smart contracts: <a href="https://en.bitcoin.it/wiki/Contracts" target="_blank" rel="external">https://en.bitcoin.it/wiki/Contracts</a></p>
</li>
<li><p>B-money: <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="external">http://www.weidai.com/bmoney.txt</a></p>
</li>
<li><p>Reusable proofs of work: <a href="http://www.finney.org/~hal/rpow/" target="_blank" rel="external">http://www.finney.org/~hal/rpow/</a></p>
</li>
<li><p>Secure property titles with owner authority: <a href="http://szabo.best.vwh.net/securetitle.html" target="_blank" rel="external">http://szabo.best.vwh.net/securetitle.html</a></p>
</li>
<li><p>Bitcoin whitepaper: <a href="http://bitcoin.org/bitcoin.pdf" target="_blank" rel="external">http://bitcoin.org/bitcoin.pdf</a></p>
</li>
<li><p>Namecoin: <a href="https://namecoin.org/" target="_blank" rel="external">https://namecoin.org/</a></p>
</li>
<li><p>Zooko’s triangle: <a href="http://en.wikipedia.org/wiki/Zooko’s_triangle" target="_blank" rel="external">http://en.wikipedia.org/wiki/Zooko’s_triangle</a></p>
</li>
<li><p>Colored coins whitepaper: <a href="https://tinyurl.com/coloredcoin-whitepaper" target="_blank" rel="external">https://tinyurl.com/coloredcoin-whitepaper</a></p>
</li>
<li><p>Mastercoin whitepaper: <a href="https://github.com/mastercoin-MSC/spec" target="_blank" rel="external">https://github.com/mastercoin-MSC/spec</a></p>
</li>
<li><p>Decentralized autonomous corporations, Bitcoin Magazine: <a href="https://tinyurl.com/Bootstrapping-DACs" target="_blank" rel="external">https://tinyurl.com/Bootstrapping-DACs</a></p>
</li>
<li><p>Simplified payment verification:<a href="https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification" target="_blank" rel="external">https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification</a></p>
</li>
<li><p>Merkle trees: <a href="http://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="external">http://en.wikipedia.org/wiki/Merkle_tree</a></p>
</li>
<li><p>Patricia trees: <a href="http://en.wikipedia.org/wiki/Patricia_tree" target="_blank" rel="external">http://en.wikipedia.org/wiki/Patricia_tree</a></p>
</li>
<li><p>GHOST: <a href="http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf" target="_blank" rel="external">http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf</a></p>
</li>
<li><p>StorJ and Autonomous Agents, Jeff Garzik: <a href="https://tinyurl.com/storj-agents" target="_blank" rel="external">https://tinyurl.com/storj-agents</a></p>
</li>
<li><p>Mike Hearn on Smart Property at Turing Festival: <a href="http://www.youtube.com/watch?v=Pu4PAMFPo5Y" target="_blank" rel="external">http://www.youtube.com/watch?v=Pu4PAMFPo5Y</a></p>
</li>
<li><p>Ethereum RLP: <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP" target="_blank" rel="external">https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP</a></p>
</li>
<li><p>Ethereum Merkle Patricia trees: <a href="https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree" target="_blank" rel="external">https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree</a></p>
</li>
<li><p>Peter Todd on Merkle sum trees:<a href="http://sourceforge.net/p/bitcoin/mailman/message/31709140/" target="_blank" rel="external">http://sourceforge.net/p/bitcoin/mailman/message/31709140/</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以太坊（Ethereum ）:下一代智能合约和去中心化应用平台&lt;/p&gt;
&lt;p&gt;当中本聪在2009年1月启动比特币区块链时，他同时向世界引入了两种未经测试的革命性的新概念。第一种就是比特币（bitcoin），一种去中心化的点对点的网上货币，在没有任何资产担保、内在价值或者中心
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用脚本acme申请Let&#39;s Encrypt免费证书（极简版）</title>
    <link href="https://www.kanshouce.com/2017/12/22/theFreeTLS/"/>
    <id>https://www.kanshouce.com/2017/12/22/theFreeTLS/</id>
    <published>2017-12-22T08:23:43.000Z</published>
    <updated>2017-12-28T13:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>免费证书如果是阿里云的主机直接申请铁门塞克的1年免费版是极方便的，申请下来后因为在阿里自己的系统内，可以直接面向相对应的产品进行推送，到期后还有自动提醒等等等，服务非常周到，可以看出阿里云一直在打造自己的全家桶。 </p>
<p>如果不使用阿里云主机的情况下，可以使用本教程生成证书。或可以看之前的<a href="https://www.kanshouce.com/2017/08/08/Https-encrypt/">完整版本</a></p>
<p>证书认证机构为 <a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>。 证书的生成有许多方法，这里使用的是比较简单的方法：使用 <a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="external">acme.sh</a> 脚本生成，本部分说明部分内容参考于<a href="https://github.com/Neilpang/acme.sh/blob/master/README.md" target="_blank" rel="external">acme.sh README</a>。</p>
<p>证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，强烈建议使用 ECC 证书。</p>
<p>以下将给出这两类证书的生成方法，请大家根据自身的情况自行选择其中一种证书类型。</p>
<p>证书生成只需在服务器上操作。</p>
<h2><span id="an-zhuang-acme-sh">安装 acme.sh</span></h2><p>执行以下命令，acme.sh 会安装到 <code>~/.acme.sh</code> 目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ curl  https://get.acme.sh | sh</div><div class="line">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                               Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100   671  100   671    0     0    680      0 --:--:-- --:--:-- --:--:--   679</div><div class="line">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                               Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100  112k  100  112k    0     0   690k      0 --:--:-- --:--:-- --:--:--  693k</div><div class="line">[Fri 30 Dec 01:03:32 GMT 2016] Installing from online archive.</div><div class="line">[Fri 30 Dec 01:03:32 GMT 2016] Downloading https://github.com/Neilpang/acme.sh/archive/master.tar.gz</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Extracting master.tar.gz</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing to /home/user/.acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installed to /home/user/.acme.sh/acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing <span class="built_in">alias</span> to <span class="string">'/home/user/.profile'</span></div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] OK, Close and reopen your terminal to start using acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing cron job</div><div class="line">no crontab <span class="keyword">for</span> user</div><div class="line">no crontab <span class="keyword">for</span> user</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Good, bash is found, so change the shebang to use bash as preferred.</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] OK</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Install success!</div></pre></td></tr></table></figure>
<p>安装成功后执行 <code>source ~/.bashrc</code> 以确保脚本所设置的命令别名生效。</p>
<p>如果安装报错，那么可能是因为系统缺少 acme.sh 所需要的依赖项，acme.sh 的依赖项主要是 netcat(nc)，我们通过以下命令来安装这些依赖项，然后重新安装一遍 acme.sh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get -y install netcat</div></pre></td></tr></table></figure>
<p>Centos自行使用<code>yum</code>安装，这里不表。</p>
<h2><span id="shi-yong-acme-sh-sheng-cheng-zheng-shu">使用 acme.sh 生成证书</span></h2><h3><span id="zheng-shu-sheng-cheng">证书生成</span></h3><p>执行以下命令生成证书：</p>
<p><strong>请注意</strong>以下的命令会临时监听 80 端口，请确保执行该命令前 80 端口没有使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --issue <span class="_">-d</span> mydomain.me --standalone -k ec-256</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Standalone mode.</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Single domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting domain auth token <span class="keyword">for</span> each domain</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting webroot <span class="keyword">for</span> domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] _w=<span class="string">'no'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting new-authz <span class="keyword">for</span> domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] The new-authz request is ok.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] Verify finished, start to sign.</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Cert success.</div><div class="line">-----BEGIN CERTIFICATE-----</div><div class="line">MIIEMTCCAxmgAwIBAgISA1+gJF5zwUDjNX/6Xzz5fo3lMA0GCSqGSIb3DQEBCwUA</div><div class="line">MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD</div><div class="line">ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjEyMjkyMzU5MDBaFw0x</div><div class="line">NzAzMjkyMzU5MDBaMBcxFTATBgNVBAMTDHdlYWtzYW5kLmNvbTBZMBMGByqGSM49</div><div class="line">****************************************************************</div><div class="line">4p40tm0aMB837XQ9jeAXvXulhVH/7/wWZ8/vkUUvuHSCYHagENiq/3DYj4a85Iw9</div><div class="line">+6u1r7atYHJ2VwqSamiyTGDQuhc5wdXIQxY/YQQqkAmn5tLsTZnnOavc4plANT40</div><div class="line">zweiG8vcIvMVnnkM0TSz8G1yzv1nOkruN3ozQkLMu6YS7lk/ENBN7DBtYVSmJeU2</div><div class="line">VAXE+zgRaP7JFOqK6DrOwhyE2LSgae83Wq/XgXxjfIo1Zmn2UmlE0sbdNKBasnf9</div><div class="line">gPUI45eltrjcv8FCSTOUcT7PWCa3</div><div class="line">-----END CERTIFICATE-----</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Your cert is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/mydomain.me.cer</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Your cert key is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/mydomain.me.key</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] The intermediate CA cert is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/ca.cer</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] And the full chain certs is there:  /root/.acme.sh/mydomain.me_ecc/fullchain.cer</div></pre></td></tr></table></figure>
<p><code>-k</code> 表示密钥长度，后面的值可以是 ec-256 、ec-284、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。</p>
<h3><span id="zheng-shu-geng-xin">证书更新</span></h3><p>由于 Let’s Encrypt 的证书有效期只有 <strong>3 个月</strong>，因此需要 <strong>90</strong> 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。</p>
<p>手动更新 ECC 证书，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --renew <span class="_">-d</span> mydomain.com --force --ecc</div></pre></td></tr></table></figure>
<p>如果是 RSA 证书则执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --renew <span class="_">-d</span> mydomain.com --force</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费证书如果是阿里云的主机直接申请铁门塞克的1年免费版是极方便的，申请下来后因为在阿里自己的系统内，可以直接面向相对应的产品进行推送，到期后还有自动提醒等等等，服务非常周到，可以看出阿里云一直在打造自己的全家桶。 &lt;/p&gt;
&lt;p&gt;如果不使用阿里云主机的情况下，可以使用本教程
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://www.kanshouce.com/tags/HTTPS/"/>
    
      <category term="SSL" scheme="https://www.kanshouce.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>如何愉快的CentOS7构建一个7 Days To Die Server？</title>
    <link href="https://www.kanshouce.com/2017/11/09/7DaysToDieOnCentOs7/"/>
    <id>https://www.kanshouce.com/2017/11/09/7DaysToDieOnCentOs7/</id>
    <published>2017-11-09T09:44:31.000Z</published>
    <updated>2017-11-14T11:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#sheng-ji-xi-tong">升级系统</a></li>
<li><a href="#chuang-jian-zhang-hu">创建账户</a></li>
<li><a href="#she-zhi-fang-huo-qiang">设置防火墙</a></li>
<li><a href="#an-zhuang-steamcmd-zhi-chi-ku">安装SteamCMD支持库</a></li>
<li><a href="#kai-shi-bu-shu">开始部署</a></li>
<li><a href="#she-zhi-pei-zhi-wen-jian">设置配置文件</a></li>
<li><a href="#chuang-jian-yi-ge-kuai-su-de-sheng-ji-jiao-ben">创建一个快速的升级脚本</a></li>
<li><a href="#yun-xing-fu-wu-qi">运行服务器</a></li>
<li><a href="#serverconfig-xml">serverconfig.xml</a></li>
</ul>
<!-- tocstop -->
</div>

<p>Linx运行七日杀的服务相比Windows稳定而消耗内存更小。下面是部署方法：</p>
<p>安装的先决条件，你需要一个Steam的账号，网络有传不需要Steam也可以成功安装，由于酶试过，不保证。</p>
<h1><span id="sheng-ji-xi-tong">升级系统</span></h1><p>先来升级下系统    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum update</div><div class="line">$ yum upgrade -y</div></pre></td></tr></table></figure>
<h1><span id="chuang-jian-zhang-hu">创建账户</span></h1><p>创建一个账户，这个账户是用于运行七日杀的，七日杀不允许直接root运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ adduser 7d2d</div><div class="line">$ passwd 7d2d</div></pre></td></tr></table></figure>
<h1><span id="she-zhi-fang-huo-qiang">设置防火墙</span></h1><p>这里对应的端口<code>26900</code>是默认的，在后面的<code>serverconfig.xml</code>文件中有设定，所以这里开放了<code>26900</code>后面就不要修改了，如果需要别的端口在这步改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ firewall-cmd --zone=public --add-port=26900/tcp --permanent</div><div class="line">$ firewall-cmd --zone=public --add-port=26900/udp --permanent</div><div class="line">$ firewall-cmd --reload</div></pre></td></tr></table></figure>
<h1><span id="an-zhuang-steamcmd-zhi-chi-ku">安装SteamCMD支持库</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install glibc.i686 libstdc++.i686 -y</div></pre></td></tr></table></figure>
<h1><span id="kai-shi-bu-shu">开始部署</span></h1><p>切换账号到开始创建的七日杀运行账号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ su 7d2d</div><div class="line">$ cd ~</div></pre></td></tr></table></figure>
<p>获取Steam在Linux下的程序包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz</div><div class="line">$ tar xf steamcmd_linux.tar.gz</div></pre></td></tr></table></figure>
<p>进入Steam运行环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./steamcmd.sh</div></pre></td></tr></table></figure>
<p>输入账号和密码进行登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; login steam用户名 steam密码  // 例如 login a 123</div></pre></td></tr></table></figure>
<p>在这里基于Steam的安全机制，会给你的邮箱或手机邮件，提示输入安全码，按照邮件中的安全码输入即可。</p>
<p>设定安装目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; force_install_dir ./72d2</div></pre></td></tr></table></figure>
<p>升级安装命令：<code>app_update</code> 这个命令包含了两个功能，安装或更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; app_update 294420 validate</div></pre></td></tr></table></figure>
<p>这里的<code>294420</code>是七日杀服务器程序的ID。</p>
<p>接下来等待漫长的安装吧</p>
<p>请注意，这里最好将 <code>app_update 294420 validate</code> 多执行几次，直到提示无需更新为止。</p>
<h1><span id="she-zhi-pei-zhi-wen-jian">设置配置文件</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nano serverconfig.xml</div></pre></td></tr></table></figure>
<p>如果需要修改，只需要修改里面的值即可</p>
<h1><span id="chuang-jian-yi-ge-kuai-su-de-sheng-ji-jiao-ben">创建一个快速的升级脚本</span></h1><p>如果说每次升级用命令很麻烦，这里可以一劳永逸，创建一个脚本来解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nano /home/7d2d/update_7d2d.txt</div></pre></td></tr></table></figure>
<p>首先我们创建一个名字是<code>update_7d2d.txt</code>的文本文件；</p>
<p>接着我们把下面的内容丢进去（需要执行的命令行）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">login 用户名 密码</div><div class="line">force_install_dir ./7d2d</div><div class="line">app_update 294420</div><div class="line">quit</div></pre></td></tr></table></figure>
<p>这样，以后服务器升级的命令会非常容易</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~</div><div class="line">$ ./steamcmd.sh +runscript update_7d2d.txt</div></pre></td></tr></table></figure>
<h1><span id="yun-xing-fu-wu-qi">运行服务器</span></h1><p>启动服务器</p>
<p><strong>32位服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/7d2d/7d2d/</div><div class="line">$ screen -dmS 7d2d ./7DaysToDieServer.x86 -configfile=serverconfig.xml -logfile 7DaysToDie_Data/output_log.txt $ @</div></pre></td></tr></table></figure>
<p><strong>64位服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/7d2d/7d2d/</div><div class="line">$ screen -dmS 7d2d ./7DaysToDieServer.x86_64 -configfile=serverconfig.xml -logfile 7DaysToDie_Data/output_log.txt $ @</div></pre></td></tr></table></figure>
<ul>
<li><p><code>screen</code> 这个命令的作用是在<code>ssh</code>的链接关闭后，仍然用进程来运行这个程序；</p>
</li>
<li><p>如果没有装<code>screen</code>可以<code>yum install screen</code>安装一个；</p>
</li>
<li><p><code>screen -ls</code>可以列出目前在后台运行的屏幕进程，用<code>screen -r 进程号</code>即可切换到这个屏幕，例子如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ screen -list</div><div class="line">There is a screen on:</div><div class="line">	3922.7d2d	(Detached)</div><div class="line">1 Socket in /var/run/screen/S-steam.</div></pre></td></tr></table></figure>
<p>如果需要切换到这个屏幕，<code>screen -r 3922</code></p>
<ul>
<li>如果你在开始创建的<code>7d2d</code>这个账号开了一个<code>screen</code>那么在切换或运行命令的时候同样要用<code>su 7d2d</code>将当前操作账号切换到<code>7d2d</code>这个账户上</li>
</ul>
<h1><span id="serverconfig-xml">serverconfig.xml</span></h1><p>这可能是网络上最全面的配置说明了</p>
<p>只需要修改<code>value</code>中的值即可</p>
<table>
<thead>
<tr>
<th>property</th>
<th>默认值</th>
<th>可选项</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServerPort</td>
<td>26900</td>
<td></td>
<td>服务器的端口号</td>
</tr>
<tr>
<td>ServerIsPublic</td>
<td>true</td>
<td>true/false</td>
<td>这个服务器是否注册到全球服务器，即是否开放</td>
</tr>
<tr>
<td>ServerName</td>
<td>My Game Host</td>
<td></td>
<td>服务器名字</td>
</tr>
<tr>
<td>ServerPassword</td>
<td></td>
<td></td>
<td>服务器密码</td>
</tr>
<tr>
<td>ServerMaxPlayerCount</td>
<td>8</td>
<td></td>
<td>最大玩家并发数，一般个人PC 8G 20人</td>
</tr>
<tr>
<td>ServerReservedSlots</td>
<td>0</td>
<td></td>
<td>可设置权限的管理员数量</td>
</tr>
<tr>
<td>ServerReservedSlotsPermission</td>
<td>100</td>
<td></td>
<td>设置服务器同时允许几不同级别管理员在线</td>
</tr>
<tr>
<td>ServerAdminSlots</td>
<td>0</td>
<td></td>
<td>同时允许几个次级管理员在线</td>
</tr>
<tr>
<td>ServerAdminSlotsPermission</td>
<td>0</td>
<td></td>
<td>是否超权可以登录的管理</td>
</tr>
<tr>
<td>ServerDescription</td>
<td>A 7 Days to Die server</td>
<td></td>
<td>服务器的描述信息，可以填一些你认为有用的</td>
</tr>
<tr>
<td>ServerWebsiteURL</td>
<td></td>
<td></td>
<td>服务器网站，一般不用设置</td>
</tr>
<tr>
<td>ServerDisabledNetworkProtocols</td>
<td>UNET</td>
<td></td>
<td>禁用的网络协议，默认的UNET即可</td>
</tr>
<tr>
<td>GameWorld</td>
<td>Navezgane</td>
<td>Navezgane ／ Random Gen</td>
<td>游戏世界设置，默认是有限的Navezgane地图，也可以改为Random Gen，即随机无限地图</td>
</tr>
<tr>
<td>GameName</td>
<td>My Game</td>
<td></td>
<td>游戏名字，如果上面填了Random Gen，这个名字将被用于随机种子生成</td>
</tr>
<tr>
<td>GameDifficulty</td>
<td>2</td>
<td>0-5</td>
<td>模式难度, 0=简单, 5=困难，填写0-5之间的数字</td>
</tr>
<tr>
<td>GameMode</td>
<td>GameModeSurvivalMP</td>
<td>GameModeSurvivalMP／GameModeSurvivalSP</td>
<td>游戏模式，MP（联网），SP（单机）（MP产生领地石效果）</td>
</tr>
<tr>
<td>ZombiesRun</td>
<td>0</td>
<td>0 =夜间狂暴，1 =永不狂暴，2 =始终狂暴</td>
<td>僵尸狂暴设置</td>
</tr>
<tr>
<td>BuildCreate</td>
<td>false</td>
<td>true/false</td>
<td>创造模式，默认关闭，开启后全体可创造</td>
</tr>
<tr>
<td>DayNightLength</td>
<td>60</td>
<td></td>
<td>游戏中24小时等于现实中多少分钟</td>
</tr>
<tr>
<td>DayLightLength</td>
<td>18</td>
<td></td>
<td>在游戏时间里，每天的阳光照射：默认白天18，夜间6</td>
</tr>
<tr>
<td>PlayerKillingMode</td>
<td>3</td>
<td>0 =无杀戮，1 =仅杀死盟友，2 =仅杀死陌生人，3 =杀死所有人</td>
<td>玩家杀戮设置</td>
</tr>
<tr>
<td>PersistentPlayerProfiles</td>
<td>false</td>
<td>true/false</td>
<td>是否拖入玩家单机资料，默认关闭，打开的话联网就完全失去了意义</td>
</tr>
<tr>
<td>PlayerSafeZoneLevel</td>
<td>5</td>
<td></td>
<td>如果玩家的等级在这个级别以下，那么他出生复活时周围不会有僵尸</td>
</tr>
<tr>
<td>PlayerSafeZoneHours</td>
<td>5</td>
<td></td>
<td>这个安全区存在的时间，是游戏中的时间</td>
</tr>
<tr>
<td>ControlPanelEnabled</td>
<td>false</td>
<td>true/false</td>
<td>启用/禁用控制面板，默认关闭</td>
</tr>
<tr>
<td>ControlPanelPort</td>
<td>8080</td>
<td></td>
<td>控制面板端口</td>
</tr>
<tr>
<td>ControlPanelPassword</td>
<td>CHANGEME</td>
<td></td>
<td>网页控制端密码</td>
</tr>
<tr>
<td>TelnetEnabled</td>
<td>true</td>
<td>true/false</td>
<td>是否开启telnet登录</td>
</tr>
<tr>
<td>TelnetPort</td>
<td>8081</td>
<td></td>
<td>telnet端口</td>
</tr>
<tr>
<td>TelnetPassword</td>
<td></td>
<td></td>
<td>telnet链接密码</td>
</tr>
<tr>
<td>AdminFileName</td>
<td>serveradmin.xml</td>
<td></td>
<td>服务器管理文件名，此文本内记录玩家白名单和黑名单以及管理员</td>
</tr>
<tr>
<td>DropOnDeath</td>
<td>2</td>
<td>0 =一切，1 =仅腰带，2 =仅背包，3 =全部删除</td>
<td>死亡掉落设置</td>
</tr>
<tr>
<td>DropOnQuit</td>
<td>0</td>
<td>0 =不掉落，1 =一切，2 =仅腰带，3 =仅背包</td>
<td>退出掉落</td>
</tr>
<tr>
<td>BloodMoonEnemyCount</td>
<td>8</td>
<td></td>
<td>在每个玩家的血月里产生的僵尸数量，第七日每个玩家刷新多少僵尸</td>
</tr>
<tr>
<td>EnemySpawnMode</td>
<td>true</td>
<td>true/false</td>
<td>启用/禁用僵尸刷新，默认开启，关掉就没有僵尸了</td>
</tr>
<tr>
<td>EnemyDifficulty</td>
<td>0</td>
<td>0 =无法感应，1 =能感应</td>
<td>僵尸能不能隔墙感应到玩家</td>
</tr>
<tr>
<td>BlockDurabilityModifier</td>
<td>100</td>
<td></td>
<td>游戏中各种方块的强度</td>
</tr>
<tr>
<td>LootAbundance</td>
<td>100</td>
<td></td>
<td>刷新物资的丰富度</td>
</tr>
<tr>
<td>LootRespawnDays</td>
<td>30</td>
<td></td>
<td>游戏中多少天刷新一次物资</td>
</tr>
<tr>
<td>LandClaimSize</td>
<td>41</td>
<td></td>
<td>领地石保护大小</td>
</tr>
<tr>
<td>LandClaimDeadZone</td>
<td>30</td>
<td></td>
<td>领地石范围不能放任何东西（除非你是与其他玩家的朋友）</td>
</tr>
<tr>
<td>LandClaimExpiryTime</td>
<td>3</td>
<td></td>
<td>玩家离线多少天不再保护</td>
</tr>
<tr>
<td>LandClaimDecayMode</td>
<td>0</td>
<td>0 =线性，1 =指数，2 =完全保护，直到过期</td>
<td>离线玩家领地石衰落</td>
</tr>
<tr>
<td>LandClaimOnlineDurabilityModifier</td>
<td>4</td>
<td>0表示无敌（不会损坏）。 默认值为4</td>
<td>当玩家在线时，领地石保护硬度增加了多少</td>
</tr>
<tr>
<td>LandClaimOfflineDurabilityModifier</td>
<td>4</td>
<td>0表示无敌（不会损坏）。 默认值为4</td>
<td>当玩家离线时，领地石硬度会增加</td>
</tr>
<tr>
<td>AirDropFrequency</td>
<td>72</td>
<td>0 = 从不</td>
<td>空投，在游戏时间里多少小时一次</td>
</tr>
<tr>
<td>AirDropMarker</td>
<td>false</td>
<td>true/false</td>
<td>是否在地图上开启空头标志</td>
</tr>
<tr>
<td>MaxSpawnedZombies</td>
<td>80</td>
<td></td>
<td>丧尸刷新数（超过80个）可能会导致服务器运行在较差的帧率，这将影响客户的延迟和流畅度</td>
</tr>
<tr>
<td>MaxSpawnedAnimals</td>
<td>50</td>
<td></td>
<td>服务器生成动物的数量</td>
</tr>
<tr>
<td>EACEnabled</td>
<td>true</td>
<td>true/false</td>
<td>Eac校验，如果关了外挂就进来了</td>
</tr>
<tr>
<td>HideCommandExecutionLog</td>
<td>0</td>
<td>0 =显示所有内容，1 =仅从Telnet / ControlPanel隐藏，2 =也隐藏远程游戏客户端，3 =隐藏所有内容</td>
<td>隐藏命令执行记录</td>
</tr>
<tr>
<td>MaxUncoveredMapChunksPerPlayer</td>
<td>131072</td>
<td></td>
<td>覆盖每个玩家在游戏地图上可以发现多少块。 最大地图文件大小为512字节。 默认131072意味着最多32公里2可以随时发现</td>
</tr>
<tr>
<td>BedrollDeadZoneSize</td>
<td>15</td>
<td></td>
<td>死亡区域的大小，这个区域内不会产生僵尸，任何清除的睡眠者数量，触摸死板死亡区域将不会产生后</td>
</tr>
<tr>
<td>SaveGameFolder</td>
<td></td>
<td></td>
<td>存盘位置，linux版本默认是注释掉的，windows版可以设置</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sheng-ji-xi-tong&quot;&gt;升级系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chuang-jian-zhang-hu&quot;&gt;创建账
    
    </summary>
    
    
      <category term="Game Server" scheme="https://www.kanshouce.com/tags/Game-Server/"/>
    
      <category term="7 Days To Die" scheme="https://www.kanshouce.com/tags/7-Days-To-Die/"/>
    
  </entry>
  
  <entry>
    <title>利用github的webhook自动化部署(PHP)</title>
    <link href="https://www.kanshouce.com/2017/11/09/github-webhook/"/>
    <id>https://www.kanshouce.com/2017/11/09/github-webhook/</id>
    <published>2017-11-09T09:21:40.000Z</published>
    <updated>2017-11-09T10:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="she-zhi-github">设置GITHUB</span></h1><p>在项目页的<code>Settings</code> -&gt; <code>Webhooks</code>中设置</p>
<ul>
<li><p><code>Raload URL</code> 填写每次调用的钩子地址；</p>
</li>
<li><p><code>Secret</code> 设置一个密码，后面会用到。</p>
</li>
</ul>
<p><img src="https://pic.kanshouce.com/blog/2017-11-09-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%885.22.49.png?x-oss-process=style/JPG" alt=""></p>
<h1><span id="fu-wu-qi-webhook-wen-jian">服务器webhook文件</span></h1><ul>
<li><code>$secret = &quot;&quot;</code> 这里填入你在github上设置的秘钥</li>
<li><code>$path = &quot;&quot;</code> 这里填你在服务器的项目根目录</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// 填写你在github设置页面中设置的密钥（Keep it the same with the 'Secret' field on your Webhooks / Manage webhook page of your respostory）</span></div><div class="line">$secret = <span class="string">""</span>;</div><div class="line"><span class="comment">// 项目根目录, 如: "/var/www/xxxbbs"</span></div><div class="line">$path = <span class="string">""</span>;</div><div class="line"><span class="comment">// Headers deliveried from GitHub</span></div><div class="line">$signature = $_SERVER[<span class="string">'HTTP_X_HUB_SIGNATURE'</span>];</div><div class="line"><span class="keyword">if</span> ($signature) &#123;</div><div class="line">  $hash = <span class="string">"sha1="</span> . hash_hmac(<span class="string">'sha1'</span>, $HTTP_RAW_POST_DATA, $secret);</div><div class="line">  <span class="keyword">if</span> (strcmp($signature, $hash) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">echo</span> shell_exec(<span class="string">"cd &#123;$path&#125; &amp;&amp; /usr/bin/git reset --hard origin/master &amp;&amp; /usr/bin/git clean -f &amp;&amp; /usr/bin/git pull 2&gt;&amp;1"</span>);</div><div class="line">      <span class="keyword">exit</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">http_response_code(<span class="number">404</span>);</div></pre></td></tr></table></figure>
<h2><span id="geng-xin-ming-ling-shuo-ming">更新命令说明</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shell_exec(<span class="string">"cd &#123;<span class="variable">$path</span>&#125; &amp;&amp; /usr/bin/git reset --hard origin/master &amp;&amp; /usr/bin/git clean -f &amp;&amp; /usr/bin/git pull 2&gt;&amp;1"</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p><code>/usr/bin/git reset --hard origin/master</code> 强制恢复版本到前一个稳定版</p>
</li>
<li><p><code>/usr/bin/git clean -f</code> 清理提交的更改</p>
</li>
<li><p><code>/usr/bin/git pull 2&gt;&amp;1</code> 拉取最新的版本到本地</p>
</li>
</ul>
<p><strong>这里需要注意是，如果<code>webhook</code>和<code>网站</code>处于<code>同目录</code>，用上面的命令<code>webhook</code>文件将被清理。<br>所以请根据实际应用场景部署。</strong></p>
<h1><span id="planb-shell-geng-xin">PlanB shell更新</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">WEB_PATH=<span class="string">'/var/www/webbbs'</span></div><div class="line">WEB_USER=<span class="string">'nginx'</span></div><div class="line">WEB_USERGROUP=<span class="string">'nginx'</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Start deployment"</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$WEB_PATH</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"pulling source code..."</span></div><div class="line">git reset --hard origin/master</div><div class="line">git clean <span class="_">-f</span></div><div class="line">git pull</div><div class="line">git checkout master</div><div class="line"><span class="built_in">echo</span> <span class="string">"changing permissions..."</span></div><div class="line">chown -R <span class="variable">$WEB_USER</span>:<span class="variable">$WEB_USERGROUP</span> <span class="variable">$WEB_PATH</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Finished."</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;&lt;span id=&quot;she-zhi-github&quot;&gt;设置GITHUB&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在项目页的&lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Webhooks&lt;/code&gt;中设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Raload 
    
    </summary>
    
      <category term="github" scheme="https://www.kanshouce.com/categories/github/"/>
    
    
      <category term="github" scheme="https://www.kanshouce.com/tags/github/"/>
    
      <category term="webhook" scheme="https://www.kanshouce.com/tags/webhook/"/>
    
      <category term="php" scheme="https://www.kanshouce.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>一个用Jquery遍历tbale表单获取值的例子</title>
    <link href="https://www.kanshouce.com/2017/08/12/jquery-Array-table/"/>
    <id>https://www.kanshouce.com/2017/08/12/jquery-Array-table/</id>
    <published>2017-08-11T18:48:34.000Z</published>
    <updated>2017-11-09T09:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个用Jquery的简单例子。</p>
<a id="more"></a>
<p>假设一个网页有N张表，就像本站的<code>阅读者</code><a href="/reader">频道</a>一样，需要获取每张表的最后一个值，这时候要用到两个知识点：</p>
<ul>
<li>遍历</li>
<li>数组栈</li>
</ul>
<p><code>阅读者</code>频道在尾部的进度条<code>x%</code>值获取实现就是基础在这段小脚本上。当然，在实现的过程中没有用到出入栈的概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先等待页面的DOM树加载完</span></div><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> $Uname = $(<span class="string">"tbody"</span>).length;   <span class="comment">//取到页面内tbody标签出现了多少次</span></div><div class="line">            <span class="keyword">var</span> Data = [];</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; $Uname; i++) &#123;    <span class="comment">//根据tbody标签出现的次数进行遍历次数</span></div><div class="line">                $a = $(<span class="string">"div tbody"</span>).eq(i).find(<span class="string">"td:last"</span>).text();   <span class="comment">//根据jq条件查询到（td:last），每个td最后一行的数据。</span></div><div class="line">                Data.push($a);                <span class="comment">//用push()的方法将数据入站</span></div><div class="line">             &#125;</div><div class="line">        $(<span class="string">"#1"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">0</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);   <span class="comment">//修改DOM上的值</span></div><div class="line">        $(<span class="string">"#2"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">1</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);</div><div class="line">        $(<span class="string">"#3"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">2</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);</div><div class="line">        &#125;</div><div class="line">        );</div></pre></td></tr></table></figure>
<p>这里用到了Javescript常用的数组方法：<code>push()</code></p>
<p>在数组栈里出了<code>push()</code>还有一个方法是<code>pop()</code>，这两种方法都允许将数组当作<strong>栈</strong>来使用，用<code>push()</code>会在数组的尾部添加一个或者多个元素，并返回数组新的长度。<code>pop()</code>则正好相反，它的作用是删除数组的最后一个元素，减小数组的长度并返回它删除的值，在犀牛书里，特意描述了需要注意的部分：</p>
<blockquote>
<p>两个方法都修改并替换原始数组而并非生成一个修改版的新数组。组合使用<code>push()</code>和<code>pop()</code>能够用Javascript数组实现先后出栈。</p>
</blockquote>
<h2><span id="guan-yu-zhan">关于“栈”</span></h2><p>这里我们先补一下关于<strong>栈</strong>的知识点：</p>
<blockquote>
<p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<p>栈是限定仅在表头进行插入和删除操作的线性表。</p>
<p>就好比：一个死胡同，前面是“此路不通”，只有一个入口，如果一队人进入，只能队尾变对首出去。</p>
</blockquote>
<p>在<code>出栈</code>和<code>入栈</code>的概念上，用图示大概是这样的：</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-push1.png" alt=""></p>
<p>用<code>push()</code>和<code>pop()</code>模拟一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> temp = i + <span class="number">1</span>;</div><div class="line">        arr.push(temp);</div><div class="line">        <span class="built_in">console</span>.log(temp + <span class="string">"  入栈"</span>);</div><div class="line">        <span class="built_in">console</span>.log(arr);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'栈，先进后出'</span>);  </div><div class="line">    <span class="keyword">var</span> len = arr.length;               <span class="comment">//这个地方需要注意，因为在出栈的过程arr.length是变化的，每移除一个元素，arr.length就会减一，所以需要将其赋值给一个变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">console</span>.log(arr.pop());</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>结果是：</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-push2.png" alt=""></p>
<h2><span id="guan-yu-dui-lie">关于“队列”</span></h2><p>这里另外一个知识点是关于队列的</p>
<p>队列在javascript里用的是<code>unshift()</code>和<code>pop()</code>方法。</p>
<blockquote>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>就好比：现在这个胡同不是死胡同了，队伍可以直接通过。</p>
</blockquote>
<p>模拟一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">        <span class="keyword">var</span> arr = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">var</span> temp = i + <span class="number">1</span>;</div><div class="line">            arr.unshift(temp);</div><div class="line">            <span class="built_in">console</span>.log(temp + <span class="string">"  插入"</span>);</div><div class="line">            <span class="built_in">console</span>.log(arr);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'队列，先进先出 First In First Out'</span>);    </div><div class="line">        <span class="keyword">var</span> len = arr.length;               <span class="comment">//这个地方需要注意，因为在删除的过程arr.length是变化的，每移除一个元素，arr.length就会减一，所以需要将其赋值给一个变量</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="built_in">console</span>.log(arr.pop());</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-p3.png" alt=""></p>
<p><code>unshift()</code>和<code>shift()</code>在用法上实际上是一对的，他们非常类似<code>push()</code>和<code>pop()</code>，不一样的是前者是在数组头部而非尾部进行元素插入和删除操作。<code>unshift()</code>在数组头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个用Jquery的简单例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://www.kanshouce.com/categories/Javascript/"/>
    
    
      <category term="Jquery" scheme="https://www.kanshouce.com/tags/Jquery/"/>
    
      <category term="WEB" scheme="https://www.kanshouce.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>没错！可以用RTL-SDR观测闪电！</title>
    <link href="https://www.kanshouce.com/2017/08/12/rtl-view-lightning/"/>
    <id>https://www.kanshouce.com/2017/08/12/rtl-view-lightning/</id>
    <published>2017-08-11T18:34:05.000Z</published>
    <updated>2017-08-11T18:40:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>据说有个笑话是这样的：<code>我要瘦成一道闪电</code>，说它是笑话是因为闪电根据统计宽度达<code>4米</code>，这明明就是想减肥人的噩梦！</p>
<a id="more"></a>
<p>为什么能用RTL-SDR观测到闪电？</p>
<blockquote>
<p>因为闪电产生相当宽的RF能量突发</p>
</blockquote>
<p>特别是在VLF中低频到HF频率</p>
<p>国外有很多专业用定制的硬件来观测闪电突发的，比如说这个<a href="blitzortung.org">blitzortung.org</a>。</p>
<p>当然，你也可以使用RTL-SDR调谐到HF，例如在RTL-SDR V3或具有上变频器的RTL-SDR。在一个歪果仁的网站上Kenn Ranous（KA0SBL）上传了一篇<a href="https://ranous.wordpress.com/2017/08/03/diy-lightning-detection-with-sdr/" target="_blank" rel="external">短片</a>，显示了他在RTL-SDR瀑布上闪电的样子。他使用RTL-SDR V3调谐到LF-MW频段，并可以找到指示闪电的宽带噪声脉冲。</p>
<p>看看这种类型的检测是否可以通过DSP进行自动化是非常趣的，如果有足够的兴趣，甚至可以搭建一个Blitzortung.org类似的服务。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-lightning1.png?x-oss-process=style/JPG" alt=""></p>
<p>闪电脉冲</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;据说有个笑话是这样的：&lt;code&gt;我要瘦成一道闪电&lt;/code&gt;，说它是笑话是因为闪电根据统计宽度达&lt;code&gt;4米&lt;/code&gt;，这明明就是想减肥人的噩梦！&lt;/p&gt;
    
    </summary>
    
      <category term="RTL-SDR" scheme="https://www.kanshouce.com/categories/RTL-SDR/"/>
    
    
      <category term="RTL" scheme="https://www.kanshouce.com/tags/RTL/"/>
    
      <category term="lightning" scheme="https://www.kanshouce.com/tags/lightning/"/>
    
  </entry>
  
  <entry>
    <title>这是一个加密测试</title>
    <link href="https://www.kanshouce.com/2017/08/12/encrypt-test/"/>
    <id>https://www.kanshouce.com/2017/08/12/encrypt-test/</id>
    <published>2017-08-11T17:33:42.000Z</published>
    <updated>2017-08-11T18:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3><span id="welcome-to-my-blog-enter-password-to-read">Welcome to my blog, enter password to read.</span></h3><script src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入密码 "> <label for="pass"> Enter </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/IXnx+OCL9MkiOY5IsCdGD50Gk8nw0At6TphUCxWlf+1xSfhF9AADNB1yDzp2YZtswUObluHTBF7iMYONylC6sMDQ+TvkwRgE2v1aL7cfwsthShjQTQG4hb+pVRRDV889FgT5xbtctttS7+FZPIRYZjgGcQMydfxYCMSqVXROGX484cMn+Ei2W951rIyJZdnJiME5XTPi5Dw4YQoKNkGp584Uf9N0BnpP43TSZTzgNcXoTXt+p7Bic </div>]]></content>
    
    <summary type="html">
    
      the content has been encrypted, enter the password to read.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>egg-static 中文说明</title>
    <link href="https://www.kanshouce.com/2017/08/10/egg-static/"/>
    <id>https://www.kanshouce.com/2017/08/10/egg-static/</id>
    <published>2017-08-10T10:23:54.000Z</published>
    <updated>2017-08-10T10:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自Github Egg项目页</p>
<p><a href="https://github.com/eggjs/egg-static" target="_blank" rel="external">直达戳我</a></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#egg-static">egg-static</a><ul>
<li><a href="#an-zhuang">安装</a></li>
<li><a href="#shi-yong">使用</a></li>
<li><a href="#shi-yong-1">使用</a></li>
<li><a href="#pei-zhi">配置</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>

<h1><span id="egg-static">egg-static</span></h1><p>静态服插件，基础与koa的静态插件 <a href="https://github.com/koajs/static-cache" target="_blank" rel="external">koa-static-cache</a>.</p>
<h2><span id="an-zhuang">安装</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i egg-static --save</div></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span></h2><p>在Egg的官方手册里是这样介绍的</p>
<p>Egg 内置了 <code>static</code> 插件，线上环境建议部署到 CDN，无需该插件。</p>
<p><code>static</code> 插件默认映射 <code>/public/*</code> -&gt; <code>app/public/*</code> 目录</p>
<p>此处，我们把静态资源都放到 <code>app/public</code> 目录即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app/public</div><div class="line">├── css</div><div class="line">│   └── news.css</div><div class="line">└── js</div><div class="line">    ├── lib.js</div><div class="line">    └── news.js</div></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span></h2><p>如果没有特别的要求，egg的脚手架对这个功能是默认开启的，在配置文件<code>plugin.js</code>里可以选择开启或关闭：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// had enabled by egg</span></div><div class="line">exports.static = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h2><span id="pei-zhi">配置</span></h2><p><code>egg-static</code> 支持 <a href="https://github.com/koajs/static-cache" target="_blank" rel="external">koa-static-cache</a>中的所有配置。 支持的配置如下：</p>
<ul>
<li>prefix: <code>/public/</code></li>
<li>dir: <code>path.join(appInfo.baseDir, &#39;app/public&#39;)</code></li>
<li>dynamic: <code>true</code></li>
<li>preload: <code>false</code></li>
<li>maxAge: <code>31536000</code> in prod env, <code>0</code> in other envs</li>
<li>buffer: <code>true</code> in prod env, <code>false</code> in other envs</li>
</ul>
<p><code>egg-static</code> 提供了一个更多的选项</p>
<ul>
<li>maxFiles: 缓存项目的最大值，仅在动态为<code>true</code>时有效，默认为<code>“1000”</code>。</li>
</ul>
<p><strong>所有的静态文件位于 <code>$baseDir/app/public</code> 在模版或调用的地方可以用 <code>/public</code>访问。所有的文件都会被加载</strong>。</p>
<ul>
<li>在非生产环境中，数据不会被缓存，修改可以立即生效。</li>
<li>在生产环境中，<code>egg-static</code>将在访问后缓存数据，需要重新启动更新数据。</li>
<li>默认目录是 <code>$baseDir/app/public</code> <strong>但是可以定义多个目录</strong> 用 <code>dir: [dir1, dir2, ...]</code> 在加载的时候服务器会加载这些目录</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &#123;app_root&#125;/config/config.default.js</span></div><div class="line">exports.static = &#123;</div><div class="line">  <span class="comment">// maxAge: 31536000,</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2><span id="license">License</span></h2><p><a href="https://github.com/eggjs/egg-static/blob/master/LICENSE" target="_blank" rel="external">MIT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自Github Egg项目页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eggjs/egg-static&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;直达戳我&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!--
    
    </summary>
    
      <category term="egg" scheme="https://www.kanshouce.com/categories/egg/"/>
    
    
      <category term="egg-static" scheme="https://www.kanshouce.com/tags/egg-static/"/>
    
      <category term="egg" scheme="https://www.kanshouce.com/tags/egg/"/>
    
  </entry>
  
  <entry>
    <title>koa-guide-v2</title>
    <link href="https://www.kanshouce.com/2017/08/10/koa-guide-v2/"/>
    <id>https://www.kanshouce.com/2017/08/10/koa-guide-v2/</id>
    <published>2017-08-10T10:06:08.000Z</published>
    <updated>2017-08-10T10:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份<br><a id="more"></a></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#zhong-wen-wen-dang">中文文档</a><ul>
<li><a href="#koa-jian-jie">koa 简介</a></li>
<li><a href="#an-zhuang-koa">安装 koa</a><ul>
<li><a href="#shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</a></li>
</ul>
</li>
<li><a href="#ying-yong-application">应用（Application）</a></li>
<li><a href="#ji-lian-dai-ma-cascading">级联代码（Cascading）</a></li>
<li><a href="#ying-yong-pei-zhi-settings">应用配置（Settings）</a></li>
<li><a href="#zhong-jian-jian-middleware">中间件（Middleware）</a></li>
<li><a href="#chang-yong-fang-fa">常用方法</a><ul>
<li><a href="#app-listen">app.listen(…)</a></li>
<li><a href="#app-callback">app.callback()</a></li>
<li><a href="#app-use-function">app.use(function)</a></li>
<li><a href="#app-keys">app.keys=</a></li>
</ul>
</li>
<li><a href="#cuo-wu-chu-li-error-handling">错误处理（Error Handling）</a></li>
<li><a href="#ying-yong-shang-xia-wen-context">应用上下文（Context）</a><ul>
<li><a href="#request-dui-xiang">Request 对象</a></li>
<li><a href="#response-dui-xiang">Response 对象</a></li>
<li><a href="#shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</a></li>
</ul>
</li>
<li><a href="#request">Request</a><ul>
<li><a href="#req-header">req.header</a></li>
<li><a href="#req-method">req.method</a></li>
<li><a href="#req-method">req.method=</a></li>
<li><a href="#req-length">req.length</a></li>
<li><a href="#req-url">req.url</a></li>
<li><a href="#req-url">req.url=</a></li>
<li><a href="#req-path">req.path</a></li>
<li><a href="#req-path">req.path=</a></li>
<li><a href="#req-querystring">req.querystring</a></li>
<li><a href="#req-querystring">req.querystring=</a></li>
<li><a href="#req-search">req.search</a></li>
<li><a href="#req-search">req.search=</a></li>
<li><a href="#req-host">req.host</a></li>
<li><a href="#req-type">req.type</a></li>
<li><a href="#req-query">req.query</a></li>
<li><a href="#req-query">req.query=</a></li>
<li><a href="#req-fresh">req.fresh</a></li>
<li><a href="#req-stale">req.stale</a></li>
<li><a href="#req-protocol">req.protocol</a></li>
<li><a href="#req-secure">req.secure</a></li>
<li><a href="#req-ip">req.ip</a></li>
<li><a href="#req-ips">req.ips</a></li>
<li><a href="#req-subdomains">req.subdomains</a></li>
<li><a href="#req-is-type">req.is(type)</a></li>
<li><a href="#req-accepts-type">req.accepts(type)</a></li>
<li><a href="#req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</a></li>
<li><a href="#req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</a></li>
<li><a href="#req-acceptslanguages-langs">req.acceptsLanguages(langs)</a></li>
</ul>
</li>
<li><a href="#response">Response</a><ul>
<li><a href="#res-header">res.header</a></li>
<li><a href="#res-status">res.status</a></li>
<li><a href="#res-status">res.status=</a></li>
<li><a href="#res-length">res.length=</a></li>
<li><a href="#res-length">res.length</a></li>
<li><a href="#res-body">res.body</a></li>
<li><a href="#res-body">res.body=</a></li>
<li><a href="#res-get-field">res.get(field)</a></li>
<li><a href="#res-set-field-value">res.set(field, value)</a></li>
<li><a href="#res-set-fields">res.set(fields)</a></li>
<li><a href="#res-remove-fields">res.remove(fields)</a></li>
<li><a href="#res-type">res.type</a></li>
<li><a href="#res-type">res.type=</a></li>
<li><a href="#res-redirect-url-alt">res.redirect(url, [alt])</a></li>
<li><a href="#res-attachment-filename">res.attachment([filename])</a></li>
<li><a href="#res-headersent">res.headerSent</a></li>
<li><a href="#res-lastmodified">res.lastModified</a></li>
<li><a href="#res-etag">res.etag=</a></li>
</ul>
</li>
<li><a href="#xing-neng-benchmarks">性能（Benchmarks）</a></li>
<li><a href="#xue-xi-zi-liao">学习资料</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#mit-license">MIT license</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>




<h1><span id="zhong-wen-wen-dang">中文文档</span></h1><p>Koa，下一代 Node.js web 框架</p>
<h2><span id="koa-jian-jie">koa 简介</span></h2><p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p>
<h2><span id="an-zhuang-koa">安装 koa</span></h2><p>Koa需要支持ES2015和<code>async</code> function的node v7.6.0或更高版本。</p>
<p>您可以使用喜欢的依赖管理工具快速安装支持的node版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nvm install 7</div><div class="line">$ npm i koa</div><div class="line">$ node my-koa-app.js</div></pre></td></tr></table></figure>
<h3><span id="shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</span></h3><p>在node 7.6版本以下，如果你想在koa里使用<code>async</code> functions，我们推荐<a href="http://babeljs.io/docs/usage/require/" target="_blank" rel="external">babel</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(&apos;babel-core/register&apos;);</div><div class="line">// require the rest of the app that needs to be transpiled after the hook</div><div class="line">const app = require(&apos;./app&apos;);</div></pre></td></tr></table></figure>
<p>你至少要使用<a href="http://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="external">transform-async-to-generator</a> or <a href="http://babeljs.io/docs/plugins/transform-async-to-module-method/" target="_blank" rel="external">transform-async-to-module-method</a>插件，<br>来解析和转译async functions。例如，你可以在你的<code>.babelrc</code>文件里这样写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-async-to-generator"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">env preset</a>里使用目标选项<code>&quot;node&quot;: &quot;current&quot;</code>。</p>
<hr>
<h2><span id="ying-yong-application">应用（Application）</span></h2><p>一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect/Express ）没有什么太大差别，不过，从另一个层面来看，Koa 提供了一种基于底层中间件编写「语法糖」的设计思路，这让设计中间件变得更简单有趣。</p>
<p>在这些中间件中，有负责内容协商（content-negotation）、缓存控制（cache freshness）、反向代理（proxy support）与重定向等等功能的常用中间件（详见 <a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6middleware">中间件</a> 章节），但如前所述， Koa 内核并不会打包这些中间件，让我们先来看看 Koa 极其简单的 Hello World 应用程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果使用Koa 2的话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</div><div class="line">  ctx.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p><strong>译者注：</strong> 与普通的 function 不同，generator functions 以 <code>function*</code> 声明，以这种关键词声明的函数支持 <code>yield</code>。generator function是ECMAScript 6定义的新的语法，想了解其基本用法，以及Koa如何利用generator function达到在保持js代码异步特性的同时无需编写大量回调函数，可以参考<a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/" target="_blank" rel="external">这篇文章</a>。</p>
<hr>
<h2><span id="ji-lian-dai-ma-cascading">级联代码（Cascading）</span></h2><p>Koa 中间件以一种非常传统的方式级联起来，你可能会非常熟悉这种写法。</p>
<p>在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 <code>yield next</code> 关键字时，会被传递到下一个符合请求的路由（downstream），在 <code>yield next</code> 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
<p>下边这个例子展现了使用这一特殊方法书写的 Hello World 范例：一开始，用户的请求通过 x-response-time 中间件和 logging 中间件，这两个中间件记录了一些请求细节，然后「穿过」 response 中间件一次，最终结束请求，返回 「Hello World」。</p>
<p>当程序运行到 <code>yield next</code> 时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码，这样切换控制权的方式，被称为<br>downstream，当没有下一个中间件执行 downstream 的时候，代码将会逆序执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line"><span class="comment">// x-response-time</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (1) 进入路由</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);</div><div class="line">  <span class="comment">// (6) 返回 this.body</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// logger</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (2) 进入 logger 中间件</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// response</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream</span></div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>在上方的范例代码中，中间件依次被执行的顺序已经在注释中标记出来。你也可以自己尝试运行一下这个范例，并打印记录下各个环节的输出与耗时。</p>
<p><strong>译者注：</strong> 「级联」这个词许多人也许在 CSS 中听说过，如果你不能理解为什么在这里使用这个词，可以将这种路由结构想象成 LESS 的继承嵌套书写方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.middleware1 &#123;</div><div class="line">  // (1) do some stuff</div><div class="line">  .middleware2 &#123;</div><div class="line">    // (2) do some other stuff</div><div class="line">    .middleware3 &#123;</div><div class="line">      // (3) NO next yield !</div><div class="line">      // this.body = &apos;hello world&apos;</div><div class="line">    &#125;</div><div class="line">    // (4) do some other stuff later</div><div class="line">  &#125;</div><div class="line">  // (5) do some stuff lastest and return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上方的伪代码中标注了中间件的执行顺序，看起来是不是有点像 ruby 执行代码块（block）时 yield 的表现了？也许这能帮助你更好的理解 koa 运作的方式。</p>
<p><strong>译者注：</strong> 更加形象的图可以参考 <a href="https://docs.djangoproject.com/en/1.6/topics/http/middleware/" target="_blank" rel="external">Django Middleware</a></p>
<p><img src="https://raw.github.com/fengmk2/koa-guide/master/onion.png" alt="onion.png"></p>
<hr>
<h2><span id="ying-yong-pei-zhi-settings">应用配置（Settings）</span></h2><p>应用的配置是 app 实例的属性。目前来说，Koa 的配置项如下：</p>
<ul>
<li>app.name 应用名称</li>
<li>app.env 执行环境，默认是 <code>NODE_ENV</code> 或者 <code>&quot;development&quot;</code> 字符串</li>
<li>app.proxy 决定了哪些 <code>proxy header</code> 参数会被加到信任列表中</li>
<li>app.subdomainOffset 被忽略的 <code>.subdomains</code> 列表，详见下方 api</li>
</ul>
<hr>
<h2><span id="zhong-jian-jian-middleware">中间件（Middleware）</span></h2><ul>
<li><a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="external">koa-router</a></li>
<li><a href="https://github.com/koajs/trie-router" target="_blank" rel="external">trie-router</a></li>
<li><a href="https://github.com/koajs/route" target="_blank" rel="external">route</a></li>
<li><a href="https://github.com/koajs/basic-auth" target="_blank" rel="external">basic-auth</a></li>
<li><a href="https://github.com/koajs/etag" target="_blank" rel="external">etag</a></li>
<li><a href="https://github.com/koajs/compose" target="_blank" rel="external">compose</a></li>
<li><a href="https://github.com/koajs/static" target="_blank" rel="external">static</a></li>
<li><a href="https://github.com/koajs/static-cache" target="_blank" rel="external">static-cache</a></li>
<li><a href="https://github.com/koajs/session" target="_blank" rel="external">session</a></li>
<li><a href="https://github.com/koajs/compress" target="_blank" rel="external">compress</a></li>
<li><a href="https://github.com/koajs/csrf" target="_blank" rel="external">csrf</a></li>
<li><a href="https://github.com/koajs/logger" target="_blank" rel="external">logger</a></li>
<li><a href="https://github.com/koajs/mount" target="_blank" rel="external">mount</a></li>
<li><a href="https://github.com/koajs/send" target="_blank" rel="external">send</a></li>
<li><a href="https://github.com/koajs/error" target="_blank" rel="external">error</a></li>
</ul>
<hr>
<h2><span id="chang-yong-fang-fa">常用方法</span></h2><h3><span id="app-listen">app.listen(…)</span></h3><p>用于启动一个服务的快捷方法，以下范例代码在 3000 端口启动了一个空服务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>app.listen 是 http.createServer 的简单包装，它实际上这样运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果有需要，你可以在多个端口上启动一个 app，比如同时支持 HTTP 和 HTTPS：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div><div class="line">http.createServer(app.callback()).listen(<span class="number">3001</span>);</div></pre></td></tr></table></figure>
<h3><span id="app-callback">app.callback()</span></h3><p>返回一个可被 <code>http.createServer()</code> 接受的程序实例，也可以将这个返回函数挂载在一个 Connect/Express 应用中。</p>
<h3><span id="app-use-function">app.use(function)</span></h3><p>将给定的 function 当做中间件加载到应用中，详见 <a href="#middleware">中间件</a> 章节</p>
<h3><span id="app-keys">app.keys=</span></h3><p>设置一个签名 Cookie 的密钥。这些参数会被传递给 <a href="https://github.com/jed/keygrip" target="_blank" rel="external">KeyGrip</a> 如果你想自己生成一个实例，也可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.keys = [<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>];</div><div class="line">app.keys = <span class="keyword">new</span> KeyGrip([<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>], <span class="string">'sha256'</span>);</div></pre></td></tr></table></figure>
<p>注意，签名密钥只在配置项 <code>signed</code> 参数为真时才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.cookies.set(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</div></pre></td></tr></table></figure>
<h2><span id="cuo-wu-chu-li-error-handling">错误处理（Error Handling）</span></h2><p>除非 <code>NODE_ENV</code> 被配置为 <code>&quot;test&quot;</code>，Koa 都将会将所有错误信息输出到 <code>stderr</code>，也可以自定义「错误事件」来监听 Koa app 中发生的错误，比如记录错误日志：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当任何 <code>req</code> 或者 <code>res</code> 中出现的错误无法被回应到客户端时，Koa 会在第二个参数传入这个错误的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err, ctx);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>任何错误有可能被回应到客户端，比如当没有新数据写入 socket 时，Koa 会默认返回一个 500 错误，并抛出一个 app 级别的错误到日志处理中间件中。</p>
<hr>
<h2><span id="ying-yong-shang-xia-wen-context">应用上下文（Context）</span></h2><p>Koa 的上下文封装了 request 与 response 对象至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。为了方便，你可以在 <code>ctx.request</code> 和 <code>ctx.response</code> 中访问到这些方法。</p>
<p>每一个请求都会创建一段上下文。在控制业务逻辑的中间件中，上下文被寄存在 <code>this</code> 对象中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>; <span class="comment">// 上下文对象</span></div><div class="line">  <span class="keyword">this</span>.request; <span class="comment">// Request 对象</span></div><div class="line">  <span class="keyword">this</span>.response; <span class="comment">// Response 对象</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了使用方便，许多上下文属性和方法都被委托代理到他们的 <code>ctx.request</code> 或 <code>ctx.response</code>，比如访问 <code>ctx.type</code> 和 <code>ctx.length</code> 将被代理到 <code>response</code> 对象，<code>ctx.path</code> 和 <code>ctx.method</code> 将被代理到 <code>request</code> 对象。</p>
<h3><span id="request-dui-xiang">Request 对象</span></h3><p>ctx.request 对象包括以下属性和别名方法，详见 <a href="#request">Request</a> 章节</p>
<ul>
<li>ctx.header</li>
<li>ctx.method</li>
<li>ctx.method=</li>
<li>ctx.url</li>
<li>ctx.url=</li>
<li>ctx.path</li>
<li>ctx.path=</li>
<li>ctx.query</li>
<li>ctx.query=</li>
<li>ctx.querystring</li>
<li>ctx.querystring=</li>
<li>ctx.length</li>
<li>ctx.host</li>
<li>ctx.fresh</li>
<li>ctx.stale</li>
<li>ctx.socket</li>
<li>ctx.protocol</li>
<li>ctx.secure</li>
<li>ctx.ip</li>
<li>ctx.ips</li>
<li>ctx.subdomains</li>
<li>ctx.is()</li>
<li>ctx.accepts()</li>
<li>ctx.acceptsEncodings()</li>
<li>ctx.acceptsCharsets()</li>
<li>ctx.acceptsLanguages()</li>
<li>ctx.get()</li>
</ul>
<h3><span id="response-dui-xiang">Response 对象</span></h3><p>ctx.response 对象包括以下属性和别名方法，详见 <a href="#response">Response</a> 章节</p>
<ul>
<li>ctx.body</li>
<li>ctx.body=</li>
<li>ctx.status</li>
<li>ctx.status=</li>
<li>ctx.length=</li>
<li>ctx.type</li>
<li>ctx.type=</li>
<li>ctx.headerSent</li>
<li>ctx.redirect()</li>
<li>ctx.attachment()</li>
<li>ctx.set()</li>
<li>ctx.remove()</li>
<li>ctx.lastModified=</li>
<li>ctx.etag=</li>
</ul>
<h3><span id="shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</span></h3><ul>
<li>ctx.req: Node.js 中的 request 对象</li>
<li>ctx.res: Node.js 中的 response 对象，方法有:<ul>
<li>res.statusCode</li>
<li>res.writeHead()</li>
<li>res.write()</li>
<li>res.end()</li>
</ul>
</li>
<li>ctx.app: app 实例</li>
<li>ctx.state: 推荐的命名空间，用来保存那些通过中间件传递给视图的参数或数据。比如 <code>this.state.user = yield User.find(id);</code></li>
<li>ctx.cookies.get(name, [options]) 对于给定的 name ，返回响应的 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
</ul>
</li>
</ul>
</li>
<li>ctx.cookies.set(name, value, [options]) 对于给定的参数，设置一个新 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
<li><code>expires</code> [date]</li>
<li><code>path</code> [string] 默认为 <code>&#39;/&#39;</code></li>
<li><code>domain</code> [string]</li>
<li><code>secure</code> [boolean]</li>
<li><code>httpOnly</code> [boolean] 默认为 <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>ctx.throw(msg, [status]) 抛出常规错误的辅助方法，默认 status 为 500。</li>
</ul>
<p>以下几种写法都有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.throw(<span class="number">403</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'name required'</span>, <span class="number">400</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="number">400</span>, <span class="string">'name required'</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'something exploded'</span>)</div></pre></td></tr></table></figure>
<p>实际上，<code>this.throw(&#39;name required&#39;, 400)</code> 是此代码片段的简写方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'name required'</span>);</div><div class="line">err.status = <span class="number">400</span>;</div><div class="line"><span class="keyword">throw</span> err;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>ctx.throw</code> 创建的错误，均为用户级别错误（标记为err.expose），会被返回到客户端。</p>
<ul>
<li>ctx.assert(value, [msg], [status], [properties]) 用来断言的辅助方法，类似 Node 中的 <code>assert()</code> 方法。<code>this.assert(this.user, 401, &#39;User not found. Please login!&#39;);</code> 此方法由 <code>http-assert</code> 模块支持。</li>
</ul>
<hr>
<h2><span id="request">Request</span></h2><p>ctx.request 对象是对 Node 原生请求对象的抽象包装，提供了一些非常有用的方法。</p>
<p>详细的 Request 对象 API 如下：</p>
<h3><span id="req-header">req.header</span></h3><p>返回请求头</p>
<h3><span id="req-method">req.method</span></h3><p>返回请求方法</p>
<h3><span id="req-method">req.method=</span></h3><p>设置 req.method ，用于实现输入 <code>methodOverride()</code> 的中间件</p>
<h3><span id="req-length">req.length</span></h3><p>返回 req 对象的 <code>Content-Length</code> (Number)</p>
<h3><span id="req-url">req.url</span></h3><p>返回请求 url</p>
<h3><span id="req-url">req.url=</span></h3><p>设置请求 url，用于进行 url 重写</p>
<h3><span id="req-path">req.path</span></h3><p>返回请求 pathname</p>
<h3><span id="req-path">req.path=</span></h3><p>设置请求 pathname，如果原有 url 存在查询字符串，则保留这些查询。</p>
<h3><span id="req-querystring">req.querystring</span></h3><p>返回 url 中的查询字符串，去除了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-querystring">req.querystring=</span></h3><p>设置查询字符串，不包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search</span></h3><p>返回 url 中的查询字符串，包含了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search=</span></h3><p>设置查询字符串，包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-host">req.host</span></h3><p>返回请求主机名，不包含端口；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Host</code>。</p>
<h3><span id="req-type">req.type</span></h3><p>返回 req 对象的 <code>Content-Type</code>，不包括 <code>charset</code> 属性，范例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query</span></h3><p>返回经过解析的查询字符串，类似 Express 中的 req.query，当不存在查询字符串时，返回空对象。</p>
<p>当 url 包含查询字符串 <code>&quot;color=blue&amp;size=small&quot;</code> 时，返回如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">color</span>: <span class="string">'blue'</span>,</div><div class="line">  <span class="attr">size</span>: <span class="string">'small'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query=</span></h3><p>设置给定的对象为查询对象。范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.query = &#123; <span class="attr">next</span>: <span class="string">'/login'</span> &#125;;</div></pre></td></tr></table></figure>
<h3><span id="req-fresh">req.fresh</span></h3><p>检查客户端请求的缓存是否是最新。当缓存为最新时，可编写业务逻辑直接返回 <code>304</code>，范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'ETag'</span>, <span class="string">'123'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存是最新时</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fresh) &#123;</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">304</span>;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存已过期时，返回最新的数据</span></div><div class="line"><span class="keyword">this</span>.body = <span class="keyword">yield</span> db.find(<span class="string">'something'</span>);</div></pre></td></tr></table></figure>
<h3><span id="req-stale">req.stale</span></h3><p>与 req.fresh 返回的结果正好相反</p>
<h3><span id="req-protocol">req.protocol</span></h3><p>返回请求协议名，如 <code>&quot;https&quot;</code> 或者 <code>&quot;http&quot;</code>；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Proto</code>。</p>
<h3><span id="req-secure">req.secure</span></h3><p>判断请求协议是否为 HTTPS 的快捷方法，等同于 <code>this.protocol == &quot;https&quot;</code></p>
<h3><span id="req-ip">req.ip</span></h3><p>返回请求IP；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-For</code>。</p>
<h3><span id="req-ips">req.ips</span></h3><p>返回请求IP列表，仅当 <code>app.proxy</code> 设置为 <code>true</code> ，并存在 <code>X-Forwarded-For</code> 列表时，否则返回空数组。</p>
<h3><span id="req-subdomains">req.subdomains</span></h3><p>返回请求对象中的子域名数组。子域名数组会自动由请求域名字符串中的 <code>.</code> 分割开，在没有设置自定义的 <code>app.subdomainOffset</code> 参数时，默认返回根域名之前的所有子域名数组。</p>
<p>例如，当请求域名为 <code>&quot;tobi.ferrets.example.com&quot;</code> 时候，返回 <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>，数组顺序是子代域名在前，孙代域名在后。</p>
<p>此例中，如果设置了自定义的 <code>app.subdomainOffset</code> 为 <code>3</code>，将忽略三级域名，返回 <code>[&quot;tobi&quot;]</code>。</p>
<h3><span id="req-is-type">req.is(type)</span></h3><p>判断请求对象中 <code>Content-Type</code> 是否为给定 type 的快捷方法，如果不存在 <code>request.body</code>，将返回 <code>undefined</code>，如果没有符合的类型，返回 <code>false</code>，除此之外，返回匹配的类型字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端 Content-Type: text/html; charset=utf-8</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; 'html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/*'</span>, <span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"></div><div class="line"><span class="comment">// 客户端 Content-Type 为 application/json 时：</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'json'</span>, <span class="string">'urlencoded'</span>); <span class="comment">// =&gt; 'json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'application/json'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>, <span class="string">'application/*'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure>
<p>又如，下方的代码使用 <code>req.is(type)</code>，仅当请求类型为图片时才进行操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.is(<span class="string">'image/*'</span>)) &#123;</div><div class="line">  <span class="comment">// process</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.throw(<span class="number">415</span>, <span class="string">'images only!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-accepts-type">req.accepts(type)</span></h3><p>判断请求对象中 <code>Accept</code> 是否为给定 type 的快捷方法，当匹配到符合的类型时，返回最匹配的类型，否则返回 <code>false</code>（此时服务器端应当返回 406 “Not Acceptable” ），传入参数可以是字符串或者数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept: text/html</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'text/html'</span>);</div><div class="line"><span class="comment">// =&gt; "text/html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'json'</span>, <span class="string">'text'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'application/json'</span>);</div><div class="line"><span class="comment">// =&gt; "application/json"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'image/png'</span>);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'png'</span>);</div><div class="line"><span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*;q=.5, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts([<span class="string">'html'</span>, <span class="string">'json'</span>]);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>, <span class="string">'json'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div></pre></td></tr></table></figure>
<p>注意，当请求头中不包含 Accept 属性时，给定的第一个 type 将会被返回。</p>
<h3><span id="req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</span></h3><p>判断客户端是否接受给定的编码方式的快捷方法，当有传入参数时，返回最应当返回的一种编码方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings(<span class="string">'gzip'</span>, <span class="string">'deflate'</span>);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.acceptsEncodings([<span class="string">'gzip'</span>, <span class="string">'deflate'</span>]);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div></pre></td></tr></table></figure>
<p>当没有传入参数时，返回客户端的请求数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip, deflate</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings();</div><div class="line"><span class="comment">// =&gt; ["gzip", "deflate"]</span></div></pre></td></tr></table></figure>
<h3><span id="req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<h3><span id="req-acceptslanguages-langs">req.acceptsLanguages(langs)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<hr>
<h2><span id="response">Response</span></h2><p>详细的 Response 对象 API 如下：</p>
<h3><span id="res-header">res.header</span></h3><p>获取返回头</p>
<h3><span id="res-status">res.status</span></h3><p>获取返回状态</p>
<h3><span id="res-status">res.status=</span></h3><p>设置返回状态，可用状态如下：</p>
<ul>
<li>100 “continue”</li>
<li>101 “switching protocols”</li>
<li>102 “processing”</li>
<li>200 “ok”</li>
<li>201 “created”</li>
<li>202 “accepted”</li>
<li>203 “non-authoritative information”</li>
<li>204 “no content”</li>
<li>205 “reset content”</li>
<li>206 “partial content”</li>
<li>207 “multi-status”</li>
<li>300 “multiple choices”</li>
<li>301 “moved permanently”</li>
<li>302 “moved temporarily”</li>
<li>303 “see other”</li>
<li>304 “not modified”</li>
<li>305 “use proxy”</li>
<li>307 “temporary redirect”</li>
<li>400 “bad request”</li>
<li>401 “unauthorized”</li>
<li>402 “payment required”</li>
<li>403 “forbidden”</li>
<li>404 “not found”</li>
<li>405 “method not allowed”</li>
<li>406 “not acceptable”</li>
<li>407 “proxy authentication required”</li>
<li>408 “request time-out”</li>
<li>409 “conflict”</li>
<li>410 “gone”</li>
<li>411 “length required”</li>
<li>412 “precondition failed”</li>
<li>413 “request entity too large”</li>
<li>414 “request-uri too large”</li>
<li>415 “unsupported media type”</li>
<li>416 “requested range not satisfiable”</li>
<li>417 “expectation failed”</li>
<li>418 “i’m a teapot”</li>
<li>422 “unprocessable entity”</li>
<li>423 “locked”</li>
<li>424 “failed dependency”</li>
<li>425 “unordered collection”</li>
<li>426 “upgrade required”</li>
<li>428 “precondition required”</li>
<li>429 “too many requests”</li>
<li>431 “request header fields too large”</li>
<li>500 “internal server error”</li>
<li>501 “not implemented”</li>
<li>502 “bad gateway”</li>
<li>503 “service unavailable”</li>
<li>504 “gateway time-out”</li>
<li>505 “http version not supported”</li>
<li>506 “variant also negotiates”</li>
<li>507 “insufficient storage”</li>
<li>509 “bandwidth limit exceeded”</li>
<li>510 “not extended”</li>
<li>511 “network authentication required”</li>
</ul>
<h3><span id="res-length">res.length=</span></h3><p>设置返回头的 <code>Content-Length</code> 属性</p>
<h3><span id="res-length">res.length</span></h3><p>返回返回头的 <code>Content-Length</code> 属性，当不存在 <code>Content-Length</code> 属性时，根据 <code>res.body</code> 推断</p>
<h3><span id="res-body">res.body</span></h3><p>获取 res.body，当 res.body 为 null ，但返回状态仍为 200 时，koa 将会返回 404 页面。</p>
<h3><span id="res-body">res.body=</span></h3><p>设置请求返回的主要内容，可以是以下几种类型：</p>
<ul>
<li><p>string</p>
<p>Content-Type 将默认设置为 text/html 或者 text/plain，默认字符集是 utf-8，Content-Length 也将一并设置</p>
</li>
<li><p>Buffer</p>
<p>Content-Type 将默认设置为 application/octet-stream，Content-Length 也将一并设置</p>
</li>
<li><p>Stream</p>
<p>Content-Type 将默认设置为 application/octet-stream</p>
</li>
<li><p>Object</p>
<p>Content-Type 将默认设置为 application/json<br>注意：默认的json返回会添加空格，如果你希望压缩json返回中的空格，可以这样配置：<code>app.jsonSpaces = 0</code></p>
</li>
<li><p>null</p>
</li>
</ul>
<h3><span id="res-get-field">res.get(field)</span></h3><p>获取指定的返回头属性，属性名称区分大小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etag = <span class="keyword">this</span>.get(<span class="string">'ETag'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-field-value">res.set(field, value)</span></h3><p>使用给定的参数设置一个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-fields">res.set(fields)</span></h3><p>使用给定的对象一次设置多个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(&#123;</div><div class="line">  <span class="string">'Etag'</span>: <span class="string">'1234'</span>,</div><div class="line">  <span class="string">'Last-Modified'</span>: date</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3><span id="res-remove-fields">res.remove(fields)</span></h3><p>删除指定的返回头属性</p>
<h3><span id="res-type">res.type</span></h3><p>获取返回头中的 Content-Type，不包括 <code>&quot;charset&quot;</code> 等属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="res-type">res.type=</span></h3><p>使用字符串或者文件后缀设定返回的 Content-Type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.type = <span class="string">'text/plain; charset=utf-8'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'image/png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'.png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'png'</span>;</div></pre></td></tr></table></figure>
<p>注意：当使用文件后缀指定时，koa 会默认设置好最匹配的编码字符集，比如当设定 <code>res.type = &#39;html&#39;</code> 时，koa 会默认使用 <code>&quot;utf-8&quot;</code> 字符集。但当明确使用 <code>res.type = &#39;text/html&#39;</code> 指定时，koa 不会自动设定字符集。</p>
<h3><span id="res-redirect-url-alt">res.redirect(url, [alt])</span></h3><p>返回一个 <code>302</code> 跳转到给定的 url，您也可以使用关键词 <code>back</code> 来跳转到该 url 的上一个页面（refer），当没有上一个页面时，默认会跳转到 ‘/‘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>, <span class="string">'/index.html'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/login'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'http://google.com'</span>);</div></pre></td></tr></table></figure>
<p>如果你需要覆盖 <code>302</code> 状态码，并在跳转时返回一些文案，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.status = <span class="number">301</span>;</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/cart'</span>);</div><div class="line"><span class="keyword">this</span>.body = <span class="string">'Redirecting to shopping cart'</span>;</div></pre></td></tr></table></figure>
<h3><span id="res-attachment-filename">res.attachment([filename])</span></h3><p>设置返回熟悉 Content-Disposition 为 <code>&quot;attachment&quot;</code>，并告知客户端进行下载。</p>
<h3><span id="res-headersent">res.headerSent</span></h3><p>判断一个响应头是否已经发送到客户端，通常用来检测客户端是否收到了错误信息。</p>
<h3><span id="res-lastmodified">res.lastModified</span></h3><p>如果返回头中存在 Last-Modified 属性，则返回它。</p>
<h4><span id="res-lastmodified">res.lastModified=</span></h4><p>设置返回头中的 Last-Modified 属性，可以使用时间对象或者时间字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.lastModified = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure>
<h3><span id="res-etag">res.etag=</span></h3><p>设置返回头的 Etag 字段。koa 不提供关于 Etag 的获取方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.etag = crypto.createHash(<span class="string">'md5'</span>).update(<span class="keyword">this</span>.body).digest(<span class="string">'hex'</span>);</div></pre></td></tr></table></figure>
<hr>
<h2><span id="xing-neng-benchmarks">性能（Benchmarks）</span></h2><p>挂载不同数量的中间件，wrk 得出 benchmarks 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">1 middleware</div><div class="line">8367.03</div><div class="line"></div><div class="line">5 middleware</div><div class="line">8074.10</div><div class="line"></div><div class="line">10 middleware</div><div class="line">7526.55</div><div class="line"></div><div class="line">15 middleware</div><div class="line">7399.92</div><div class="line"></div><div class="line">20 middleware</div><div class="line">7055.33</div><div class="line"></div><div class="line">30 middleware</div><div class="line">6460.17</div><div class="line"></div><div class="line">50 middleware</div><div class="line">5671.98</div><div class="line"></div><div class="line">100 middleware</div><div class="line">4349.37</div></pre></td></tr></table></figure>
<p>一般来说，我们通常要使用约50个中间件，按这个标准计算，单应用可支持 340,260 请求/分钟，即 20,415,600 请求/小时，也就是约 4.4 亿 请求/天。</p>
<hr>
<h2><span id="xue-xi-zi-liao">学习资料</span></h2><p>发现更多第三方的 koa 中间件，或者一起来参与社区的讨论和建设吧：</p>
<ul>
<li><a href="https://github.com/koajs/koa" target="_blank" rel="external">GitHub repository</a></li>
<li><a href="https://github.com/koajs/examples" target="_blank" rel="external">Examples</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Middleware</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Wiki</a></li>
<li><a href="https://plus.google.com/communities/101845768320796750641" target="_blank" rel="external">G+ Community</a></li>
<li><a href="https://groups.google.com/forum/#!forum/koajs" target="_blank" rel="external">Mailing list</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md" target="_blank" rel="external">Guide</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md" target="_blank" rel="external">FAQ</a></li>
</ul>
<hr>
<h2><span id="contributing">Contributing</span></h2><ul>
<li>Fork this repo</li>
<li>Clone your repo</li>
<li>Install dependencies</li>
<li>Checkout a feature branch</li>
<li>Feel free to add your features</li>
<li>Make sure your features are fully tested</li>
<li>Open a pull request, and enjoy &lt;3</li>
</ul>
<h2><span id="mit-license">MIT license</span></h2><p>Copyright (c) 2013 turing &lt;o.u.turing@gmail.com&gt;</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br>THE SOFTWARE.</p>
<hr>
<p><img src="https://cdn1.iconfinder.com/data/icons/windows8_icons_iconpharm/26/doctor.png" alt="docor"></p>
<p>Generated using <a href="https://github.com/guo-yu/docor.git" target="_blank" rel="external">docor</a> @ 0.1.0. brought to you by <a href="https://github.com/guo-yu" target="_blank" rel="external">Guo Yu</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份&lt;br&gt;
    
    </summary>
    
      <category term="node.js" scheme="https://www.kanshouce.com/categories/node-js/"/>
    
    
      <category term="guide" scheme="https://www.kanshouce.com/tags/guide/"/>
    
      <category term="Koa" scheme="https://www.kanshouce.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>招行办理深圳工商局U盾签名爬坑</title>
    <link href="https://www.kanshouce.com/2017/08/08/Adobe-acrobat-U/"/>
    <id>https://www.kanshouce.com/2017/08/08/Adobe-acrobat-U/</id>
    <published>2017-08-08T15:08:48.000Z</published>
    <updated>2017-08-11T16:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>深圳工商应该是全国率先实现了U盾电子签名办事，这是无数代办公司的噩梦，但是软件问题坑苦了用户。本文记载在多次办理后的所需经验。</p>
<a id="more"></a>
<h1><span id="adobe-acrobat-dc-an-zhuang-wen-ti">Adobe Acrobat DC 安装问题</span></h1><p>首先，你必须有个windows环境，这点毫无疑问。</p>
<p>请注意，需要安装<code>最新版本</code>的的Acrobat，本次我安装的是<code>AcroRdrDC1701220093_zh_CN</code>，如果不是最新版本的，在签名部分可能需要安装Adobe的一个补丁，而国外的网络很慢，所以最好下载一个最新版本。</p>
<p>最常见的错误是由于很多人会把桌面更换了存放盘，导致在安装过程中提示</p>
<div class="tip"><br>ERROR!<br>无法访问网络位置 c:/users/76798/Desktop<br></div>

<p>这时候最好的解决办法是在计算机<code>开始</code>菜单，点击右键，选择<code>运行</code>，输入<code>regedit</code>进入注册表。</p>
<p>问题的关键在于<code>/</code>和<code>\</code>的符号错误，搜索<code>c:/users/76798/Desktop</code>找到这个键值。改为<code>c:\users\76798\Desktop</code>即可</p>
<h1><span id="adobe-acrobat-dc-shan-tui">Adobe Acrobat DC 闪退</span></h1><p>Adobe Acrobat DC的闪退用两个方案可以快速解决</p>
<p>（1）前往Adobe的安装目录，找到<code>Eula.exe</code>文件（这是最早安装弹出的许可协议，很多人点了拒绝），在这里点击<code>Accept</code>接受；</p>
<div class="tip"><br>ERROR!<br>无法创建该签名。Error at File:DSHandler.cpp,line:<em>LINE</em><br></div>

<p>（2）因为提前安装了招行的插件引起，这时候找到安装目录，通常可能是<code>C:\Program Files\Adobe\Reader 11.0\Reader\plug_ins</code>或者<code>C:\Program Files\Adobe\Acrobat Reader DC\Reader\plug_ins</code>，在里面找到<code>CMBPDFSign.api</code>招行的签名文件。</p>
<p>将文件用<code>Ctrl</code>+<code>x</code>剪切到桌面，然后再打开AcrobatDC，操作一会儿，如果没闪退，可以把该文件复制回刚刚的目录，闪退的问题解决了。</p>
<h1><span id="zhao-xing-u-dun-qian-ming-qu-dong-xia-zai">招行U盾签名驱动下载</span></h1><p>推荐前往深圳工商局网站链接，根据自己U盾的情况进行下载：</p>
<p><a href="http://app03.szaic.gov.cn/psout/jsp/gcloud/pubservice/network/downPageSimple.jsp" target="_blank" rel="external">戳我直达深圳工商局网站下载帮助页</a></p>
<p>或</p>
<p><a href="http://www.shenzhen.cmbchina.com/EasyRegister/" target="_blank" rel="external">戳我直达招行下载页</a></p>
<h1><span id="qian-ming-shi-de-cuo-wu-ti-shi">签名时的错误提示</span></h1><p>进入Adobe菜单 - <code>编辑</code> - <code>首选项</code> - <code>签名</code> - <code>创建和外观</code> - <code>默认签名方法</code>，选择<code>CMB_PDF_SIGN</code>，确定后，回到上页，点击<code>验证</code>,检查其中的始终是用默认方法部分是不是<code>用Adobe默认安全性</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深圳工商应该是全国率先实现了U盾电子签名办事，这是无数代办公司的噩梦，但是软件问题坑苦了用户。本文记载在多次办理后的所需经验。&lt;/p&gt;
    
    </summary>
    
      <category term="Skill" scheme="https://www.kanshouce.com/categories/Skill/"/>
    
    
      <category term="AcrobatDC" scheme="https://www.kanshouce.com/tags/AcrobatDC/"/>
    
      <category term="signature" scheme="https://www.kanshouce.com/tags/signature/"/>
    
  </entry>
  
  <entry>
    <title>免费的HTTPS证书Let&#39;s Encrypt</title>
    <link href="https://www.kanshouce.com/2017/08/08/Https-encrypt/"/>
    <id>https://www.kanshouce.com/2017/08/08/Https-encrypt/</id>
    <published>2017-08-08T10:59:21.000Z</published>
    <updated>2017-08-08T13:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>是由ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。</p>
<a id="more"></a>
<p>申请 Let’s Encrypt 证书不但免费，还非常简单，虽然每次只有 <code>90</code>天的有效期，但可以<strong>通过脚本定期更新</strong>，配好之后一劳永逸。</p>
<p>在Let’s Encrypt 官网有提供工具来申请证书，本教程使用 <a href="https://github.com/diafygi/acme-tiny" target="_blank" rel="external">acme-tiny</a> 这个更为小巧的开源工具。以下内容基本按照 acme-tiny 的说明文档写的，省略了一些不需要的步骤。</p>
<p>ACME 全称是 Automated Certificate Management Environment，直译过来是自动化证书管理环境的意思，Let’s Encrypt 的证书签发过程使用的就是 ACME 协议。有关 ACME 协议的更多资料可以在<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">这个仓库</a>找到。</p>
<h1><span id="create-account">Create Account</span></h1><p>首先创建一个目录，例如 SSL，如果是Nginx，使用了yum安装，最方便的方式是存在<code>/etc/nginx/cert</code>，这样在配置conf的时候可以直接用<code>cert/xxxx.pub</code>这样的写法。新建立的SSL目录用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; account.key</div></pre></td></tr></table></figure>
<h1><span id="create-csr-file">Create CSR file</span></h1><p>接着就可以生成 CSR（Certificate Signing Request，证书签名请求）文件了。在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥），根据证书不同类型，域名私钥也可以选择 RSA 和 ECC 两种不同类型。以下两种方式请根据实际情况二选一。</p>
<p>(1)创建RSA私钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; domain.key</div></pre></td></tr></table></figure>
<p>(2)创建 ECC 私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#secp256r1</span></div><div class="line">$ openssl ecparam -genkey -name secp256r1 | openssl ec -out domain.key</div><div class="line"></div><div class="line"><span class="comment">#secp384r1</span></div><div class="line">$ openssl ecparam -genkey -name secp384r1 | openssl ec -out domain.key</div></pre></td></tr></table></figure>
<p>有关 ECC 证书的更多介绍，请<a href="https://imququ.com/post/optimize-tls-handshake.html#toc-2-1" target="_blank" rel="external">点击这里</a>。<br>有了私钥文件，就可以生成 CSR 文件了。在 CSR 中推荐至少把域名带 www 和不带 www 的两种情况都加进去，其它子域可以根据需要添加（目前一张证书最多可以包含 100 个域名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -new -sha256 -key domain.key -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com"</span>)) &gt; domain.csr</div></pre></td></tr></table></figure>
<p>执行这一步时，如果提示找不到 <code>/etc/ssl/openssl.cnf</code> 文件，请看看 <code>/usr/local/openssl/ssl/openssl.cnf</code> 是否存在，之前可以按照本站所提到的文章升级Openssl 1.1.0f。如果还是不行，也可以使用交互方式创建 CSR（需要注意 Common Name 必须为你的域名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -new -sha256 -key domain.key -out domain.csr</div></pre></td></tr></table></figure>
<h1><span id="auth-config">Auth Config</span></h1><p>我们知道，CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 <code>admin@yoursite.com</code> 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。<br>首先创建用于存放验证文件的目录，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/www/challenges/</div></pre></td></tr></table></figure>
<p>然后配置一个 HTTP 服务，以 Nginx 为例</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">server_name</span> www.yoursite.com yoursite.com;</div><div class="line"></div><div class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /.well-known/acme-challenge/ &#123;</div><div class="line">        <span class="attribute">alias</span> /home/xxx/www/challenges/;</div><div class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://yoursite.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上配置优先查找 <code>~/www/challenges/</code> 目录下的文件，如果找不到就重定向到 HTTPS 地址。这个验证服务以后更新证书还要用到，建议一直保留。</p>
<h1><span id="get-website-ssl">Get website ssl</span></h1><p>先把 acme-tiny 脚本保存到之前的 <code>ssl</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</div></pre></td></tr></table></figure>
<p>指定账户私钥、CSR 以及验证目录，执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir ~/www/challenges/ &gt; ./signed.crt</div></pre></td></tr></table></figure>
<p>如果一切正常，当前目录下就会生成一个 <code>signed.crt</code>，这就是申请好的证书文件。</p>
<p>如果你把域名 DNS 解析放在国内，这一步很可能会遇到类似这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ValueError: Wrote file to /home/xxx/www/challenges/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn&apos;t download http://www.yoursite.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg</div></pre></td></tr></table></figure>
<p>这是因为你的域名很可能在国外无法解析，可以暂时使用国外的 DNS 解析服务商，例如 <a href="https://dns.he.net/" target="_blank" rel="external">dns.he.net</a>。如果还是搞不定，也可以试试<a href="https://github.com/Neilpang/le" target="_blank" rel="external">「Neilpang/le」</a>这个工具的 DNS Mode。<br>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。我在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起：</p>
<p>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">$ cat signed.crt intermediate.pem &gt; chained.pem</div></pre></td></tr></table></figure>
<p>为了后续能顺利启用 <a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html#toc-2" target="_blank" rel="external">OCSP Stapling</a>，我们再把根证书和中间证书合在一起：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &gt; root.pem</div><div class="line">$ cat intermediate.pem root.pem &gt; full_chained.pem</div></pre></td></tr></table></figure>
<p>最终，修改 Nginx 中有关证书的配置并 reload 服务即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ssl_certificate</span>     ~/www/ssl/chained.pem;</div><div class="line"><span class="attribute">ssl_certificate_key</span> ~/www/ssl/domain.key;</div></pre></td></tr></table></figure>
<h1><span id="config-auto-upgrade">Config Auto upgrade</span></h1><p>Let’s Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新。例如可以创建了一个 <code>renew_cert.sh</code> 并通过 <code>chmod a+x renew_cert.sh</code> 赋予执行权限。文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /home/xxx/www/ssl/</div><div class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/xxx/www/challenges/ &gt; signed.crt || <span class="built_in">exit</span></div><div class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">cat signed.crt intermediate.pem &gt; chained.pem</div><div class="line">service nginx reload</div></pre></td></tr></table></figure>
<p>crontab 中使用绝对路径比较保险，<code>crontab -e</code> 加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 0 1 * * /home/xxx/shell/renew_cert.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>这样以后证书每个月都会自动更新，一劳永逸。实际上，Let’s Encrypt 官方将证书有效期定为 90 天一方面是为了更安全，更重要的是鼓励用户采用自动化部署方案。</p>
<p>Let’s Encrypt 官方的新特性预告可以在<a href="https://letsencrypt.org/upcoming-features/" target="_blank" rel="external">这个页面</a>查看。</p>
<p>我个人建议：对于个人用户来说，如果非常在意证书兼容性，可以购买 RapidSSL Standard 或者 Comodo Positive SSL 这两种证书。其中 RapidSSL 证书一共才三级，比较小；Comodo Positive 有四级，但可以申请 ECC 证书；二者都有着不错的兼容性，也非常廉价（一年不到 10$）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Let’s Encrypt&lt;/a&gt;是由ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
      <category term="WEB" scheme="https://www.kanshouce.com/categories/Server/WEB/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="https" scheme="https://www.kanshouce.com/tags/https/"/>
    
      <category term="web" scheme="https://www.kanshouce.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>这是目前最好用的，替换某字体的方法了</title>
    <link href="https://www.kanshouce.com/2017/08/08/fonts-replace/"/>
    <id>https://www.kanshouce.com/2017/08/08/fonts-replace/</id>
    <published>2017-08-08T09:19:38.000Z</published>
    <updated>2017-08-08T09:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于给朋友装了一些Wordpress，模版上使用的字体因为某些原因无法访问，这是大家共知的情况。</p>
<p>原360（libs.useso.com）和其他一些地方提供的字体代理因为各种原因不合适，比如不支持https等。</p>
<a id="more"></a>
<p>科大从2014年既提供了替代方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ajax.googleapis.com =&gt; ajax.lug.ustc.edu.cn</div><div class="line">fonts.googleapis.com =&gt; fonts.lug.ustc.edu.cn</div><div class="line">themes.googleusercontent.com =&gt; google-themes.lug.ustc.edu.cn</div></pre></td></tr></table></figure>
<p>这种方案支持单独站点某些字体的替换。</p>
<p>但是如果Wordpress每次升级会覆盖原来的<code>js</code>或<code>css</code>文件，如果服务器采用Nginx部署的，可以采用将<code>MIME type</code>强制替换方案。</p>
<p>Nginx配置文件参考，需要注意的是，不支持Gzip。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># disable gzip response, otherwise subs_filter cannot parse it</span></div><div class="line">proxy_set_header Accept-Encoding <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="comment">#subs_filter_types text/html text/css text/xml text/javascript;</span></div><div class="line">subs_filter_types text/css text/xml text/javascript;</div><div class="line">subs_filter //fonts.googleapis.com/ //fonts.lug.ustc.edu.cn/;</div><div class="line">subs_filter //ajax.googleapis.com/ //ajax.lug.ustc.edu.cn/;</div><div class="line">subs_filter //themes.googleusercontent.com/ //google-themes.lug.ustc.edu.cn/;</div><div class="line">subs_filter //fonts.gstatic.com/ //fonts-gstatic.lug.ustc.edu.cn/;</div><div class="line"></div><div class="line">proxy_connect_timeout 3s;</div><div class="line">error_page 500 502 504 @redirect;</div></pre></td></tr></table></figure>
<p><a href="https://gist.github.com/gaoyifan/680da074330d2c499d6b" target="_blank" rel="external">科大的配置文件完整版</a></p>
<p>另外，科大博客维护人员在Github上一个<a href="https://github.com/gaoyifan/china-operator-ip" target="_blank" rel="external">非常不错的项目</a>应该是目前最好的IP库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于给朋友装了一些Wordpress，模版上使用的字体因为某些原因无法访问，这是大家共知的情况。&lt;/p&gt;
&lt;p&gt;原360（libs.useso.com）和其他一些地方提供的字体代理因为各种原因不合适，比如不支持https等。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://www.kanshouce.com/categories/WEB/"/>
    
    
      <category term="web" scheme="https://www.kanshouce.com/tags/web/"/>
    
      <category term="google fonts" scheme="https://www.kanshouce.com/tags/google-fonts/"/>
    
      <category term="wordpress" scheme="https://www.kanshouce.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>国际空间站（ISS）传输SSTV庆祝业余无线电20周年</title>
    <link href="https://www.kanshouce.com/2017/08/06/iss-with-rtl-sdr/"/>
    <id>https://www.kanshouce.com/2017/08/06/iss-with-rtl-sdr/</id>
    <published>2017-08-06T09:45:22.000Z</published>
    <updated>2017-08-08T13:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年7月20日至24日，ISS（国际空间站）正在传播SSTV（慢扫描电视）图像，以庆祝ARISS（ISS的业余无线电）20周年。</p>
<p>ISS每年在庆祝的场合传播SSTV图像很多次。有关即将到来的ARISS活动的更多信息，可以访问他们的网站 <a href="ariss.org">ariss.org</a>。</p>
<p>在YouTube上有个歪果仁Tysonpower使用RTL-SDR，FM陷阱滤波器和V-Dipole天线，收集了ISS SSTV图像的视频和写作数据。<br><img src="https://pic.kanshouce.com/blog/2017-08-06-15039.gif" alt=""></p>
<p>如果希望看完整个过程，可以直接访问这个人的<a href="https://tysonpower.de/blog/sstv-from-the-iss-ariss-20th-anniversary-july-2017" target="_blank" rel="external">博客</a>，有详细的记载。</p>
<a id="more"></a>
<p>请注意，Tysonpower的YouTube视频是以德文叙述的，但如果您打开YouTube的隐藏式字幕，则默认情况下可以使用英文字幕，并打开谷歌的中文翻译功能。</p>
<p>在2015年，国际空间站（ISS）向当时正在过80岁生日的俄罗斯宇航员尤里加加林发送了SSTV图像。</p>
<p>欧洲的军装怎么说，还真是很耐看。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-ISS_SSTV_Yuri.jpg" alt=""></p>
<p>满满的IBM笔记本有没有，挂在墙上固定的各式工具看起来属于极为实用的风格（毕竟物体带上空间站的成本高昂的吓人）<br><img src="https://pic.kanshouce.com/blog/2017-08-06-issttt.jpg" alt="ISS上用于传输SSTV图像的计算机"></p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-iss_arissant22.jpg" alt="传输SSTV天线"></p>
<p>要解码图像，建议使用SDR＃并将音频管道传输到<a href="http://hamsoft.ca/pages/mmsstv.php" target="_blank" rel="external">MMSSTV</a>，一个免费的SSTV解码软件程序。为了从MMSSTV中获得最佳效果，建议在选项 - &gt;设置MMSTV-&gt; RX下启用“自动倾斜”和“自动重新同步”。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-MMSTV_settings.jpg" alt=""></p>
<p>国际空间站的部分追踪信息可以在这里在线跟踪它：</p>
<ul>
<li><a href="http://spotthestation.nasa.gov/sightings/" target="_blank" rel="external">http://spotthestation.nasa.gov/sightings/</a> </li>
<li><a href="http://www.isstracker.com/" target="_blank" rel="external">http://www.isstracker.com/</a></li>
<li><a href="http://www.mcc.rsa.ru/English/trassa.htm" target="_blank" rel="external">http://www.mcc.rsa.ru/English/trassa.htm</a></li>
</ul>
<p>另外，对懒癌晚期来说，这里有个非常有趣的图册集合，集合了大多数爱好者接收到的SSTV。</p>
<p><a href="http://spaceflightsoftware.com/ARISS_SSTV/index.php" target="_blank" rel="external">戳我抵达</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年7月20日至24日，ISS（国际空间站）正在传播SSTV（慢扫描电视）图像，以庆祝ARISS（ISS的业余无线电）20周年。&lt;/p&gt;
&lt;p&gt;ISS每年在庆祝的场合传播SSTV图像很多次。有关即将到来的ARISS活动的更多信息，可以访问他们的网站 &lt;a href=&quot;ariss.org&quot;&gt;ariss.org&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在YouTube上有个歪果仁Tysonpower使用RTL-SDR，FM陷阱滤波器和V-Dipole天线，收集了ISS SSTV图像的视频和写作数据。&lt;br&gt;&lt;img src=&quot;https://pic.kanshouce.com/blog/2017-08-06-15039.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果希望看完整个过程，可以直接访问这个人的&lt;a href=&quot;https://tysonpower.de/blog/sstv-from-the-iss-ariss-20th-anniversary-july-2017&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;，有详细的记载。&lt;/p&gt;
    
    </summary>
    
      <category term="SDR" scheme="https://www.kanshouce.com/categories/SDR/"/>
    
    
      <category term="RTL-SDR" scheme="https://www.kanshouce.com/tags/RTL-SDR/"/>
    
      <category term="ISS" scheme="https://www.kanshouce.com/tags/ISS/"/>
    
      <category term="SSTV" scheme="https://www.kanshouce.com/tags/SSTV/"/>
    
  </entry>
  
  <entry>
    <title>用RTL-SDR进行IMSI的捕获</title>
    <link href="https://www.kanshouce.com/2017/08/06/simple-imsi-catcher/"/>
    <id>https://www.kanshouce.com/2017/08/06/simple-imsi-catcher/</id>
    <published>2017-08-06T09:27:10.000Z</published>
    <updated>2017-08-08T13:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>事实上在HarckRF上捕获IMSI是非常容易的，在安卓系统上也有成堆的IMSI捕捉器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AIMSICD • Fight IMSI-Catcher, StingRay and silent SMS!</div><div class="line">https://github.com/CellularPrivacy/Android-IMSI-Catcher-Detector.git</div><div class="line">https://cellularprivacy.github.io/Android-IMSI-Catcher-Detector/</div><div class="line">https://opensource.srlabs.de/projects/mobile-network-assessment-tools/wiki/CatcherCatcher</div><div class="line"></div><div class="line">Netmonitor - Monitor GSM/CDMA/LTE network: current and neighboring cell infos, signal strength.</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>早些时候，在Youtube上有个用户上传了用RTL-SDR配合一段python的脚本捕捉IMSI的<a href="https://www.youtube.com/channel/UC4cMTOPJf_ixWyGW1u48yrw" target="_blank" rel="external">视频</a></p>
<p>视频中展示了他如何使用gr-gsm和Python脚本使用RTL-SDR来创建一个简单的IMSI捕获器。</p>
<p>IMSI代表国际移动用户身份，并且是识别GSM（2G）移动电话系统中的手机SIM卡的唯一号码。为了安全起见，IMSI号码通常仅在连接到新的基站时被传送。</p>
<p>很多国家的政府机构使用的更先进的IMSI捕获器使用基站信号强制IMSI一致被报道。这样他们可以跟踪手机的位置以及其他数据，比如谁打电话或什么时候打电话。</p>
<p>在视频中，Keld使用了一个名为<a href="https://github.com/Oros42/IMSI-catcher" target="_blank" rel="external">IMSI-Catcher</a>的Python脚本。此脚本在文本显示屏上显示检测到的IMSI号码，国家/地区和移动运营商。视频说明显示如何在Ubuntu上安装GR-GSM和IMSI-Catcher脚本。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-093512.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事实上在HarckRF上捕获IMSI是非常容易的，在安卓系统上也有成堆的IMSI捕捉器。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;AIMSICD • Fight IMSI-Catcher, StingRay and silent SMS!&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://github.com/CellularPrivacy/Android-IMSI-Catcher-Detector.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://cellularprivacy.github.io/Android-IMSI-Catcher-Detector/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://opensource.srlabs.de/projects/mobile-network-assessment-tools/wiki/CatcherCatcher&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Netmonitor - Monitor GSM/CDMA/LTE network: current and neighboring cell infos, signal strength.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SDR" scheme="https://www.kanshouce.com/categories/SDR/"/>
    
    
      <category term="RTL" scheme="https://www.kanshouce.com/tags/RTL/"/>
    
      <category term="IMSI" scheme="https://www.kanshouce.com/tags/IMSI/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级Openssl并支持HTTP2</title>
    <link href="https://www.kanshouce.com/2017/08/05/openssl-upgrade/"/>
    <id>https://www.kanshouce.com/2017/08/05/openssl-upgrade/</id>
    <published>2017-08-05T08:58:45.000Z</published>
    <updated>2017-08-08T13:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 7 默认带的openssl是1.0.1版本，开启HTTP2则必须升级1.1左右的版本。</p>
<p>本文仅适用CentOS7</p>
<p>以下为升级全过程</p>
<a id="more"></a>
<h1><span id="sheng-ji-openssl">升级OpenSSL</span></h1><p>查看当前openssl版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl version</div></pre></td></tr></table></figure>
<p>查看输出版本</p>
<p>前往Openssl官方<a href="https://www.openssl.org/source/" target="_blank" rel="external">（戳我）</a>查看最新的openssl版本，make本文的时候最新版本为1.1.0f</p>
<p>下载并解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home</div><div class="line">$ wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.0f.tar.gz</div><div class="line">$ tar -zxvf openssl-1.1.0f.tar.gz</div><div class="line">$ <span class="built_in">cd</span> openssl-1.1.0f</div></pre></td></tr></table></figure>
<p>动态编译Openssl，并安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./config zlib-dynamic</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>这里要注意，如果编译的时候增加了 <code>zlib-dynamic</code> 这个参数代表了动态编译，编译完成后，只需要执行下文中<code>#添加libssl.so.1.1</code>等两个步骤，因为openssl的执行目录和文件都已经就绪。</p>
<p>如果用默认的安装，那么此刻openssl默认被安装到了<code>/usr/local/</code>目录。</p>
<p>查看目前运行的Openssl目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">which</span> openssl</div></pre></td></tr></table></figure>
<p>开始升级（如果动态编译，可以从<code>#添加libssl.so.1.1</code>开始）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#把旧版本的openssl备份一下，下面的目录即是上面用which查出来的目录，每个人的服务器配置不一样，请依照情况执行。</span></div><div class="line">$ mv /usr/bin/openssl /usr/bin/openssl.bak</div><div class="line">$ mv /usr/include/openssl /usr/include/openssl.bak</div><div class="line"></div><div class="line"><span class="comment">#拷贝刚编译好的新版本的openssl-1.1.0f</span></div><div class="line">$ cp /usr/<span class="built_in">local</span>/bin/openssl /usr/bin/openssl</div><div class="line">$ cp -r /usr/<span class="built_in">local</span>/ssl /usr/include/openssl</div><div class="line"><span class="comment">#注意，1.1.0f版本 生成的文件的位置在/usr/local/ssl</span></div><div class="line"><span class="comment">#这里没有用ln软链的原因是因为如果使用ln可能在后续安装中造成其他软件的安装错误,比较常见的就是报[install_dev]错误</span></div><div class="line"></div><div class="line"><span class="comment">#添加libssl.so.1.1</span></div><div class="line">$ cp /usr/<span class="built_in">local</span>/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</div><div class="line">$ cp /usr/<span class="built_in">local</span>/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</div><div class="line"></div><div class="line"><span class="comment">#查看openssl版本</span></div><div class="line">$ openssl version</div><div class="line"></div><div class="line"><span class="comment">#重新加载动态链接库，这步比较重要，特别是下一步要升级nginx</span></div><div class="line">$ ldconfig -v</div></pre></td></tr></table></figure>
<p>至此，openssl已经成功升级。</p>
<h1><span id="sheng-ji-nginx-zhi-chi-http2">升级Nginx支持HTTP2</span></h1><h2><span id="sheng-ji">升级</span></h2><p>Nginx的升级相对比较简单</p>
<p>升级前最好<code>检查</code>下是否具备编译Nginx的条件，特别是以前很多采用<code>YUM</code>安装的懒癌晚期，可能没安装编译环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install gcc-c ++ pcre-devel zlib-devel make wget openssl-devel libxml2-devel libxslt-devel gd-devel perl-ExtUtils-Embed GeoIP-devel gperftools-devel</div></pre></td></tr></table></figure>
<p>以上基本把所需的依赖都装好了，如果在下面的编译环境中提示<code>Peal</code>的相关错误，可以考虑安装<code>cpan</code>，用cpan按照提示安装缺少的peal库。</p>
<p>开始升级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#看一下nginx版本与配置</span></div><div class="line">[root@sf3 ~]<span class="comment"># nginx -V</span></div><div class="line">nginx version: nginx/1.10.0   //这里输出的是当前版本</div><div class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC) //编译用的Gcc版本</div><div class="line">built with OpenSSL 1.0.1e-fips 11 Feb 2013  //使用的openssl版本，我们本次升级主要针对的地方</div><div class="line">TLS SNI support enabled  //TLS支持是否打开</div><div class="line">configure arguments: [内容略去]  //编译参数</div></pre></td></tr></table></figure>
<p>最新稳定版本是1.10.2</p>
<p>官网地址：<a href="http://nginx.org" target="_blank" rel="external">http://nginx.org</a></p>
<p>升级步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载nginx最新版</span></div><div class="line">$ <span class="built_in">cd</span> /home</div><div class="line"><span class="variable">$wget</span> http://nginx.org/download/nginx-1.10.2.tar.gz</div><div class="line"><span class="comment">#解压源码</span></div><div class="line">$ tar zxvf nginx-1.10.2.tar.gz</div><div class="line"><span class="comment">#进入源码目录</span></div><div class="line">$ <span class="built_in">cd</span> nginx-1.10.2</div><div class="line"></div><div class="line"><span class="comment">#加上所需参数开始编译</span></div><div class="line">$ ./configure [这里copy上文提到的内容略去部分，或者根据你自己的情况进行配置] --with-openssl=/home/openssl-1.1.0f <span class="comment">#请注意，这条最重要，对应openssl源码解压后的路径</span></div><div class="line"></div><div class="line"><span class="comment">#执行make编译，但是不要执行make install</span></div><div class="line"></div><div class="line">$ make</div><div class="line"></div><div class="line"><span class="comment">#重命名nginx旧版本二进制文件，即sbin目录下的nginx（期间nginx并不会停止服务）</span></div><div class="line"><span class="comment">#每个人服务器的安装不太一样，执行前记得用which nginx看一下nginx所在目录</span></div><div class="line">$ mv /usr/sbin/nginx /usr/sbin/nginx.old</div><div class="line"></div><div class="line"><span class="comment">#然后拷贝一份新编译的二进制文件</span></div><div class="line">$ cp objs/nginx /usr/sbin/sbin/</div><div class="line"><span class="comment">#在源码目录执行make upgrade开始升级</span></div><div class="line">$ make upgrade</div><div class="line"></div><div class="line"><span class="comment">#完成后查看下版本</span></div><div class="line">$ nginx -V</div></pre></td></tr></table></figure>
<p>如果遇到错误，请参考本博客<a href="https://www.kanshouce.com/2017/08/01/nginx-php7/">上篇文章</a>，用YUM升级安装nginx到最新版本nginx，再进行编译。</p>
<h2><span id="pei-zhi-bu-fen">配置部分</span></h2><p>在nginx的<code>conf</code>文件里，对对应的站点进行配置，非常简单，只需要增加<code>ssl http2;</code>即可，比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listen 443 ssl http2 default_server;</div></pre></td></tr></table></figure>
<p>要验证http2是否生效可以安装个chrome插件<code>HTTP/2 and SPDY indicator</code>，如果开启了h2，那么会有一道蓝色的闪电，比如说，就像本站已经开启了：<br><img src="https://pic.kanshouce.com/blog/2017-08-06-2017-08-06%205.18.06.png" alt=""></p>
<h3><span id="tui-jian-de-pei-zhi">推荐的配置</span></h3><p>这里有个网站推荐给大家，可以生成被优化推荐的Nginx配置文件</p>
<p><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="external">戳我抵达</a></p>
<h1><span id="yi-xie-ce-shi">一些测试</span></h1><p>除了上面提到的Chrome插件以外，如果服务器的openssl版本过低，可能导致chrom浏览器访问失败，原因是因为在去年google chrom51版本中google移除了NPN，只支持ALPN，所以导致协商失败。</p>
<p>用这条命令可以测试目前HTTP2服务是否支持ALPN</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl s_client -alpn h2 -servername imququ.com -connect kanshouce.com:443 &lt; /dev/null | grep <span class="string">'ALPN'</span></div></pre></td></tr></table></figure>
<p>如果提示 <code>unknown option -alpn</code>，说明本地的 OpenSSL 版本太低（可通过 <code>openssl version</code> 查看），请升级到 1.0.2+。如果不方便升级，也可以使用 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="external">Qualys SSL Labs’s SSL Server Test</a> 这个在线工具来测试。</p>
<p>如果结果包含 <code>ALPN protocol: h2</code>，说明服务端支持 ALPN，不受 Chrome 51+ 去掉 NPN 的影响。</p>
<p>如果结果包含 <code>No ALPN negotiated</code>，说明服务端不支持 ALPN，在 Chrome 51+ 中无法协商到 HTTP/2，需要尽快升级。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 7 默认带的openssl是1.0.1版本，开启HTTP2则必须升级1.1左右的版本。&lt;/p&gt;
&lt;p&gt;本文仅适用CentOS7&lt;/p&gt;
&lt;p&gt;以下为升级全过程&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Openssl" scheme="https://www.kanshouce.com/tags/Openssl/"/>
    
  </entry>
  
  <entry>
    <title>YUM安装php7与Nginx</title>
    <link href="https://www.kanshouce.com/2017/08/01/nginx-php7/"/>
    <id>https://www.kanshouce.com/2017/08/01/nginx-php7/</id>
    <published>2017-08-01T10:57:14.000Z</published>
    <updated>2017-08-08T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="ben-wen-gua-yong-ban-ben">本文适用版本</span></h1><p>服务器：centos 7.6 64x</p>
<p>SElinux：关闭</p>
<p>适用：YUM安装</p>
<h1><span id="an-zhuang-php7">安装PHP7</span></h1><h2><span id="shan-chu-jiu-ban-ben">删除旧版本</span></h2><p>首先检查之前用YUM安装的php版本与包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[server@name]<span class="comment"># yum list installed | grep php</span></div></pre></td></tr></table></figure>
<p>如果有安装过，根据GREP出的列表删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum remove php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-devel.x86_64 php56w-fpm.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 php56w-pear.noarch php56w-pecl-igbinary.x86_64 php56w-pecl-memcache.x86_64 php56w-pecl-redis.x86_64 php56w-process.x86_64 php56w-soap.x86_64 php56w-xml.x86_64</div></pre></td></tr></table></figure>
<p>每个空格删除一个</p>
<h2><span id="pei-zhi-an-zhuang-yuan">配置安装源</span></h2><p>以下是CentOS 7的源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</div><div class="line">$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</div></pre></td></tr></table></figure>
<h2><span id="an-zhuang">安装</span></h2><p>安装php</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[server@name]<span class="comment"># yum install \</span></div><div class="line">php70w.x86_64 \</div><div class="line">php70w-cli.x86_64 \</div><div class="line">php70w-common.x86_64 \</div><div class="line">php70w-gd.x86_64 \</div><div class="line">php70w-ldap.x86_64 \</div><div class="line">php70w-mbstring.x86_64 \</div><div class="line">php70w-mcrypt.x86_64 \</div><div class="line">php70w-mysql.x86_64 \</div><div class="line">php70w-pdo.x86_64</div></pre></td></tr></table></figure>
<p>安装php-fpm</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install php70w-fpm</div></pre></td></tr></table></figure>
<p>非常简单，安装好后的配置文件在 <code>/etc/php.ini</code>内</p>
<p>如果需要安装php的其他版本，替换上面的70w为其他版本号即可。</p>
<h2><span id="pei-zhi-zi-dong-qi-dong">配置自动启动</span></h2><p>用centos7的systemctl任务管理配置自动启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ systemctl <span class="built_in">enable</span> php-fpm   //加入到系统服务中</div><div class="line">$ systemctl start php-fpm    //启动</div><div class="line">$ systemctl status php-fpm   //查看运行状态</div></pre></td></tr></table></figure>
<h1><span id="an-zhuang-nginx">安装Nginx</span></h1><p>在<code>/etc/yum.repos.d</code>目录下创建文件<code>nginx.repo</code>，输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#nginx.repo</span></div><div class="line"></div><div class="line">[nginx]</div><div class="line">name=nginx repo</div><div class="line">baseurl=http://nginx.org/packages/centos/6/<span class="variable">$basearch</span>/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure>
<p>其中，<code>baseurl</code>中的6是CentOS的主版本号，因为我的操作系统是CentOS 6.3。如果是CentOS 7，就应该是<code>http://nginx.org/packages/centos/7/$basearch/</code>。</p>
<p><code>enabled=1</code>表示这个库是开启的，用完之后可以把它关闭。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum install nginx  //安装使用</div><div class="line">$ yum update nginx   //因为加入了nginx源，升级可直接升级</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;&lt;span id=&quot;ben-wen-gua-yong-ban-ben&quot;&gt;本文适用版本&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;服务器：centos 7.6 64x&lt;/p&gt;
&lt;p&gt;SElinux：关闭&lt;/p&gt;
&lt;p&gt;适用：YUM安装&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;an-zhuan
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Centos" scheme="https://www.kanshouce.com/tags/Centos/"/>
    
      <category term="Nginx" scheme="https://www.kanshouce.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>为服务器SSH增加Google两步验证登陆</title>
    <link href="https://www.kanshouce.com/2017/07/31/google-linux-2F/"/>
    <id>https://www.kanshouce.com/2017/07/31/google-linux-2F/</id>
    <published>2017-07-31T06:38:43.000Z</published>
    <updated>2017-08-08T13:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="ben-wen-an-zhuang-huan-jing-centos-7-64-wei">本文安装环境： CentOS 7 64位</span></h2><a id="more"></a>
<h2><span id="an-zhuang-suo-xu-de-zhi-chi-huan-jing">安装所需的支持环境</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yum groupinstall <span class="string">"Development Tools"</span> -y         </div><div class="line">$ yum install pam-devel -y         </div><div class="line">$ yum install chrony -y     //这步Centos7是已经默认安装的</div></pre></td></tr></table></figure>
<h2><span id="chong-yao-kai-qi-shi-jian-tong-bu">【重要】开启时间同步</span></h2><p>由于GOOGLE的两步验证服务器端每次密钥生成依赖时间，所以务必执行本步骤，以确保时间是正确时间</p>
<p>编辑时间同步的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/chrony.conf</div></pre></td></tr></table></figure>
<p>在头部时间服务器列表中增加：<code>server 2.cn.pool.ntp.org iburst</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ systemctl restart chronyd  //重启时间服务 </div><div class="line">$ chronyc sources  //手动同步一下时间</div></pre></td></tr></table></figure>
<h2><span id="bian-yi-an-zhuang-gu-ge-liang-bu-yan-zheng">编译安装谷歌两步验证</span></h2><p>先从远端仓库拉回来代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/google/google-authenticator-libpam.git     </div><div class="line">$ <span class="built_in">cd</span> google-authenticator-libpam/</div></pre></td></tr></table></figure>
<p>编译、安装：          </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./bootstrap.sh</div><div class="line">$ ./configure</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2><span id="chong-yao-bu-zou">重要步骤</span></h2><p>将谷歌两步验证加入到ssh服务中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/pam.d/sshd</div></pre></td></tr></table></figure>
<p>在文件中<strong>头部</strong>增加：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auth required pam_google_authenticator.so</div></pre></td></tr></table></figure>
<p>配置ssh服务，开启两步验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure>
<p>找到<code>ChallengeResponseAuthentication no</code> 将<code>no</code>修改为<code>yes</code></p>
<h3><span id="chong-yao">重要</span></h3><p>按照默认安装，会报错，请将这个文件cp或者ln到目录，推荐使用ln方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp pam_google_authenticator.so /usr/lib64/security/</div></pre></td></tr></table></figure>
<p>重启ssh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl restart sshd</div></pre></td></tr></table></figure>
<p>开始配置谷歌两步验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ google-authenticator</div></pre></td></tr></table></figure>
<p>这里剩下一路回车即可，系统会生成密钥，可以用谷歌验证器扫描增加。</p>
<p>这里要注意的是在二维码生成后会现实几串应急密码，可以记录下来，在验证器失败的时候可以用临时应急密码登陆，但每使用一个失效一个。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文安装环境：-CentOS-7-64位&quot;&gt;&lt;a href=&quot;#本文安装环境：-CentOS-7-64位&quot; class=&quot;headerlink&quot; title=&quot;本文安装环境： CentOS 7 64位&quot;&gt;&lt;/a&gt;本文安装环境： CentOS 7 64位&lt;/h2&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Centos" scheme="https://www.kanshouce.com/tags/Centos/"/>
    
      <category term="Google 2FC" scheme="https://www.kanshouce.com/tags/Google-2FC/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="https://www.kanshouce.com/2017/06/20/essay/"/>
    <id>https://www.kanshouce.com/2017/06/20/essay/</id>
    <published>2017-06-20T03:25:08.000Z</published>
    <updated>2017-08-08T13:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这只是一篇随笔。</p>
<a id="more"></a>
<h2><span id="wen-hua-kuai-can">文化快餐</span></h2><p>之前大概一直在看晓松奇谈，早期的奇葩说看过但始终觉得没甚意思，最近偶尔看到，才发现文化快餐流行到了一个令人惊讶的地步。</p>
<p>学习是一个修心的过程，人类大多数愉悦的反馈实际保持了能量守恒的定律，愉悦是痛苦或不快后上天给予的反馈。阅读和学习便是这样的一个过程，就像从初拾起跑步的痛苦到身心愉悦。</p>
<p>学习必然是痛苦的，就像上学的本质实际上是人在毕业之前父母偷懒把你送到监狱的一个普世现象。</p>
<p>因为生活的痛苦，所以人类总想找捷径，而一旦发现了捷径，便认为这是唯一的道路。</p>
<p>知识的本质是一场盛宴，特别是人有余力广博群书的时候。前几天看到文章讨论为什么中国的娱乐节目没有原创，细数了各种不是，初为认同，因为火热的娱乐节目确实版权不在中国。但看了奇葩说，我想，这是一个经典的案例，这是一个让人细思极恐的案例。</p>
<p>偶然窥见的那期没有看完，那期的辩题是这样的：</p>
<blockquote>
<p>奇葩村有一口愚人井，喝了井水的人，变得黑白不分，颠倒是非，全村都喝了，你喝不喝？</p>
</blockquote>
<p>后来看下去，便觉得这是一群聪明人，因为能把哲学初级入门题（铁轨问题）搬上来，又按照教材路线从不同的角度去演绎，更有甚者把入门的下一题（人是否存在问题）也揭开了一角。但这个问题在哲学教学上（可见哈佛公开课）是涉及了“死刑是否合理”的命题，其本质，这是一道政治题啊，细思极恐。前前后后，一堆口才卓著的文化人专注表演快两小时，我想，职业演员已经OUT了，什么叫深度？什么叫内涵？什么叫有文化？什么叫会玩？</p>
<p>所以，节目带来的思考便是，如果这代表了市场需要更高智商的节目来愚弄大众，那我们的教育还能跟的上么？愚民和对这个世界充满了解行家里手的结构已经越拉越大了么？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这只是一篇随笔。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NULLCON 2017：GNU RADIO+SDR，无人机劫持和其他IOT入侵问题</title>
    <link href="https://www.kanshouce.com/2017/06/16/Nullcon2017DroneHijacking/"/>
    <id>https://www.kanshouce.com/2017/06/16/Nullcon2017DroneHijacking/</id>
    <published>2017-06-16T13:20:05.000Z</published>
    <updated>2017-08-08T13:27:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nullcon（在印度举办的一个国际性安全会议）在今年3月初举行，最近有些演示文稿的视频已经在网上可以看到。</p>
<p>一个有趣的演讲是亚瑟·加皮洛夫（Arthur Garipov）关于“GNU RADIO+SDR，无人机劫持和其他IOT入侵问题”的演讲。在他的演讲中，他解释了他如何使用软件定义的无线电和GNU Radio基于nRF，攻击各种无人机以及其他IoT设备。演讲中他说：</p>
<blockquote>
<p>物联网正围绕着我们，但是否考虑过安全问题？还是大多数人已经遗忘了安全性（被视为）隐形？近些年来SDR（软件定义无线电）和GNU Radio可以回答这些问题。在本演示中，我们将会“重放”一些流行的无线设备。它们具有类似的协议，并且它们都没有对通讯数据进行加密。</p>
<p>我们将展示使用SDR和专有芯片设备找到它们是多么容易，以及如何使用简单的python脚本和GNU Radio来嗅探/拦截/干扰这些设备。</p>
<p>作为一个例子，我们将展示一个Mousejack攻击鼠标的无线加密狗，实现无线键盘键盘记录器，甚至包括无人机劫持。</p>
</blockquote>
<p>演讲人物介绍：<br>网络应用安全小组 高级专家，Artur生于1987年。他毕业于乌法国家航空技术大学，是OZNA的软件开发人员和独立安全研究员。他于2014年开始在Positive Technologies工作。目前他从事无线技术，移动系统和IoT的安全研究。他还是PHDays V和PHDays VI的MiTM Mobile竞赛、实践实验室的组织者。</p>
<p>谈话幻灯片可以从他们的<a href="http://nullcon.net/website/archives/goa-2017.php" target="_blank" rel="external">档案下载</a>。</p>
<a id="more"></a>
<p>关于无线网络的安全问题，必将被提上日程，无线为我们的生活带来了极大的便利，但是完全没有加密的无线设备通讯，确是当下非常严重的漏洞，而这种漏洞可能存活的时间会非常久。</p>
<p>曾经在一些安全网站、论坛看过一些千奇百怪的入侵方式，包括利用信号检测对室内进行绘图、通过硬盘灯闪烁读取数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nullcon（在印度举办的一个国际性安全会议）在今年3月初举行，最近有些演示文稿的视频已经在网上可以看到。&lt;/p&gt;
&lt;p&gt;一个有趣的演讲是亚瑟·加皮洛夫（Arthur Garipov）关于“GNU RADIO+SDR，无人机劫持和其他IOT入侵问题”的演讲。在他的演讲中，他解释了他如何使用软件定义的无线电和GNU Radio基于nRF，攻击各种无人机以及其他IoT设备。演讲中他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物联网正围绕着我们，但是否考虑过安全问题？还是大多数人已经遗忘了安全性（被视为）隐形？近些年来SDR（软件定义无线电）和GNU Radio可以回答这些问题。在本演示中，我们将会“重放”一些流行的无线设备。它们具有类似的协议，并且它们都没有对通讯数据进行加密。&lt;/p&gt;
&lt;p&gt;我们将展示使用SDR和专有芯片设备找到它们是多么容易，以及如何使用简单的python脚本和GNU Radio来嗅探/拦截/干扰这些设备。&lt;/p&gt;
&lt;p&gt;作为一个例子，我们将展示一个Mousejack攻击鼠标的无线加密狗，实现无线键盘键盘记录器，甚至包括无人机劫持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;演讲人物介绍：&lt;br&gt;网络应用安全小组 高级专家，Artur生于1987年。他毕业于乌法国家航空技术大学，是OZNA的软件开发人员和独立安全研究员。他于2014年开始在Positive Technologies工作。目前他从事无线技术，移动系统和IoT的安全研究。他还是PHDays V和PHDays VI的MiTM Mobile竞赛、实践实验室的组织者。&lt;/p&gt;
&lt;p&gt;谈话幻灯片可以从他们的&lt;a href=&quot;http://nullcon.net/website/archives/goa-2017.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;档案下载&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Hack" scheme="https://www.kanshouce.com/categories/Hack/"/>
    
    
      <category term="SDR" scheme="https://www.kanshouce.com/tags/SDR/"/>
    
      <category term="Hack" scheme="https://www.kanshouce.com/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>避免被判定为垃圾邮件，提高邮件被接受效率</title>
    <link href="https://www.kanshouce.com/2017/06/16/emailtester/"/>
    <id>https://www.kanshouce.com/2017/06/16/emailtester/</id>
    <published>2017-06-16T09:25:42.000Z</published>
    <updated>2017-08-08T13:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候采用外部免费的Email企业邮箱会遇到一些问题，比如会被一些外部邮箱判定为垃圾邮件，通过这个网站，可以改进这个问题。</p>
<p><code>http://www.mail-tester.com</code></p>
<p>网站每次访问会给出一个临时的邮件地址，向这个邮件地址发送邮件（比如说邀请用户注册的模版、找回密码模版等），发送完成后，可以看到邮件的评分结果。</p>
<p>这是一个有效提高邮件到达率的方法。</p>
<a id="more"></a>
<p><img src="https://pic.kanshouce.com/blog/2017-06-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A71111.png" alt=""></p>
<p>如图所示，最早的时候公司企业邮箱的评分非常低，在经过调整改进后，可以看到明显提升。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-06-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-16%20%E4%B8%8B%E5%8D%885.24.18.png" alt=""></p>
<p>实际上此封邮件可以得到7分以上的评价，因为文件内容较少（不足2000字）等问题，没有得到分值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候采用外部免费的Email企业邮箱会遇到一些问题，比如会被一些外部邮箱判定为垃圾邮件，通过这个网站，可以改进这个问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://www.mail-tester.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网站每次访问会给出一个临时的邮件地址，向这个邮件地址发送邮件（比如说邀请用户注册的模版、找回密码模版等），发送完成后，可以看到邮件的评分结果。&lt;/p&gt;
&lt;p&gt;这是一个有效提高邮件到达率的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Email" scheme="https://www.kanshouce.com/tags/Email/"/>
    
  </entry>
  
</feed>
