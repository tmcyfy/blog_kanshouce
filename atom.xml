<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>手册</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kanshouce.com/"/>
  <updated>2017-12-22T09:08:58.000Z</updated>
  <id>https://www.kanshouce.com/</id>
  
  <author>
    <name>Louis</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用脚本acme申请Let&#39;s Encrypt免费证书（极简版）</title>
    <link href="https://www.kanshouce.com/2017/12/22/theFreeTLS/"/>
    <id>https://www.kanshouce.com/2017/12/22/theFreeTLS/</id>
    <published>2017-12-22T08:23:43.000Z</published>
    <updated>2017-12-22T09:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>免费证书如果是阿里云的主机直接申请铁门塞克的1年免费版是极方便的，申请下来后因为在阿里自己的系统内，可以直接面向相对应的产品进行推送，到期后还有自动提醒等等等，服务非常周到，可以看出阿里云一直在打造自己的全家桶。 </p>
<p>如果不使用阿里云主机的情况下，可以使用本教程生成证书。或可以看之前的<a href="https://www.kanshouce.com/2017/08/08/Https-encrypt/">完整版本</a></p>
<p>证书认证机构为 <a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>。 证书的生成有许多方法，这里使用的是比较简单的方法：使用 <a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="external">acme.sh</a> 脚本生成，本部分说明部分内容参考于<a href="https://github.com/Neilpang/acme.sh/blob/master/README.md" target="_blank" rel="external">acme.sh README</a>。</p>
<p>证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，强烈建议使用 ECC 证书。</p>
<p>以下将给出这两类证书的生成方法，请大家根据自身的情况自行选择其中一种证书类型。</p>
<p>证书生成只需在服务器上操作。</p>
<h2><span id="an-zhuang-acme-sh">安装 acme.sh</span></h2><p>执行以下命令，acme.sh 会安装到 <code>~/.acme.sh</code> 目录下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ curl  https://get.acme.sh | sh</div><div class="line">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                               Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100   671  100   671    0     0    680      0 --:--:-- --:--:-- --:--:--   679</div><div class="line">% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</div><div class="line">                               Dload  Upload   Total   Spent    Left  Speed</div><div class="line">100  112k  100  112k    0     0   690k      0 --:--:-- --:--:-- --:--:--  693k</div><div class="line">[Fri 30 Dec 01:03:32 GMT 2016] Installing from online archive.</div><div class="line">[Fri 30 Dec 01:03:32 GMT 2016] Downloading https://github.com/Neilpang/acme.sh/archive/master.tar.gz</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Extracting master.tar.gz</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing to /home/user/.acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installed to /home/user/.acme.sh/acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing <span class="built_in">alias</span> to <span class="string">'/home/user/.profile'</span></div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] OK, Close and reopen your terminal to start using acme.sh</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Installing cron job</div><div class="line">no crontab <span class="keyword">for</span> user</div><div class="line">no crontab <span class="keyword">for</span> user</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Good, bash is found, so change the shebang to use bash as preferred.</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] OK</div><div class="line">[Fri 30 Dec 01:03:33 GMT 2016] Install success!</div></pre></td></tr></table></figure>
<p>安装成功后执行 <code>source ~/.bashrc</code> 以确保脚本所设置的命令别名生效。</p>
<p>如果安装报错，那么可能是因为系统缺少 acme.sh 所需要的依赖项，acme.sh 的依赖项主要是 netcat(nc)，我们通过以下命令来安装这些依赖项，然后重新安装一遍 acme.sh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get -y install netcat</div></pre></td></tr></table></figure>
<p>Centos自行使用<code>yum</code>安装，这里不表。</p>
<h2><span id="shi-yong-acme-sh-sheng-cheng-zheng-shu">使用 acme.sh 生成证书</span></h2><h3><span id="zheng-shu-sheng-cheng">证书生成</span></h3><p>执行以下命令生成证书：</p>
<p><strong>请注意</strong>以下的命令会临时监听 80 端口，请确保执行该命令前 80 端口没有使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --issue <span class="_">-d</span> mydomain.me --standalone -k ec-256</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Standalone mode.</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Single domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting domain auth token <span class="keyword">for</span> each domain</div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting webroot <span class="keyword">for</span> domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] _w=<span class="string">'no'</span></div><div class="line">[Fri Dec 30 08:59:12 HKT 2016] Getting new-authz <span class="keyword">for</span> domain=<span class="string">'mydomain.me'</span></div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] The new-authz request is ok.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] mydomain.me is already verified, skip http-01.</div><div class="line">[Fri Dec 30 08:59:14 HKT 2016] Verify finished, start to sign.</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Cert success.</div><div class="line">-----BEGIN CERTIFICATE-----</div><div class="line">MIIEMTCCAxmgAwIBAgISA1+gJF5zwUDjNX/6Xzz5fo3lMA0GCSqGSIb3DQEBCwUA</div><div class="line">MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD</div><div class="line">ExpMZXQncyBFbmNyeXB0IEF1dGhvcml0eSBYMzAeFw0xNjEyMjkyMzU5MDBaFw0x</div><div class="line">NzAzMjkyMzU5MDBaMBcxFTATBgNVBAMTDHdlYWtzYW5kLmNvbTBZMBMGByqGSM49</div><div class="line">****************************************************************</div><div class="line">4p40tm0aMB837XQ9jeAXvXulhVH/7/wWZ8/vkUUvuHSCYHagENiq/3DYj4a85Iw9</div><div class="line">+6u1r7atYHJ2VwqSamiyTGDQuhc5wdXIQxY/YQQqkAmn5tLsTZnnOavc4plANT40</div><div class="line">zweiG8vcIvMVnnkM0TSz8G1yzv1nOkruN3ozQkLMu6YS7lk/ENBN7DBtYVSmJeU2</div><div class="line">VAXE+zgRaP7JFOqK6DrOwhyE2LSgae83Wq/XgXxjfIo1Zmn2UmlE0sbdNKBasnf9</div><div class="line">gPUI45eltrjcv8FCSTOUcT7PWCa3</div><div class="line">-----END CERTIFICATE-----</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Your cert is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/mydomain.me.cer</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] Your cert key is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/mydomain.me.key</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] The intermediate CA cert is <span class="keyword">in</span>  /root/.acme.sh/mydomain.me_ecc/ca.cer</div><div class="line">[Fri Dec 30 08:59:16 HKT 2016] And the full chain certs is there:  /root/.acme.sh/mydomain.me_ecc/fullchain.cer</div></pre></td></tr></table></figure>
<p><code>-k</code> 表示密钥长度，后面的值可以是 ec-256 、ec-284、2048、3072、4096、8192，带有 ec 表示生成的是 ECC 证书，没有则是 RSA 证书。在安全性上 256 位的 ECC 证书等同于 3072 位的 RSA 证书。</p>
<h3><span id="zheng-shu-geng-xin">证书更新</span></h3><p>由于 Let’s Encrypt 的证书有效期只有 <strong>3 个月</strong>，因此需要 <strong>90</strong> 天至少要更新一次证书，acme.sh 脚本会每 60 天自动更新证书。也可以手动更新。</p>
<p>手动更新 ECC 证书，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --renew <span class="_">-d</span> mydomain.com --force --ecc</div></pre></td></tr></table></figure>
<p>如果是 RSA 证书则执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ~/.acme.sh/acme.sh --renew <span class="_">-d</span> mydomain.com --force</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免费证书如果是阿里云的主机直接申请铁门塞克的1年免费版是极方便的，申请下来后因为在阿里自己的系统内，可以直接面向相对应的产品进行推送，到期后还有自动提醒等等等，服务非常周到，可以看出阿里云一直在打造自己的全家桶。 &lt;/p&gt;
&lt;p&gt;如果不使用阿里云主机的情况下，可以使用本教程
    
    </summary>
    
    
      <category term="HTTPS" scheme="https://www.kanshouce.com/tags/HTTPS/"/>
    
      <category term="SSL" scheme="https://www.kanshouce.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>如何愉快的CentOS7构建一个7 Days To Die Server？</title>
    <link href="https://www.kanshouce.com/2017/11/09/7DaysToDieOnCentOs7/"/>
    <id>https://www.kanshouce.com/2017/11/09/7DaysToDieOnCentOs7/</id>
    <published>2017-11-09T09:44:31.000Z</published>
    <updated>2017-11-14T11:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#sheng-ji-xi-tong">升级系统</a></li>
<li><a href="#chuang-jian-zhang-hu">创建账户</a></li>
<li><a href="#she-zhi-fang-huo-qiang">设置防火墙</a></li>
<li><a href="#an-zhuang-steamcmd-zhi-chi-ku">安装SteamCMD支持库</a></li>
<li><a href="#kai-shi-bu-shu">开始部署</a></li>
<li><a href="#she-zhi-pei-zhi-wen-jian">设置配置文件</a></li>
<li><a href="#chuang-jian-yi-ge-kuai-su-de-sheng-ji-jiao-ben">创建一个快速的升级脚本</a></li>
<li><a href="#yun-xing-fu-wu-qi">运行服务器</a></li>
<li><a href="#serverconfig-xml">serverconfig.xml</a></li>
</ul>
<!-- tocstop -->
</div>

<p>Linx运行七日杀的服务相比Windows稳定而消耗内存更小。下面是部署方法：</p>
<p>安装的先决条件，你需要一个Steam的账号，网络有传不需要Steam也可以成功安装，由于酶试过，不保证。</p>
<h1><span id="sheng-ji-xi-tong">升级系统</span></h1><p>先来升级下系统    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum update</div><div class="line">$ yum upgrade -y</div></pre></td></tr></table></figure>
<h1><span id="chuang-jian-zhang-hu">创建账户</span></h1><p>创建一个账户，这个账户是用于运行七日杀的，七日杀不允许直接root运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ adduser 7d2d</div><div class="line">$ passwd 7d2d</div></pre></td></tr></table></figure>
<h1><span id="she-zhi-fang-huo-qiang">设置防火墙</span></h1><p>这里对应的端口<code>26900</code>是默认的，在后面的<code>serverconfig.xml</code>文件中有设定，所以这里开放了<code>26900</code>后面就不要修改了，如果需要别的端口在这步改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ firewall-cmd --zone=public --add-port=26900/tcp --permanent</div><div class="line">$ firewall-cmd --zone=public --add-port=26900/udp --permanent</div><div class="line">$ firewall-cmd --reload</div></pre></td></tr></table></figure>
<h1><span id="an-zhuang-steamcmd-zhi-chi-ku">安装SteamCMD支持库</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install glibc.i686 libstdc++.i686 -y</div></pre></td></tr></table></figure>
<h1><span id="kai-shi-bu-shu">开始部署</span></h1><p>切换账号到开始创建的七日杀运行账号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ su 7d2d</div><div class="line">$ cd ~</div></pre></td></tr></table></figure>
<p>获取Steam在Linux下的程序包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz</div><div class="line">$ tar xf steamcmd_linux.tar.gz</div></pre></td></tr></table></figure>
<p>进入Steam运行环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./steamcmd.sh</div></pre></td></tr></table></figure>
<p>输入账号和密码进行登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; login steam用户名 steam密码  // 例如 login a 123</div></pre></td></tr></table></figure>
<p>在这里基于Steam的安全机制，会给你的邮箱或手机邮件，提示输入安全码，按照邮件中的安全码输入即可。</p>
<p>设定安装目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; force_install_dir ./72d2</div></pre></td></tr></table></figure>
<p>升级安装命令：<code>app_update</code> 这个命令包含了两个功能，安装或更新。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">steam&gt; app_update 294420 validate</div></pre></td></tr></table></figure>
<p>这里的<code>294420</code>是七日杀服务器程序的ID。</p>
<p>接下来等待漫长的安装吧</p>
<p>请注意，这里最好将 <code>app_update 294420 validate</code> 多执行几次，直到提示无需更新为止。</p>
<h1><span id="she-zhi-pei-zhi-wen-jian">设置配置文件</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nano serverconfig.xml</div></pre></td></tr></table></figure>
<p>如果需要修改，只需要修改里面的值即可</p>
<h1><span id="chuang-jian-yi-ge-kuai-su-de-sheng-ji-jiao-ben">创建一个快速的升级脚本</span></h1><p>如果说每次升级用命令很麻烦，这里可以一劳永逸，创建一个脚本来解决。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nano /home/7d2d/update_7d2d.txt</div></pre></td></tr></table></figure>
<p>首先我们创建一个名字是<code>update_7d2d.txt</code>的文本文件；</p>
<p>接着我们把下面的内容丢进去（需要执行的命令行）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">login 用户名 密码</div><div class="line">force_install_dir ./7d2d</div><div class="line">app_update 294420</div><div class="line">quit</div></pre></td></tr></table></figure>
<p>这样，以后服务器升级的命令会非常容易</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~</div><div class="line">$ ./steamcmd.sh +runscript update_7d2d.txt</div></pre></td></tr></table></figure>
<h1><span id="yun-xing-fu-wu-qi">运行服务器</span></h1><p>启动服务器</p>
<p><strong>32位服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/7d2d/7d2d/</div><div class="line">$ screen -dmS 7d2d ./7DaysToDieServer.x86 -configfile=serverconfig.xml -logfile 7DaysToDie_Data/output_log.txt $ @</div></pre></td></tr></table></figure>
<p><strong>64位服务器</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home/7d2d/7d2d/</div><div class="line">$ screen -dmS 7d2d ./7DaysToDieServer.x86_64 -configfile=serverconfig.xml -logfile 7DaysToDie_Data/output_log.txt $ @</div></pre></td></tr></table></figure>
<ul>
<li><p><code>screen</code> 这个命令的作用是在<code>ssh</code>的链接关闭后，仍然用进程来运行这个程序；</p>
</li>
<li><p>如果没有装<code>screen</code>可以<code>yum install screen</code>安装一个；</p>
</li>
<li><p><code>screen -ls</code>可以列出目前在后台运行的屏幕进程，用<code>screen -r 进程号</code>即可切换到这个屏幕，例子如下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ screen -list</div><div class="line">There is a screen on:</div><div class="line">	3922.7d2d	(Detached)</div><div class="line">1 Socket in /var/run/screen/S-steam.</div></pre></td></tr></table></figure>
<p>如果需要切换到这个屏幕，<code>screen -r 3922</code></p>
<ul>
<li>如果你在开始创建的<code>7d2d</code>这个账号开了一个<code>screen</code>那么在切换或运行命令的时候同样要用<code>su 7d2d</code>将当前操作账号切换到<code>7d2d</code>这个账户上</li>
</ul>
<h1><span id="serverconfig-xml">serverconfig.xml</span></h1><p>这可能是网络上最全面的配置说明了</p>
<p>只需要修改<code>value</code>中的值即可</p>
<table>
<thead>
<tr>
<th>property</th>
<th>默认值</th>
<th>可选项</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServerPort</td>
<td>26900</td>
<td></td>
<td>服务器的端口号</td>
</tr>
<tr>
<td>ServerIsPublic</td>
<td>true</td>
<td>true/false</td>
<td>这个服务器是否注册到全球服务器，即是否开放</td>
</tr>
<tr>
<td>ServerName</td>
<td>My Game Host</td>
<td></td>
<td>服务器名字</td>
</tr>
<tr>
<td>ServerPassword</td>
<td></td>
<td></td>
<td>服务器密码</td>
</tr>
<tr>
<td>ServerMaxPlayerCount</td>
<td>8</td>
<td></td>
<td>最大玩家并发数，一般个人PC 8G 20人</td>
</tr>
<tr>
<td>ServerReservedSlots</td>
<td>0</td>
<td></td>
<td>可设置权限的管理员数量</td>
</tr>
<tr>
<td>ServerReservedSlotsPermission</td>
<td>100</td>
<td></td>
<td>设置服务器同时允许几不同级别管理员在线</td>
</tr>
<tr>
<td>ServerAdminSlots</td>
<td>0</td>
<td></td>
<td>同时允许几个次级管理员在线</td>
</tr>
<tr>
<td>ServerAdminSlotsPermission</td>
<td>0</td>
<td></td>
<td>是否超权可以登录的管理</td>
</tr>
<tr>
<td>ServerDescription</td>
<td>A 7 Days to Die server</td>
<td></td>
<td>服务器的描述信息，可以填一些你认为有用的</td>
</tr>
<tr>
<td>ServerWebsiteURL</td>
<td></td>
<td></td>
<td>服务器网站，一般不用设置</td>
</tr>
<tr>
<td>ServerDisabledNetworkProtocols</td>
<td>UNET</td>
<td></td>
<td>禁用的网络协议，默认的UNET即可</td>
</tr>
<tr>
<td>GameWorld</td>
<td>Navezgane</td>
<td>Navezgane ／ Random Gen</td>
<td>游戏世界设置，默认是有限的Navezgane地图，也可以改为Random Gen，即随机无限地图</td>
</tr>
<tr>
<td>GameName</td>
<td>My Game</td>
<td></td>
<td>游戏名字，如果上面填了Random Gen，这个名字将被用于随机种子生成</td>
</tr>
<tr>
<td>GameDifficulty</td>
<td>2</td>
<td>0-5</td>
<td>模式难度, 0=简单, 5=困难，填写0-5之间的数字</td>
</tr>
<tr>
<td>GameMode</td>
<td>GameModeSurvivalMP</td>
<td>GameModeSurvivalMP／GameModeSurvivalSP</td>
<td>游戏模式，MP（联网），SP（单机）（MP产生领地石效果）</td>
</tr>
<tr>
<td>ZombiesRun</td>
<td>0</td>
<td>0 =夜间狂暴，1 =永不狂暴，2 =始终狂暴</td>
<td>僵尸狂暴设置</td>
</tr>
<tr>
<td>BuildCreate</td>
<td>false</td>
<td>true/false</td>
<td>创造模式，默认关闭，开启后全体可创造</td>
</tr>
<tr>
<td>DayNightLength</td>
<td>60</td>
<td></td>
<td>游戏中24小时等于现实中多少分钟</td>
</tr>
<tr>
<td>DayLightLength</td>
<td>18</td>
<td></td>
<td>在游戏时间里，每天的阳光照射：默认白天18，夜间6</td>
</tr>
<tr>
<td>PlayerKillingMode</td>
<td>3</td>
<td>0 =无杀戮，1 =仅杀死盟友，2 =仅杀死陌生人，3 =杀死所有人</td>
<td>玩家杀戮设置</td>
</tr>
<tr>
<td>PersistentPlayerProfiles</td>
<td>false</td>
<td>true/false</td>
<td>是否拖入玩家单机资料，默认关闭，打开的话联网就完全失去了意义</td>
</tr>
<tr>
<td>PlayerSafeZoneLevel</td>
<td>5</td>
<td></td>
<td>如果玩家的等级在这个级别以下，那么他出生复活时周围不会有僵尸</td>
</tr>
<tr>
<td>PlayerSafeZoneHours</td>
<td>5</td>
<td></td>
<td>这个安全区存在的时间，是游戏中的时间</td>
</tr>
<tr>
<td>ControlPanelEnabled</td>
<td>false</td>
<td>true/false</td>
<td>启用/禁用控制面板，默认关闭</td>
</tr>
<tr>
<td>ControlPanelPort</td>
<td>8080</td>
<td></td>
<td>控制面板端口</td>
</tr>
<tr>
<td>ControlPanelPassword</td>
<td>CHANGEME</td>
<td></td>
<td>网页控制端密码</td>
</tr>
<tr>
<td>TelnetEnabled</td>
<td>true</td>
<td>true/false</td>
<td>是否开启telnet登录</td>
</tr>
<tr>
<td>TelnetPort</td>
<td>8081</td>
<td></td>
<td>telnet端口</td>
</tr>
<tr>
<td>TelnetPassword</td>
<td></td>
<td></td>
<td>telnet链接密码</td>
</tr>
<tr>
<td>AdminFileName</td>
<td>serveradmin.xml</td>
<td></td>
<td>服务器管理文件名，此文本内记录玩家白名单和黑名单以及管理员</td>
</tr>
<tr>
<td>DropOnDeath</td>
<td>2</td>
<td>0 =一切，1 =仅腰带，2 =仅背包，3 =全部删除</td>
<td>死亡掉落设置</td>
</tr>
<tr>
<td>DropOnQuit</td>
<td>0</td>
<td>0 =不掉落，1 =一切，2 =仅腰带，3 =仅背包</td>
<td>退出掉落</td>
</tr>
<tr>
<td>BloodMoonEnemyCount</td>
<td>8</td>
<td></td>
<td>在每个玩家的血月里产生的僵尸数量，第七日每个玩家刷新多少僵尸</td>
</tr>
<tr>
<td>EnemySpawnMode</td>
<td>true</td>
<td>true/false</td>
<td>启用/禁用僵尸刷新，默认开启，关掉就没有僵尸了</td>
</tr>
<tr>
<td>EnemyDifficulty</td>
<td>0</td>
<td>0 =无法感应，1 =能感应</td>
<td>僵尸能不能隔墙感应到玩家</td>
</tr>
<tr>
<td>BlockDurabilityModifier</td>
<td>100</td>
<td></td>
<td>游戏中各种方块的强度</td>
</tr>
<tr>
<td>LootAbundance</td>
<td>100</td>
<td></td>
<td>刷新物资的丰富度</td>
</tr>
<tr>
<td>LootRespawnDays</td>
<td>30</td>
<td></td>
<td>游戏中多少天刷新一次物资</td>
</tr>
<tr>
<td>LandClaimSize</td>
<td>41</td>
<td></td>
<td>领地石保护大小</td>
</tr>
<tr>
<td>LandClaimDeadZone</td>
<td>30</td>
<td></td>
<td>领地石范围不能放任何东西（除非你是与其他玩家的朋友）</td>
</tr>
<tr>
<td>LandClaimExpiryTime</td>
<td>3</td>
<td></td>
<td>玩家离线多少天不再保护</td>
</tr>
<tr>
<td>LandClaimDecayMode</td>
<td>0</td>
<td>0 =线性，1 =指数，2 =完全保护，直到过期</td>
<td>离线玩家领地石衰落</td>
</tr>
<tr>
<td>LandClaimOnlineDurabilityModifier</td>
<td>4</td>
<td>0表示无敌（不会损坏）。 默认值为4</td>
<td>当玩家在线时，领地石保护硬度增加了多少</td>
</tr>
<tr>
<td>LandClaimOfflineDurabilityModifier</td>
<td>4</td>
<td>0表示无敌（不会损坏）。 默认值为4</td>
<td>当玩家离线时，领地石硬度会增加</td>
</tr>
<tr>
<td>AirDropFrequency</td>
<td>72</td>
<td>0 = 从不</td>
<td>空投，在游戏时间里多少小时一次</td>
</tr>
<tr>
<td>AirDropMarker</td>
<td>false</td>
<td>true/false</td>
<td>是否在地图上开启空头标志</td>
</tr>
<tr>
<td>MaxSpawnedZombies</td>
<td>80</td>
<td></td>
<td>丧尸刷新数（超过80个）可能会导致服务器运行在较差的帧率，这将影响客户的延迟和流畅度</td>
</tr>
<tr>
<td>MaxSpawnedAnimals</td>
<td>50</td>
<td></td>
<td>服务器生成动物的数量</td>
</tr>
<tr>
<td>EACEnabled</td>
<td>true</td>
<td>true/false</td>
<td>Eac校验，如果关了外挂就进来了</td>
</tr>
<tr>
<td>HideCommandExecutionLog</td>
<td>0</td>
<td>0 =显示所有内容，1 =仅从Telnet / ControlPanel隐藏，2 =也隐藏远程游戏客户端，3 =隐藏所有内容</td>
<td>隐藏命令执行记录</td>
</tr>
<tr>
<td>MaxUncoveredMapChunksPerPlayer</td>
<td>131072</td>
<td></td>
<td>覆盖每个玩家在游戏地图上可以发现多少块。 最大地图文件大小为512字节。 默认131072意味着最多32公里2可以随时发现</td>
</tr>
<tr>
<td>BedrollDeadZoneSize</td>
<td>15</td>
<td></td>
<td>死亡区域的大小，这个区域内不会产生僵尸，任何清除的睡眠者数量，触摸死板死亡区域将不会产生后</td>
</tr>
<tr>
<td>SaveGameFolder</td>
<td></td>
<td></td>
<td>存盘位置，linux版本默认是注释掉的，windows版可以设置</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#sheng-ji-xi-tong&quot;&gt;升级系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#chuang-jian-zhang-hu&quot;&gt;创建账
    
    </summary>
    
    
      <category term="Game Server" scheme="https://www.kanshouce.com/tags/Game-Server/"/>
    
      <category term="7 Days To Die" scheme="https://www.kanshouce.com/tags/7-Days-To-Die/"/>
    
  </entry>
  
  <entry>
    <title>利用github的webhook自动化部署(PHP)</title>
    <link href="https://www.kanshouce.com/2017/11/09/github-webhook/"/>
    <id>https://www.kanshouce.com/2017/11/09/github-webhook/</id>
    <published>2017-11-09T09:21:40.000Z</published>
    <updated>2017-11-09T10:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="she-zhi-github">设置GITHUB</span></h1><p>在项目页的<code>Settings</code> -&gt; <code>Webhooks</code>中设置</p>
<ul>
<li><p><code>Raload URL</code> 填写每次调用的钩子地址；</p>
</li>
<li><p><code>Secret</code> 设置一个密码，后面会用到。</p>
</li>
</ul>
<p><img src="https://pic.kanshouce.com/blog/2017-11-09-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-09%20%E4%B8%8B%E5%8D%885.22.49.png?x-oss-process=style/JPG" alt=""></p>
<h1><span id="fu-wu-qi-webhook-wen-jian">服务器webhook文件</span></h1><ul>
<li><code>$secret = &quot;&quot;</code> 这里填入你在github上设置的秘钥</li>
<li><code>$path = &quot;&quot;</code> 这里填你在服务器的项目根目录</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// 填写你在github设置页面中设置的密钥（Keep it the same with the 'Secret' field on your Webhooks / Manage webhook page of your respostory）</span></div><div class="line">$secret = <span class="string">""</span>;</div><div class="line"><span class="comment">// 项目根目录, 如: "/var/www/xxxbbs"</span></div><div class="line">$path = <span class="string">""</span>;</div><div class="line"><span class="comment">// Headers deliveried from GitHub</span></div><div class="line">$signature = $_SERVER[<span class="string">'HTTP_X_HUB_SIGNATURE'</span>];</div><div class="line"><span class="keyword">if</span> ($signature) &#123;</div><div class="line">  $hash = <span class="string">"sha1="</span> . hash_hmac(<span class="string">'sha1'</span>, $HTTP_RAW_POST_DATA, $secret);</div><div class="line">  <span class="keyword">if</span> (strcmp($signature, $hash) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">echo</span> shell_exec(<span class="string">"cd &#123;$path&#125; &amp;&amp; /usr/bin/git reset --hard origin/master &amp;&amp; /usr/bin/git clean -f &amp;&amp; /usr/bin/git pull 2&gt;&amp;1"</span>);</div><div class="line">      <span class="keyword">exit</span>();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">http_response_code(<span class="number">404</span>);</div></pre></td></tr></table></figure>
<h2><span id="geng-xin-ming-ling-shuo-ming">更新命令说明</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shell_exec(<span class="string">"cd &#123;<span class="variable">$path</span>&#125; &amp;&amp; /usr/bin/git reset --hard origin/master &amp;&amp; /usr/bin/git clean -f &amp;&amp; /usr/bin/git pull 2&gt;&amp;1"</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p><code>/usr/bin/git reset --hard origin/master</code> 强制恢复版本到前一个稳定版</p>
</li>
<li><p><code>/usr/bin/git clean -f</code> 清理提交的更改</p>
</li>
<li><p><code>/usr/bin/git pull 2&gt;&amp;1</code> 拉取最新的版本到本地</p>
</li>
</ul>
<p><strong>这里需要注意是，如果<code>webhook</code>和<code>网站</code>处于<code>同目录</code>，用上面的命令<code>webhook</code>文件将被清理。<br>所以请根据实际应用场景部署。</strong></p>
<h1><span id="planb-shell-geng-xin">PlanB shell更新</span></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line">WEB_PATH=<span class="string">'/var/www/webbbs'</span></div><div class="line">WEB_USER=<span class="string">'nginx'</span></div><div class="line">WEB_USERGROUP=<span class="string">'nginx'</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"Start deployment"</span></div><div class="line"><span class="built_in">cd</span> <span class="variable">$WEB_PATH</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"pulling source code..."</span></div><div class="line">git reset --hard origin/master</div><div class="line">git clean <span class="_">-f</span></div><div class="line">git pull</div><div class="line">git checkout master</div><div class="line"><span class="built_in">echo</span> <span class="string">"changing permissions..."</span></div><div class="line">chown -R <span class="variable">$WEB_USER</span>:<span class="variable">$WEB_USERGROUP</span> <span class="variable">$WEB_PATH</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"Finished."</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;&lt;span id=&quot;she-zhi-github&quot;&gt;设置GITHUB&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在项目页的&lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Webhooks&lt;/code&gt;中设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Raload 
    
    </summary>
    
      <category term="github" scheme="https://www.kanshouce.com/categories/github/"/>
    
    
      <category term="github" scheme="https://www.kanshouce.com/tags/github/"/>
    
      <category term="webhook" scheme="https://www.kanshouce.com/tags/webhook/"/>
    
      <category term="php" scheme="https://www.kanshouce.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>一个用Jquery遍历tbale表单获取值的例子</title>
    <link href="https://www.kanshouce.com/2017/08/12/jquery-Array-table/"/>
    <id>https://www.kanshouce.com/2017/08/12/jquery-Array-table/</id>
    <published>2017-08-11T18:48:34.000Z</published>
    <updated>2017-11-09T09:20:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个用Jquery的简单例子。</p>
<a id="more"></a>
<p>假设一个网页有N张表，就像本站的<code>阅读者</code><a href="/reader">频道</a>一样，需要获取每张表的最后一个值，这时候要用到两个知识点：</p>
<ul>
<li>遍历</li>
<li>数组栈</li>
</ul>
<p><code>阅读者</code>频道在尾部的进度条<code>x%</code>值获取实现就是基础在这段小脚本上。当然，在实现的过程中没有用到出入栈的概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//首先等待页面的DOM树加载完</span></div><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> $Uname = $(<span class="string">"tbody"</span>).length;   <span class="comment">//取到页面内tbody标签出现了多少次</span></div><div class="line">            <span class="keyword">var</span> Data = [];</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; $Uname; i++) &#123;    <span class="comment">//根据tbody标签出现的次数进行遍历次数</span></div><div class="line">                $a = $(<span class="string">"div tbody"</span>).eq(i).find(<span class="string">"td:last"</span>).text();   <span class="comment">//根据jq条件查询到（td:last），每个td最后一行的数据。</span></div><div class="line">                Data.push($a);                <span class="comment">//用push()的方法将数据入站</span></div><div class="line">             &#125;</div><div class="line">        $(<span class="string">"#1"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">0</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);   <span class="comment">//修改DOM上的值</span></div><div class="line">        $(<span class="string">"#2"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">1</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);</div><div class="line">        $(<span class="string">"#3"</span>).attr(<span class="string">"style"</span>,<span class="string">'width:'</span>+ (((Data[<span class="number">2</span>])/<span class="number">50</span>)*<span class="number">100</span>)+<span class="string">'%'</span>);</div><div class="line">        &#125;</div><div class="line">        );</div></pre></td></tr></table></figure>
<p>这里用到了Javescript常用的数组方法：<code>push()</code></p>
<p>在数组栈里出了<code>push()</code>还有一个方法是<code>pop()</code>，这两种方法都允许将数组当作<strong>栈</strong>来使用，用<code>push()</code>会在数组的尾部添加一个或者多个元素，并返回数组新的长度。<code>pop()</code>则正好相反，它的作用是删除数组的最后一个元素，减小数组的长度并返回它删除的值，在犀牛书里，特意描述了需要注意的部分：</p>
<blockquote>
<p>两个方法都修改并替换原始数组而并非生成一个修改版的新数组。组合使用<code>push()</code>和<code>pop()</code>能够用Javascript数组实现先后出栈。</p>
</blockquote>
<h2><span id="guan-yu-zhan">关于“栈”</span></h2><p>这里我们先补一下关于<strong>栈</strong>的知识点：</p>
<blockquote>
<p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
<p>栈是限定仅在表头进行插入和删除操作的线性表。</p>
<p>就好比：一个死胡同，前面是“此路不通”，只有一个入口，如果一队人进入，只能队尾变对首出去。</p>
</blockquote>
<p>在<code>出栈</code>和<code>入栈</code>的概念上，用图示大概是这样的：</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-push1.png" alt=""></p>
<p>用<code>push()</code>和<code>pop()</code>模拟一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">        <span class="keyword">var</span> temp = i + <span class="number">1</span>;</div><div class="line">        arr.push(temp);</div><div class="line">        <span class="built_in">console</span>.log(temp + <span class="string">"  入栈"</span>);</div><div class="line">        <span class="built_in">console</span>.log(arr);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'栈，先进后出'</span>);  </div><div class="line">    <span class="keyword">var</span> len = arr.length;               <span class="comment">//这个地方需要注意，因为在出栈的过程arr.length是变化的，每移除一个元素，arr.length就会减一，所以需要将其赋值给一个变量</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="built_in">console</span>.log(arr.pop());</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>结果是：</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-push2.png" alt=""></p>
<h2><span id="guan-yu-dui-lie">关于“队列”</span></h2><p>这里另外一个知识点是关于队列的</p>
<p>队列在javascript里用的是<code>unshift()</code>和<code>pop()</code>方法。</p>
<blockquote>
<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<p>就好比：现在这个胡同不是死胡同了，队伍可以直接通过。</p>
</blockquote>
<p>模拟一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">        <span class="keyword">var</span> arr = [];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">var</span> temp = i + <span class="number">1</span>;</div><div class="line">            arr.unshift(temp);</div><div class="line">            <span class="built_in">console</span>.log(temp + <span class="string">"  插入"</span>);</div><div class="line">            <span class="built_in">console</span>.log(arr);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'队列，先进先出 First In First Out'</span>);    </div><div class="line">        <span class="keyword">var</span> len = arr.length;               <span class="comment">//这个地方需要注意，因为在删除的过程arr.length是变化的，每移除一个元素，arr.length就会减一，所以需要将其赋值给一个变量</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">            <span class="built_in">console</span>.log(arr.pop());</div><div class="line">        &#125;</div><div class="line">    &lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>结果</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-p3.png" alt=""></p>
<p><code>unshift()</code>和<code>shift()</code>在用法上实际上是一对的，他们非常类似<code>push()</code>和<code>pop()</code>，不一样的是前者是在数组头部而非尾部进行元素插入和删除操作。<code>unshift()</code>在数组头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。<code>shift()</code>删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个用Jquery的简单例子。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://www.kanshouce.com/categories/Javascript/"/>
    
    
      <category term="Jquery" scheme="https://www.kanshouce.com/tags/Jquery/"/>
    
      <category term="WEB" scheme="https://www.kanshouce.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>没错！可以用RTL-SDR观测闪电！</title>
    <link href="https://www.kanshouce.com/2017/08/12/rtl-view-lightning/"/>
    <id>https://www.kanshouce.com/2017/08/12/rtl-view-lightning/</id>
    <published>2017-08-11T18:34:05.000Z</published>
    <updated>2017-08-11T18:40:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>据说有个笑话是这样的：<code>我要瘦成一道闪电</code>，说它是笑话是因为闪电根据统计宽度达<code>4米</code>，这明明就是想减肥人的噩梦！</p>
<a id="more"></a>
<p>为什么能用RTL-SDR观测到闪电？</p>
<blockquote>
<p>因为闪电产生相当宽的RF能量突发</p>
</blockquote>
<p>特别是在VLF中低频到HF频率</p>
<p>国外有很多专业用定制的硬件来观测闪电突发的，比如说这个<a href="blitzortung.org">blitzortung.org</a>。</p>
<p>当然，你也可以使用RTL-SDR调谐到HF，例如在RTL-SDR V3或具有上变频器的RTL-SDR。在一个歪果仁的网站上Kenn Ranous（KA0SBL）上传了一篇<a href="https://ranous.wordpress.com/2017/08/03/diy-lightning-detection-with-sdr/" target="_blank" rel="external">短片</a>，显示了他在RTL-SDR瀑布上闪电的样子。他使用RTL-SDR V3调谐到LF-MW频段，并可以找到指示闪电的宽带噪声脉冲。</p>
<p>看看这种类型的检测是否可以通过DSP进行自动化是非常趣的，如果有足够的兴趣，甚至可以搭建一个Blitzortung.org类似的服务。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-11-lightning1.png?x-oss-process=style/JPG" alt=""></p>
<p>闪电脉冲</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;据说有个笑话是这样的：&lt;code&gt;我要瘦成一道闪电&lt;/code&gt;，说它是笑话是因为闪电根据统计宽度达&lt;code&gt;4米&lt;/code&gt;，这明明就是想减肥人的噩梦！&lt;/p&gt;
    
    </summary>
    
      <category term="RTL-SDR" scheme="https://www.kanshouce.com/categories/RTL-SDR/"/>
    
    
      <category term="RTL" scheme="https://www.kanshouce.com/tags/RTL/"/>
    
      <category term="lightning" scheme="https://www.kanshouce.com/tags/lightning/"/>
    
  </entry>
  
  <entry>
    <title>这是一个加密测试</title>
    <link href="https://www.kanshouce.com/2017/08/12/encrypt-test/"/>
    <id>https://www.kanshouce.com/2017/08/12/encrypt-test/</id>
    <published>2017-08-11T17:33:42.000Z</published>
    <updated>2017-08-11T18:12:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3><span id="welcome-to-my-blog-enter-password-to-read">Welcome to my blog, enter password to read.</span></h3><script src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 请输入密码 "> <label for="pass"> Enter </label> <div class="bottom-line"></div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1+SB8o3roA+CTfsKYxjBlo6a0e5UbyJqBL159uzatr8idNwU5PcEAxgMXc4SiZIYWasDuzVuyMv9ZlcvxmX8wePN6j0ZycfumotgqjqwJvUIYu/74dUjwm3lohA+FM/Ok6HfuYBySJR83PRiIpdsoqcL05P9lpgSscmv+/j/YtiNd1Or3toVGvLnf+XOa3+Ja0IPIsdYTay9zPHGAHPPPxksL9NpVnegBKCdFrqteq2eNWnaWi6mHPy </div>]]></content>
    
    <summary type="html">
    
      the content has been encrypted, enter the password to read.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>egg-static 中文说明</title>
    <link href="https://www.kanshouce.com/2017/08/10/egg-static/"/>
    <id>https://www.kanshouce.com/2017/08/10/egg-static/</id>
    <published>2017-08-10T10:23:54.000Z</published>
    <updated>2017-08-10T10:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自Github Egg项目页</p>
<p><a href="https://github.com/eggjs/egg-static" target="_blank" rel="external">直达戳我</a></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#egg-static">egg-static</a><ul>
<li><a href="#an-zhuang">安装</a></li>
<li><a href="#shi-yong">使用</a></li>
<li><a href="#shi-yong-1">使用</a></li>
<li><a href="#pei-zhi">配置</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>

<h1><span id="egg-static">egg-static</span></h1><p>静态服插件，基础与koa的静态插件 <a href="https://github.com/koajs/static-cache" target="_blank" rel="external">koa-static-cache</a>.</p>
<h2><span id="an-zhuang">安装</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm i egg-static --save</div></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span></h2><p>在Egg的官方手册里是这样介绍的</p>
<p>Egg 内置了 <code>static</code> 插件，线上环境建议部署到 CDN，无需该插件。</p>
<p><code>static</code> 插件默认映射 <code>/public/*</code> -&gt; <code>app/public/*</code> 目录</p>
<p>此处，我们把静态资源都放到 <code>app/public</code> 目录即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app/public</div><div class="line">├── css</div><div class="line">│   └── news.css</div><div class="line">└── js</div><div class="line">    ├── lib.js</div><div class="line">    └── news.js</div></pre></td></tr></table></figure>
<h2><span id="shi-yong">使用</span></h2><p>如果没有特别的要求，egg的脚手架对这个功能是默认开启的，在配置文件<code>plugin.js</code>里可以选择开启或关闭：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// had enabled by egg</span></div><div class="line">exports.static = <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<h2><span id="pei-zhi">配置</span></h2><p><code>egg-static</code> 支持 <a href="https://github.com/koajs/static-cache" target="_blank" rel="external">koa-static-cache</a>中的所有配置。 支持的配置如下：</p>
<ul>
<li>prefix: <code>/public/</code></li>
<li>dir: <code>path.join(appInfo.baseDir, &#39;app/public&#39;)</code></li>
<li>dynamic: <code>true</code></li>
<li>preload: <code>false</code></li>
<li>maxAge: <code>31536000</code> in prod env, <code>0</code> in other envs</li>
<li>buffer: <code>true</code> in prod env, <code>false</code> in other envs</li>
</ul>
<p><code>egg-static</code> 提供了一个更多的选项</p>
<ul>
<li>maxFiles: 缓存项目的最大值，仅在动态为<code>true</code>时有效，默认为<code>“1000”</code>。</li>
</ul>
<p><strong>所有的静态文件位于 <code>$baseDir/app/public</code> 在模版或调用的地方可以用 <code>/public</code>访问。所有的文件都会被加载</strong>。</p>
<ul>
<li>在非生产环境中，数据不会被缓存，修改可以立即生效。</li>
<li>在生产环境中，<code>egg-static</code>将在访问后缓存数据，需要重新启动更新数据。</li>
<li>默认目录是 <code>$baseDir/app/public</code> <strong>但是可以定义多个目录</strong> 用 <code>dir: [dir1, dir2, ...]</code> 在加载的时候服务器会加载这些目录</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &#123;app_root&#125;/config/config.default.js</span></div><div class="line">exports.static = &#123;</div><div class="line">  <span class="comment">// maxAge: 31536000,</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2><span id="license">License</span></h2><p><a href="https://github.com/eggjs/egg-static/blob/master/LICENSE" target="_blank" rel="external">MIT</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译自Github Egg项目页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eggjs/egg-static&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;直达戳我&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;toc&quot;&gt;

&lt;!--
    
    </summary>
    
      <category term="egg" scheme="https://www.kanshouce.com/categories/egg/"/>
    
    
      <category term="egg-static" scheme="https://www.kanshouce.com/tags/egg-static/"/>
    
      <category term="egg" scheme="https://www.kanshouce.com/tags/egg/"/>
    
  </entry>
  
  <entry>
    <title>koa-guide-v2</title>
    <link href="https://www.kanshouce.com/2017/08/10/koa-guide-v2/"/>
    <id>https://www.kanshouce.com/2017/08/10/koa-guide-v2/</id>
    <published>2017-08-10T10:06:08.000Z</published>
    <updated>2017-08-10T10:15:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份<br><a id="more"></a></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#zhong-wen-wen-dang">中文文档</a><ul>
<li><a href="#koa-jian-jie">koa 简介</a></li>
<li><a href="#an-zhuang-koa">安装 koa</a><ul>
<li><a href="#shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</a></li>
</ul>
</li>
<li><a href="#ying-yong-application">应用（Application）</a></li>
<li><a href="#ji-lian-dai-ma-cascading">级联代码（Cascading）</a></li>
<li><a href="#ying-yong-pei-zhi-settings">应用配置（Settings）</a></li>
<li><a href="#zhong-jian-jian-middleware">中间件（Middleware）</a></li>
<li><a href="#chang-yong-fang-fa">常用方法</a><ul>
<li><a href="#app-listen">app.listen(…)</a></li>
<li><a href="#app-callback">app.callback()</a></li>
<li><a href="#app-use-function">app.use(function)</a></li>
<li><a href="#app-keys">app.keys=</a></li>
</ul>
</li>
<li><a href="#cuo-wu-chu-li-error-handling">错误处理（Error Handling）</a></li>
<li><a href="#ying-yong-shang-xia-wen-context">应用上下文（Context）</a><ul>
<li><a href="#request-dui-xiang">Request 对象</a></li>
<li><a href="#response-dui-xiang">Response 对象</a></li>
<li><a href="#shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</a></li>
</ul>
</li>
<li><a href="#request">Request</a><ul>
<li><a href="#req-header">req.header</a></li>
<li><a href="#req-method">req.method</a></li>
<li><a href="#req-method">req.method=</a></li>
<li><a href="#req-length">req.length</a></li>
<li><a href="#req-url">req.url</a></li>
<li><a href="#req-url">req.url=</a></li>
<li><a href="#req-path">req.path</a></li>
<li><a href="#req-path">req.path=</a></li>
<li><a href="#req-querystring">req.querystring</a></li>
<li><a href="#req-querystring">req.querystring=</a></li>
<li><a href="#req-search">req.search</a></li>
<li><a href="#req-search">req.search=</a></li>
<li><a href="#req-host">req.host</a></li>
<li><a href="#req-type">req.type</a></li>
<li><a href="#req-query">req.query</a></li>
<li><a href="#req-query">req.query=</a></li>
<li><a href="#req-fresh">req.fresh</a></li>
<li><a href="#req-stale">req.stale</a></li>
<li><a href="#req-protocol">req.protocol</a></li>
<li><a href="#req-secure">req.secure</a></li>
<li><a href="#req-ip">req.ip</a></li>
<li><a href="#req-ips">req.ips</a></li>
<li><a href="#req-subdomains">req.subdomains</a></li>
<li><a href="#req-is-type">req.is(type)</a></li>
<li><a href="#req-accepts-type">req.accepts(type)</a></li>
<li><a href="#req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</a></li>
<li><a href="#req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</a></li>
<li><a href="#req-acceptslanguages-langs">req.acceptsLanguages(langs)</a></li>
</ul>
</li>
<li><a href="#response">Response</a><ul>
<li><a href="#res-header">res.header</a></li>
<li><a href="#res-status">res.status</a></li>
<li><a href="#res-status">res.status=</a></li>
<li><a href="#res-length">res.length=</a></li>
<li><a href="#res-length">res.length</a></li>
<li><a href="#res-body">res.body</a></li>
<li><a href="#res-body">res.body=</a></li>
<li><a href="#res-get-field">res.get(field)</a></li>
<li><a href="#res-set-field-value">res.set(field, value)</a></li>
<li><a href="#res-set-fields">res.set(fields)</a></li>
<li><a href="#res-remove-fields">res.remove(fields)</a></li>
<li><a href="#res-type">res.type</a></li>
<li><a href="#res-type">res.type=</a></li>
<li><a href="#res-redirect-url-alt">res.redirect(url, [alt])</a></li>
<li><a href="#res-attachment-filename">res.attachment([filename])</a></li>
<li><a href="#res-headersent">res.headerSent</a></li>
<li><a href="#res-lastmodified">res.lastModified</a></li>
<li><a href="#res-etag">res.etag=</a></li>
</ul>
</li>
<li><a href="#xing-neng-benchmarks">性能（Benchmarks）</a></li>
<li><a href="#xue-xi-zi-liao">学习资料</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#mit-license">MIT license</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>




<h1><span id="zhong-wen-wen-dang">中文文档</span></h1><p>Koa，下一代 Node.js web 框架</p>
<h2><span id="koa-jian-jie">koa 简介</span></h2><p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p>
<h2><span id="an-zhuang-koa">安装 koa</span></h2><p>Koa需要支持ES2015和<code>async</code> function的node v7.6.0或更高版本。</p>
<p>您可以使用喜欢的依赖管理工具快速安装支持的node版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nvm install 7</div><div class="line">$ npm i koa</div><div class="line">$ node my-koa-app.js</div></pre></td></tr></table></figure>
<h3><span id="shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</span></h3><p>在node 7.6版本以下，如果你想在koa里使用<code>async</code> functions，我们推荐<a href="http://babeljs.io/docs/usage/require/" target="_blank" rel="external">babel</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(&apos;babel-core/register&apos;);</div><div class="line">// require the rest of the app that needs to be transpiled after the hook</div><div class="line">const app = require(&apos;./app&apos;);</div></pre></td></tr></table></figure>
<p>你至少要使用<a href="http://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="external">transform-async-to-generator</a> or <a href="http://babeljs.io/docs/plugins/transform-async-to-module-method/" target="_blank" rel="external">transform-async-to-module-method</a>插件，<br>来解析和转译async functions。例如，你可以在你的<code>.babelrc</code>文件里这样写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-async-to-generator"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">env preset</a>里使用目标选项<code>&quot;node&quot;: &quot;current&quot;</code>。</p>
<hr>
<h2><span id="ying-yong-application">应用（Application）</span></h2><p>一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect/Express ）没有什么太大差别，不过，从另一个层面来看，Koa 提供了一种基于底层中间件编写「语法糖」的设计思路，这让设计中间件变得更简单有趣。</p>
<p>在这些中间件中，有负责内容协商（content-negotation）、缓存控制（cache freshness）、反向代理（proxy support）与重定向等等功能的常用中间件（详见 <a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6middleware">中间件</a> 章节），但如前所述， Koa 内核并不会打包这些中间件，让我们先来看看 Koa 极其简单的 Hello World 应用程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果使用Koa 2的话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</div><div class="line">  ctx.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p><strong>译者注：</strong> 与普通的 function 不同，generator functions 以 <code>function*</code> 声明，以这种关键词声明的函数支持 <code>yield</code>。generator function是ECMAScript 6定义的新的语法，想了解其基本用法，以及Koa如何利用generator function达到在保持js代码异步特性的同时无需编写大量回调函数，可以参考<a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/" target="_blank" rel="external">这篇文章</a>。</p>
<hr>
<h2><span id="ji-lian-dai-ma-cascading">级联代码（Cascading）</span></h2><p>Koa 中间件以一种非常传统的方式级联起来，你可能会非常熟悉这种写法。</p>
<p>在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 <code>yield next</code> 关键字时，会被传递到下一个符合请求的路由（downstream），在 <code>yield next</code> 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
<p>下边这个例子展现了使用这一特殊方法书写的 Hello World 范例：一开始，用户的请求通过 x-response-time 中间件和 logging 中间件，这两个中间件记录了一些请求细节，然后「穿过」 response 中间件一次，最终结束请求，返回 「Hello World」。</p>
<p>当程序运行到 <code>yield next</code> 时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码，这样切换控制权的方式，被称为<br>downstream，当没有下一个中间件执行 downstream 的时候，代码将会逆序执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line"><span class="comment">// x-response-time</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (1) 进入路由</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);</div><div class="line">  <span class="comment">// (6) 返回 this.body</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// logger</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (2) 进入 logger 中间件</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// response</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream</span></div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>在上方的范例代码中，中间件依次被执行的顺序已经在注释中标记出来。你也可以自己尝试运行一下这个范例，并打印记录下各个环节的输出与耗时。</p>
<p><strong>译者注：</strong> 「级联」这个词许多人也许在 CSS 中听说过，如果你不能理解为什么在这里使用这个词，可以将这种路由结构想象成 LESS 的继承嵌套书写方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.middleware1 &#123;</div><div class="line">  // (1) do some stuff</div><div class="line">  .middleware2 &#123;</div><div class="line">    // (2) do some other stuff</div><div class="line">    .middleware3 &#123;</div><div class="line">      // (3) NO next yield !</div><div class="line">      // this.body = &apos;hello world&apos;</div><div class="line">    &#125;</div><div class="line">    // (4) do some other stuff later</div><div class="line">  &#125;</div><div class="line">  // (5) do some stuff lastest and return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上方的伪代码中标注了中间件的执行顺序，看起来是不是有点像 ruby 执行代码块（block）时 yield 的表现了？也许这能帮助你更好的理解 koa 运作的方式。</p>
<p><strong>译者注：</strong> 更加形象的图可以参考 <a href="https://docs.djangoproject.com/en/1.6/topics/http/middleware/" target="_blank" rel="external">Django Middleware</a></p>
<p><img src="https://raw.github.com/fengmk2/koa-guide/master/onion.png" alt="onion.png"></p>
<hr>
<h2><span id="ying-yong-pei-zhi-settings">应用配置（Settings）</span></h2><p>应用的配置是 app 实例的属性。目前来说，Koa 的配置项如下：</p>
<ul>
<li>app.name 应用名称</li>
<li>app.env 执行环境，默认是 <code>NODE_ENV</code> 或者 <code>&quot;development&quot;</code> 字符串</li>
<li>app.proxy 决定了哪些 <code>proxy header</code> 参数会被加到信任列表中</li>
<li>app.subdomainOffset 被忽略的 <code>.subdomains</code> 列表，详见下方 api</li>
</ul>
<hr>
<h2><span id="zhong-jian-jian-middleware">中间件（Middleware）</span></h2><ul>
<li><a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="external">koa-router</a></li>
<li><a href="https://github.com/koajs/trie-router" target="_blank" rel="external">trie-router</a></li>
<li><a href="https://github.com/koajs/route" target="_blank" rel="external">route</a></li>
<li><a href="https://github.com/koajs/basic-auth" target="_blank" rel="external">basic-auth</a></li>
<li><a href="https://github.com/koajs/etag" target="_blank" rel="external">etag</a></li>
<li><a href="https://github.com/koajs/compose" target="_blank" rel="external">compose</a></li>
<li><a href="https://github.com/koajs/static" target="_blank" rel="external">static</a></li>
<li><a href="https://github.com/koajs/static-cache" target="_blank" rel="external">static-cache</a></li>
<li><a href="https://github.com/koajs/session" target="_blank" rel="external">session</a></li>
<li><a href="https://github.com/koajs/compress" target="_blank" rel="external">compress</a></li>
<li><a href="https://github.com/koajs/csrf" target="_blank" rel="external">csrf</a></li>
<li><a href="https://github.com/koajs/logger" target="_blank" rel="external">logger</a></li>
<li><a href="https://github.com/koajs/mount" target="_blank" rel="external">mount</a></li>
<li><a href="https://github.com/koajs/send" target="_blank" rel="external">send</a></li>
<li><a href="https://github.com/koajs/error" target="_blank" rel="external">error</a></li>
</ul>
<hr>
<h2><span id="chang-yong-fang-fa">常用方法</span></h2><h3><span id="app-listen">app.listen(…)</span></h3><p>用于启动一个服务的快捷方法，以下范例代码在 3000 端口启动了一个空服务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>app.listen 是 http.createServer 的简单包装，它实际上这样运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果有需要，你可以在多个端口上启动一个 app，比如同时支持 HTTP 和 HTTPS：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div><div class="line">http.createServer(app.callback()).listen(<span class="number">3001</span>);</div></pre></td></tr></table></figure>
<h3><span id="app-callback">app.callback()</span></h3><p>返回一个可被 <code>http.createServer()</code> 接受的程序实例，也可以将这个返回函数挂载在一个 Connect/Express 应用中。</p>
<h3><span id="app-use-function">app.use(function)</span></h3><p>将给定的 function 当做中间件加载到应用中，详见 <a href="#middleware">中间件</a> 章节</p>
<h3><span id="app-keys">app.keys=</span></h3><p>设置一个签名 Cookie 的密钥。这些参数会被传递给 <a href="https://github.com/jed/keygrip" target="_blank" rel="external">KeyGrip</a> 如果你想自己生成一个实例，也可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.keys = [<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>];</div><div class="line">app.keys = <span class="keyword">new</span> KeyGrip([<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>], <span class="string">'sha256'</span>);</div></pre></td></tr></table></figure>
<p>注意，签名密钥只在配置项 <code>signed</code> 参数为真时才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.cookies.set(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</div></pre></td></tr></table></figure>
<h2><span id="cuo-wu-chu-li-error-handling">错误处理（Error Handling）</span></h2><p>除非 <code>NODE_ENV</code> 被配置为 <code>&quot;test&quot;</code>，Koa 都将会将所有错误信息输出到 <code>stderr</code>，也可以自定义「错误事件」来监听 Koa app 中发生的错误，比如记录错误日志：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当任何 <code>req</code> 或者 <code>res</code> 中出现的错误无法被回应到客户端时，Koa 会在第二个参数传入这个错误的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err, ctx);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>任何错误有可能被回应到客户端，比如当没有新数据写入 socket 时，Koa 会默认返回一个 500 错误，并抛出一个 app 级别的错误到日志处理中间件中。</p>
<hr>
<h2><span id="ying-yong-shang-xia-wen-context">应用上下文（Context）</span></h2><p>Koa 的上下文封装了 request 与 response 对象至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。为了方便，你可以在 <code>ctx.request</code> 和 <code>ctx.response</code> 中访问到这些方法。</p>
<p>每一个请求都会创建一段上下文。在控制业务逻辑的中间件中，上下文被寄存在 <code>this</code> 对象中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>; <span class="comment">// 上下文对象</span></div><div class="line">  <span class="keyword">this</span>.request; <span class="comment">// Request 对象</span></div><div class="line">  <span class="keyword">this</span>.response; <span class="comment">// Response 对象</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了使用方便，许多上下文属性和方法都被委托代理到他们的 <code>ctx.request</code> 或 <code>ctx.response</code>，比如访问 <code>ctx.type</code> 和 <code>ctx.length</code> 将被代理到 <code>response</code> 对象，<code>ctx.path</code> 和 <code>ctx.method</code> 将被代理到 <code>request</code> 对象。</p>
<h3><span id="request-dui-xiang">Request 对象</span></h3><p>ctx.request 对象包括以下属性和别名方法，详见 <a href="#request">Request</a> 章节</p>
<ul>
<li>ctx.header</li>
<li>ctx.method</li>
<li>ctx.method=</li>
<li>ctx.url</li>
<li>ctx.url=</li>
<li>ctx.path</li>
<li>ctx.path=</li>
<li>ctx.query</li>
<li>ctx.query=</li>
<li>ctx.querystring</li>
<li>ctx.querystring=</li>
<li>ctx.length</li>
<li>ctx.host</li>
<li>ctx.fresh</li>
<li>ctx.stale</li>
<li>ctx.socket</li>
<li>ctx.protocol</li>
<li>ctx.secure</li>
<li>ctx.ip</li>
<li>ctx.ips</li>
<li>ctx.subdomains</li>
<li>ctx.is()</li>
<li>ctx.accepts()</li>
<li>ctx.acceptsEncodings()</li>
<li>ctx.acceptsCharsets()</li>
<li>ctx.acceptsLanguages()</li>
<li>ctx.get()</li>
</ul>
<h3><span id="response-dui-xiang">Response 对象</span></h3><p>ctx.response 对象包括以下属性和别名方法，详见 <a href="#response">Response</a> 章节</p>
<ul>
<li>ctx.body</li>
<li>ctx.body=</li>
<li>ctx.status</li>
<li>ctx.status=</li>
<li>ctx.length=</li>
<li>ctx.type</li>
<li>ctx.type=</li>
<li>ctx.headerSent</li>
<li>ctx.redirect()</li>
<li>ctx.attachment()</li>
<li>ctx.set()</li>
<li>ctx.remove()</li>
<li>ctx.lastModified=</li>
<li>ctx.etag=</li>
</ul>
<h3><span id="shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</span></h3><ul>
<li>ctx.req: Node.js 中的 request 对象</li>
<li>ctx.res: Node.js 中的 response 对象，方法有:<ul>
<li>res.statusCode</li>
<li>res.writeHead()</li>
<li>res.write()</li>
<li>res.end()</li>
</ul>
</li>
<li>ctx.app: app 实例</li>
<li>ctx.state: 推荐的命名空间，用来保存那些通过中间件传递给视图的参数或数据。比如 <code>this.state.user = yield User.find(id);</code></li>
<li>ctx.cookies.get(name, [options]) 对于给定的 name ，返回响应的 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
</ul>
</li>
</ul>
</li>
<li>ctx.cookies.set(name, value, [options]) 对于给定的参数，设置一个新 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
<li><code>expires</code> [date]</li>
<li><code>path</code> [string] 默认为 <code>&#39;/&#39;</code></li>
<li><code>domain</code> [string]</li>
<li><code>secure</code> [boolean]</li>
<li><code>httpOnly</code> [boolean] 默认为 <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>ctx.throw(msg, [status]) 抛出常规错误的辅助方法，默认 status 为 500。</li>
</ul>
<p>以下几种写法都有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.throw(<span class="number">403</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'name required'</span>, <span class="number">400</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="number">400</span>, <span class="string">'name required'</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'something exploded'</span>)</div></pre></td></tr></table></figure>
<p>实际上，<code>this.throw(&#39;name required&#39;, 400)</code> 是此代码片段的简写方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'name required'</span>);</div><div class="line">err.status = <span class="number">400</span>;</div><div class="line"><span class="keyword">throw</span> err;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>ctx.throw</code> 创建的错误，均为用户级别错误（标记为err.expose），会被返回到客户端。</p>
<ul>
<li>ctx.assert(value, [msg], [status], [properties]) 用来断言的辅助方法，类似 Node 中的 <code>assert()</code> 方法。<code>this.assert(this.user, 401, &#39;User not found. Please login!&#39;);</code> 此方法由 <code>http-assert</code> 模块支持。</li>
</ul>
<hr>
<h2><span id="request">Request</span></h2><p>ctx.request 对象是对 Node 原生请求对象的抽象包装，提供了一些非常有用的方法。</p>
<p>详细的 Request 对象 API 如下：</p>
<h3><span id="req-header">req.header</span></h3><p>返回请求头</p>
<h3><span id="req-method">req.method</span></h3><p>返回请求方法</p>
<h3><span id="req-method">req.method=</span></h3><p>设置 req.method ，用于实现输入 <code>methodOverride()</code> 的中间件</p>
<h3><span id="req-length">req.length</span></h3><p>返回 req 对象的 <code>Content-Length</code> (Number)</p>
<h3><span id="req-url">req.url</span></h3><p>返回请求 url</p>
<h3><span id="req-url">req.url=</span></h3><p>设置请求 url，用于进行 url 重写</p>
<h3><span id="req-path">req.path</span></h3><p>返回请求 pathname</p>
<h3><span id="req-path">req.path=</span></h3><p>设置请求 pathname，如果原有 url 存在查询字符串，则保留这些查询。</p>
<h3><span id="req-querystring">req.querystring</span></h3><p>返回 url 中的查询字符串，去除了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-querystring">req.querystring=</span></h3><p>设置查询字符串，不包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search</span></h3><p>返回 url 中的查询字符串，包含了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search=</span></h3><p>设置查询字符串，包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-host">req.host</span></h3><p>返回请求主机名，不包含端口；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Host</code>。</p>
<h3><span id="req-type">req.type</span></h3><p>返回 req 对象的 <code>Content-Type</code>，不包括 <code>charset</code> 属性，范例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query</span></h3><p>返回经过解析的查询字符串，类似 Express 中的 req.query，当不存在查询字符串时，返回空对象。</p>
<p>当 url 包含查询字符串 <code>&quot;color=blue&amp;size=small&quot;</code> 时，返回如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">color</span>: <span class="string">'blue'</span>,</div><div class="line">  <span class="attr">size</span>: <span class="string">'small'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query=</span></h3><p>设置给定的对象为查询对象。范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.query = &#123; <span class="attr">next</span>: <span class="string">'/login'</span> &#125;;</div></pre></td></tr></table></figure>
<h3><span id="req-fresh">req.fresh</span></h3><p>检查客户端请求的缓存是否是最新。当缓存为最新时，可编写业务逻辑直接返回 <code>304</code>，范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'ETag'</span>, <span class="string">'123'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存是最新时</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fresh) &#123;</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">304</span>;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存已过期时，返回最新的数据</span></div><div class="line"><span class="keyword">this</span>.body = <span class="keyword">yield</span> db.find(<span class="string">'something'</span>);</div></pre></td></tr></table></figure>
<h3><span id="req-stale">req.stale</span></h3><p>与 req.fresh 返回的结果正好相反</p>
<h3><span id="req-protocol">req.protocol</span></h3><p>返回请求协议名，如 <code>&quot;https&quot;</code> 或者 <code>&quot;http&quot;</code>；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Proto</code>。</p>
<h3><span id="req-secure">req.secure</span></h3><p>判断请求协议是否为 HTTPS 的快捷方法，等同于 <code>this.protocol == &quot;https&quot;</code></p>
<h3><span id="req-ip">req.ip</span></h3><p>返回请求IP；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-For</code>。</p>
<h3><span id="req-ips">req.ips</span></h3><p>返回请求IP列表，仅当 <code>app.proxy</code> 设置为 <code>true</code> ，并存在 <code>X-Forwarded-For</code> 列表时，否则返回空数组。</p>
<h3><span id="req-subdomains">req.subdomains</span></h3><p>返回请求对象中的子域名数组。子域名数组会自动由请求域名字符串中的 <code>.</code> 分割开，在没有设置自定义的 <code>app.subdomainOffset</code> 参数时，默认返回根域名之前的所有子域名数组。</p>
<p>例如，当请求域名为 <code>&quot;tobi.ferrets.example.com&quot;</code> 时候，返回 <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>，数组顺序是子代域名在前，孙代域名在后。</p>
<p>此例中，如果设置了自定义的 <code>app.subdomainOffset</code> 为 <code>3</code>，将忽略三级域名，返回 <code>[&quot;tobi&quot;]</code>。</p>
<h3><span id="req-is-type">req.is(type)</span></h3><p>判断请求对象中 <code>Content-Type</code> 是否为给定 type 的快捷方法，如果不存在 <code>request.body</code>，将返回 <code>undefined</code>，如果没有符合的类型，返回 <code>false</code>，除此之外，返回匹配的类型字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端 Content-Type: text/html; charset=utf-8</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; 'html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/*'</span>, <span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"></div><div class="line"><span class="comment">// 客户端 Content-Type 为 application/json 时：</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'json'</span>, <span class="string">'urlencoded'</span>); <span class="comment">// =&gt; 'json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'application/json'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>, <span class="string">'application/*'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure>
<p>又如，下方的代码使用 <code>req.is(type)</code>，仅当请求类型为图片时才进行操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.is(<span class="string">'image/*'</span>)) &#123;</div><div class="line">  <span class="comment">// process</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.throw(<span class="number">415</span>, <span class="string">'images only!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-accepts-type">req.accepts(type)</span></h3><p>判断请求对象中 <code>Accept</code> 是否为给定 type 的快捷方法，当匹配到符合的类型时，返回最匹配的类型，否则返回 <code>false</code>（此时服务器端应当返回 406 “Not Acceptable” ），传入参数可以是字符串或者数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept: text/html</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'text/html'</span>);</div><div class="line"><span class="comment">// =&gt; "text/html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'json'</span>, <span class="string">'text'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'application/json'</span>);</div><div class="line"><span class="comment">// =&gt; "application/json"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'image/png'</span>);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'png'</span>);</div><div class="line"><span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*;q=.5, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts([<span class="string">'html'</span>, <span class="string">'json'</span>]);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>, <span class="string">'json'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div></pre></td></tr></table></figure>
<p>注意，当请求头中不包含 Accept 属性时，给定的第一个 type 将会被返回。</p>
<h3><span id="req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</span></h3><p>判断客户端是否接受给定的编码方式的快捷方法，当有传入参数时，返回最应当返回的一种编码方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings(<span class="string">'gzip'</span>, <span class="string">'deflate'</span>);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.acceptsEncodings([<span class="string">'gzip'</span>, <span class="string">'deflate'</span>]);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div></pre></td></tr></table></figure>
<p>当没有传入参数时，返回客户端的请求数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip, deflate</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings();</div><div class="line"><span class="comment">// =&gt; ["gzip", "deflate"]</span></div></pre></td></tr></table></figure>
<h3><span id="req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<h3><span id="req-acceptslanguages-langs">req.acceptsLanguages(langs)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<hr>
<h2><span id="response">Response</span></h2><p>详细的 Response 对象 API 如下：</p>
<h3><span id="res-header">res.header</span></h3><p>获取返回头</p>
<h3><span id="res-status">res.status</span></h3><p>获取返回状态</p>
<h3><span id="res-status">res.status=</span></h3><p>设置返回状态，可用状态如下：</p>
<ul>
<li>100 “continue”</li>
<li>101 “switching protocols”</li>
<li>102 “processing”</li>
<li>200 “ok”</li>
<li>201 “created”</li>
<li>202 “accepted”</li>
<li>203 “non-authoritative information”</li>
<li>204 “no content”</li>
<li>205 “reset content”</li>
<li>206 “partial content”</li>
<li>207 “multi-status”</li>
<li>300 “multiple choices”</li>
<li>301 “moved permanently”</li>
<li>302 “moved temporarily”</li>
<li>303 “see other”</li>
<li>304 “not modified”</li>
<li>305 “use proxy”</li>
<li>307 “temporary redirect”</li>
<li>400 “bad request”</li>
<li>401 “unauthorized”</li>
<li>402 “payment required”</li>
<li>403 “forbidden”</li>
<li>404 “not found”</li>
<li>405 “method not allowed”</li>
<li>406 “not acceptable”</li>
<li>407 “proxy authentication required”</li>
<li>408 “request time-out”</li>
<li>409 “conflict”</li>
<li>410 “gone”</li>
<li>411 “length required”</li>
<li>412 “precondition failed”</li>
<li>413 “request entity too large”</li>
<li>414 “request-uri too large”</li>
<li>415 “unsupported media type”</li>
<li>416 “requested range not satisfiable”</li>
<li>417 “expectation failed”</li>
<li>418 “i’m a teapot”</li>
<li>422 “unprocessable entity”</li>
<li>423 “locked”</li>
<li>424 “failed dependency”</li>
<li>425 “unordered collection”</li>
<li>426 “upgrade required”</li>
<li>428 “precondition required”</li>
<li>429 “too many requests”</li>
<li>431 “request header fields too large”</li>
<li>500 “internal server error”</li>
<li>501 “not implemented”</li>
<li>502 “bad gateway”</li>
<li>503 “service unavailable”</li>
<li>504 “gateway time-out”</li>
<li>505 “http version not supported”</li>
<li>506 “variant also negotiates”</li>
<li>507 “insufficient storage”</li>
<li>509 “bandwidth limit exceeded”</li>
<li>510 “not extended”</li>
<li>511 “network authentication required”</li>
</ul>
<h3><span id="res-length">res.length=</span></h3><p>设置返回头的 <code>Content-Length</code> 属性</p>
<h3><span id="res-length">res.length</span></h3><p>返回返回头的 <code>Content-Length</code> 属性，当不存在 <code>Content-Length</code> 属性时，根据 <code>res.body</code> 推断</p>
<h3><span id="res-body">res.body</span></h3><p>获取 res.body，当 res.body 为 null ，但返回状态仍为 200 时，koa 将会返回 404 页面。</p>
<h3><span id="res-body">res.body=</span></h3><p>设置请求返回的主要内容，可以是以下几种类型：</p>
<ul>
<li><p>string</p>
<p>Content-Type 将默认设置为 text/html 或者 text/plain，默认字符集是 utf-8，Content-Length 也将一并设置</p>
</li>
<li><p>Buffer</p>
<p>Content-Type 将默认设置为 application/octet-stream，Content-Length 也将一并设置</p>
</li>
<li><p>Stream</p>
<p>Content-Type 将默认设置为 application/octet-stream</p>
</li>
<li><p>Object</p>
<p>Content-Type 将默认设置为 application/json<br>注意：默认的json返回会添加空格，如果你希望压缩json返回中的空格，可以这样配置：<code>app.jsonSpaces = 0</code></p>
</li>
<li><p>null</p>
</li>
</ul>
<h3><span id="res-get-field">res.get(field)</span></h3><p>获取指定的返回头属性，属性名称区分大小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etag = <span class="keyword">this</span>.get(<span class="string">'ETag'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-field-value">res.set(field, value)</span></h3><p>使用给定的参数设置一个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-fields">res.set(fields)</span></h3><p>使用给定的对象一次设置多个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(&#123;</div><div class="line">  <span class="string">'Etag'</span>: <span class="string">'1234'</span>,</div><div class="line">  <span class="string">'Last-Modified'</span>: date</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3><span id="res-remove-fields">res.remove(fields)</span></h3><p>删除指定的返回头属性</p>
<h3><span id="res-type">res.type</span></h3><p>获取返回头中的 Content-Type，不包括 <code>&quot;charset&quot;</code> 等属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="res-type">res.type=</span></h3><p>使用字符串或者文件后缀设定返回的 Content-Type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.type = <span class="string">'text/plain; charset=utf-8'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'image/png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'.png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'png'</span>;</div></pre></td></tr></table></figure>
<p>注意：当使用文件后缀指定时，koa 会默认设置好最匹配的编码字符集，比如当设定 <code>res.type = &#39;html&#39;</code> 时，koa 会默认使用 <code>&quot;utf-8&quot;</code> 字符集。但当明确使用 <code>res.type = &#39;text/html&#39;</code> 指定时，koa 不会自动设定字符集。</p>
<h3><span id="res-redirect-url-alt">res.redirect(url, [alt])</span></h3><p>返回一个 <code>302</code> 跳转到给定的 url，您也可以使用关键词 <code>back</code> 来跳转到该 url 的上一个页面（refer），当没有上一个页面时，默认会跳转到 ‘/‘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>, <span class="string">'/index.html'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/login'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'http://google.com'</span>);</div></pre></td></tr></table></figure>
<p>如果你需要覆盖 <code>302</code> 状态码，并在跳转时返回一些文案，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.status = <span class="number">301</span>;</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/cart'</span>);</div><div class="line"><span class="keyword">this</span>.body = <span class="string">'Redirecting to shopping cart'</span>;</div></pre></td></tr></table></figure>
<h3><span id="res-attachment-filename">res.attachment([filename])</span></h3><p>设置返回熟悉 Content-Disposition 为 <code>&quot;attachment&quot;</code>，并告知客户端进行下载。</p>
<h3><span id="res-headersent">res.headerSent</span></h3><p>判断一个响应头是否已经发送到客户端，通常用来检测客户端是否收到了错误信息。</p>
<h3><span id="res-lastmodified">res.lastModified</span></h3><p>如果返回头中存在 Last-Modified 属性，则返回它。</p>
<h4><span id="res-lastmodified">res.lastModified=</span></h4><p>设置返回头中的 Last-Modified 属性，可以使用时间对象或者时间字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.lastModified = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure>
<h3><span id="res-etag">res.etag=</span></h3><p>设置返回头的 Etag 字段。koa 不提供关于 Etag 的获取方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.etag = crypto.createHash(<span class="string">'md5'</span>).update(<span class="keyword">this</span>.body).digest(<span class="string">'hex'</span>);</div></pre></td></tr></table></figure>
<hr>
<h2><span id="xing-neng-benchmarks">性能（Benchmarks）</span></h2><p>挂载不同数量的中间件，wrk 得出 benchmarks 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">1 middleware</div><div class="line">8367.03</div><div class="line"></div><div class="line">5 middleware</div><div class="line">8074.10</div><div class="line"></div><div class="line">10 middleware</div><div class="line">7526.55</div><div class="line"></div><div class="line">15 middleware</div><div class="line">7399.92</div><div class="line"></div><div class="line">20 middleware</div><div class="line">7055.33</div><div class="line"></div><div class="line">30 middleware</div><div class="line">6460.17</div><div class="line"></div><div class="line">50 middleware</div><div class="line">5671.98</div><div class="line"></div><div class="line">100 middleware</div><div class="line">4349.37</div></pre></td></tr></table></figure>
<p>一般来说，我们通常要使用约50个中间件，按这个标准计算，单应用可支持 340,260 请求/分钟，即 20,415,600 请求/小时，也就是约 4.4 亿 请求/天。</p>
<hr>
<h2><span id="xue-xi-zi-liao">学习资料</span></h2><p>发现更多第三方的 koa 中间件，或者一起来参与社区的讨论和建设吧：</p>
<ul>
<li><a href="https://github.com/koajs/koa" target="_blank" rel="external">GitHub repository</a></li>
<li><a href="https://github.com/koajs/examples" target="_blank" rel="external">Examples</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Middleware</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Wiki</a></li>
<li><a href="https://plus.google.com/communities/101845768320796750641" target="_blank" rel="external">G+ Community</a></li>
<li><a href="https://groups.google.com/forum/#!forum/koajs" target="_blank" rel="external">Mailing list</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md" target="_blank" rel="external">Guide</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md" target="_blank" rel="external">FAQ</a></li>
</ul>
<hr>
<h2><span id="contributing">Contributing</span></h2><ul>
<li>Fork this repo</li>
<li>Clone your repo</li>
<li>Install dependencies</li>
<li>Checkout a feature branch</li>
<li>Feel free to add your features</li>
<li>Make sure your features are fully tested</li>
<li>Open a pull request, and enjoy &lt;3</li>
</ul>
<h2><span id="mit-license">MIT license</span></h2><p>Copyright (c) 2013 turing &lt;o.u.turing@gmail.com&gt;</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br>THE SOFTWARE.</p>
<hr>
<p><img src="https://cdn1.iconfinder.com/data/icons/windows8_icons_iconpharm/26/doctor.png" alt="docor"></p>
<p>Generated using <a href="https://github.com/guo-yu/docor.git" target="_blank" rel="external">docor</a> @ 0.1.0. brought to you by <a href="https://github.com/guo-yu" target="_blank" rel="external">Guo Yu</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份&lt;br&gt;
    
    </summary>
    
      <category term="node.js" scheme="https://www.kanshouce.com/categories/node-js/"/>
    
    
      <category term="guide" scheme="https://www.kanshouce.com/tags/guide/"/>
    
      <category term="Koa" scheme="https://www.kanshouce.com/tags/Koa/"/>
    
  </entry>
  
  <entry>
    <title>招行办理深圳工商局U盾签名爬坑</title>
    <link href="https://www.kanshouce.com/2017/08/08/Adobe-acrobat-U/"/>
    <id>https://www.kanshouce.com/2017/08/08/Adobe-acrobat-U/</id>
    <published>2017-08-08T15:08:48.000Z</published>
    <updated>2017-08-11T16:47:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>深圳工商应该是全国率先实现了U盾电子签名办事，这是无数代办公司的噩梦，但是软件问题坑苦了用户。本文记载在多次办理后的所需经验。</p>
<a id="more"></a>
<h1><span id="adobe-acrobat-dc-an-zhuang-wen-ti">Adobe Acrobat DC 安装问题</span></h1><p>首先，你必须有个windows环境，这点毫无疑问。</p>
<p>请注意，需要安装<code>最新版本</code>的的Acrobat，本次我安装的是<code>AcroRdrDC1701220093_zh_CN</code>，如果不是最新版本的，在签名部分可能需要安装Adobe的一个补丁，而国外的网络很慢，所以最好下载一个最新版本。</p>
<p>最常见的错误是由于很多人会把桌面更换了存放盘，导致在安装过程中提示</p>
<div class="tip"><br>ERROR!<br>无法访问网络位置 c:/users/76798/Desktop<br></div>

<p>这时候最好的解决办法是在计算机<code>开始</code>菜单，点击右键，选择<code>运行</code>，输入<code>regedit</code>进入注册表。</p>
<p>问题的关键在于<code>/</code>和<code>\</code>的符号错误，搜索<code>c:/users/76798/Desktop</code>找到这个键值。改为<code>c:\users\76798\Desktop</code>即可</p>
<h1><span id="adobe-acrobat-dc-shan-tui">Adobe Acrobat DC 闪退</span></h1><p>Adobe Acrobat DC的闪退用两个方案可以快速解决</p>
<p>（1）前往Adobe的安装目录，找到<code>Eula.exe</code>文件（这是最早安装弹出的许可协议，很多人点了拒绝），在这里点击<code>Accept</code>接受；</p>
<div class="tip"><br>ERROR!<br>无法创建该签名。Error at File:DSHandler.cpp,line:<em>LINE</em><br></div>

<p>（2）因为提前安装了招行的插件引起，这时候找到安装目录，通常可能是<code>C:\Program Files\Adobe\Reader 11.0\Reader\plug_ins</code>或者<code>C:\Program Files\Adobe\Acrobat Reader DC\Reader\plug_ins</code>，在里面找到<code>CMBPDFSign.api</code>招行的签名文件。</p>
<p>将文件用<code>Ctrl</code>+<code>x</code>剪切到桌面，然后再打开AcrobatDC，操作一会儿，如果没闪退，可以把该文件复制回刚刚的目录，闪退的问题解决了。</p>
<h1><span id="zhao-xing-u-dun-qian-ming-qu-dong-xia-zai">招行U盾签名驱动下载</span></h1><p>推荐前往深圳工商局网站链接，根据自己U盾的情况进行下载：</p>
<p><a href="http://app03.szaic.gov.cn/psout/jsp/gcloud/pubservice/network/downPageSimple.jsp" target="_blank" rel="external">戳我直达深圳工商局网站下载帮助页</a></p>
<p>或</p>
<p><a href="http://www.shenzhen.cmbchina.com/EasyRegister/" target="_blank" rel="external">戳我直达招行下载页</a></p>
<h1><span id="qian-ming-shi-de-cuo-wu-ti-shi">签名时的错误提示</span></h1><p>进入Adobe菜单 - <code>编辑</code> - <code>首选项</code> - <code>签名</code> - <code>创建和外观</code> - <code>默认签名方法</code>，选择<code>CMB_PDF_SIGN</code>，确定后，回到上页，点击<code>验证</code>,检查其中的始终是用默认方法部分是不是<code>用Adobe默认安全性</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深圳工商应该是全国率先实现了U盾电子签名办事，这是无数代办公司的噩梦，但是软件问题坑苦了用户。本文记载在多次办理后的所需经验。&lt;/p&gt;
    
    </summary>
    
      <category term="Skill" scheme="https://www.kanshouce.com/categories/Skill/"/>
    
    
      <category term="AcrobatDC" scheme="https://www.kanshouce.com/tags/AcrobatDC/"/>
    
      <category term="signature" scheme="https://www.kanshouce.com/tags/signature/"/>
    
  </entry>
  
  <entry>
    <title>免费的HTTPS证书Let&#39;s Encrypt</title>
    <link href="https://www.kanshouce.com/2017/08/08/Https-encrypt/"/>
    <id>https://www.kanshouce.com/2017/08/08/Https-encrypt/</id>
    <published>2017-08-08T10:59:21.000Z</published>
    <updated>2017-08-08T13:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>是由ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。</p>
<a id="more"></a>
<p>申请 Let’s Encrypt 证书不但免费，还非常简单，虽然每次只有 <code>90</code>天的有效期，但可以<strong>通过脚本定期更新</strong>，配好之后一劳永逸。</p>
<p>在Let’s Encrypt 官网有提供工具来申请证书，本教程使用 <a href="https://github.com/diafygi/acme-tiny" target="_blank" rel="external">acme-tiny</a> 这个更为小巧的开源工具。以下内容基本按照 acme-tiny 的说明文档写的，省略了一些不需要的步骤。</p>
<p>ACME 全称是 Automated Certificate Management Environment，直译过来是自动化证书管理环境的意思，Let’s Encrypt 的证书签发过程使用的就是 ACME 协议。有关 ACME 协议的更多资料可以在<a href="https://github.com/ietf-wg-acme/acme/" target="_blank" rel="external">这个仓库</a>找到。</p>
<h1><span id="create-account">Create Account</span></h1><p>首先创建一个目录，例如 SSL，如果是Nginx，使用了yum安装，最方便的方式是存在<code>/etc/nginx/cert</code>，这样在配置conf的时候可以直接用<code>cert/xxxx.pub</code>这样的写法。新建立的SSL目录用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个 RSA 私钥用于 Let’s Encrypt 识别你的身份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; account.key</div></pre></td></tr></table></figure>
<h1><span id="create-csr-file">Create CSR file</span></h1><p>接着就可以生成 CSR（Certificate Signing Request，证书签名请求）文件了。在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥），根据证书不同类型，域名私钥也可以选择 RSA 和 ECC 两种不同类型。以下两种方式请根据实际情况二选一。</p>
<p>(1)创建RSA私钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl genrsa 4096 &gt; domain.key</div></pre></td></tr></table></figure>
<p>(2)创建 ECC 私钥（部分老旧操作系统、浏览器不支持。优点是证书体积小）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#secp256r1</span></div><div class="line">$ openssl ecparam -genkey -name secp256r1 | openssl ec -out domain.key</div><div class="line"></div><div class="line"><span class="comment">#secp384r1</span></div><div class="line">$ openssl ecparam -genkey -name secp384r1 | openssl ec -out domain.key</div></pre></td></tr></table></figure>
<p>有关 ECC 证书的更多介绍，请<a href="https://imququ.com/post/optimize-tls-handshake.html#toc-2-1" target="_blank" rel="external">点击这里</a>。<br>有了私钥文件，就可以生成 CSR 文件了。在 CSR 中推荐至少把域名带 www 和不带 www 的两种情况都加进去，其它子域可以根据需要添加（目前一张证书最多可以包含 100 个域名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -new -sha256 -key domain.key -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com"</span>)) &gt; domain.csr</div></pre></td></tr></table></figure>
<p>执行这一步时，如果提示找不到 <code>/etc/ssl/openssl.cnf</code> 文件，请看看 <code>/usr/local/openssl/ssl/openssl.cnf</code> 是否存在，之前可以按照本站所提到的文章升级Openssl 1.1.0f。如果还是不行，也可以使用交互方式创建 CSR（需要注意 Common Name 必须为你的域名）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl req -new -sha256 -key domain.key -out domain.csr</div></pre></td></tr></table></figure>
<h1><span id="auth-config">Auth Config</span></h1><p>我们知道，CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 <code>admin@yoursite.com</code> 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。<br>首先创建用于存放验证文件的目录，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/www/challenges/</div></pre></td></tr></table></figure>
<p>然后配置一个 HTTP 服务，以 Nginx 为例</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;</div><div class="line">    <span class="attribute">server_name</span> www.yoursite.com yoursite.com;</div><div class="line"></div><div class="line">    <span class="attribute">location</span><span class="regexp"> ^~</span> /.well-known/acme-challenge/ &#123;</div><div class="line">        <span class="attribute">alias</span> /home/xxx/www/challenges/;</div><div class="line">        <span class="attribute">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="attribute">location</span> / &#123;</div><div class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://yoursite.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上配置优先查找 <code>~/www/challenges/</code> 目录下的文件，如果找不到就重定向到 HTTPS 地址。这个验证服务以后更新证书还要用到，建议一直保留。</p>
<h1><span id="get-website-ssl">Get website ssl</span></h1><p>先把 acme-tiny 脚本保存到之前的 <code>ssl</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</div></pre></td></tr></table></figure>
<p>指定账户私钥、CSR 以及验证目录，执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir ~/www/challenges/ &gt; ./signed.crt</div></pre></td></tr></table></figure>
<p>如果一切正常，当前目录下就会生成一个 <code>signed.crt</code>，这就是申请好的证书文件。</p>
<p>如果你把域名 DNS 解析放在国内，这一步很可能会遇到类似这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ValueError: Wrote file to /home/xxx/www/challenges/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg, but couldn&apos;t download http://www.yoursite.com/.well-known/acme-challenge/oJbvpIhkwkBGBAQUklWJXyC8VbWAdQqlgpwUJkgC1Vg</div></pre></td></tr></table></figure>
<p>这是因为你的域名很可能在国外无法解析，可以暂时使用国外的 DNS 解析服务商，例如 <a href="https://dns.he.net/" target="_blank" rel="external">dns.he.net</a>。如果还是搞不定，也可以试试<a href="https://github.com/Neilpang/le" target="_blank" rel="external">「Neilpang/le」</a>这个工具的 DNS Mode。<br>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。我在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起：</p>
<p>搞定网站证书后，还要下载 Let’s Encrypt 的中间证书。在之前的文章中讲过，配置 HTTPS 证书时既不要漏掉中间证书，也不要包含根证书。在 Nginx 配置中，需要把中间证书和网站证书合在一起:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">$ cat signed.crt intermediate.pem &gt; chained.pem</div></pre></td></tr></table></figure>
<p>为了后续能顺利启用 <a href="https://imququ.com/post/why-can-not-turn-on-ocsp-stapling.html#toc-2" target="_blank" rel="external">OCSP Stapling</a>，我们再把根证书和中间证书合在一起：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &gt; root.pem</div><div class="line">$ cat intermediate.pem root.pem &gt; full_chained.pem</div></pre></td></tr></table></figure>
<p>最终，修改 Nginx 中有关证书的配置并 reload 服务即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ssl_certificate</span>     ~/www/ssl/chained.pem;</div><div class="line"><span class="attribute">ssl_certificate_key</span> ~/www/ssl/domain.key;</div></pre></td></tr></table></figure>
<h1><span id="config-auto-upgrade">Config Auto upgrade</span></h1><p>Let’s Encrypt 签发的证书只有 90 天有效期，推荐使用脚本定期更新。例如可以创建了一个 <code>renew_cert.sh</code> 并通过 <code>chmod a+x renew_cert.sh</code> 赋予执行权限。文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /home/xxx/www/ssl/</div><div class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/xxx/www/challenges/ &gt; signed.crt || <span class="built_in">exit</span></div><div class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">cat signed.crt intermediate.pem &gt; chained.pem</div><div class="line">service nginx reload</div></pre></td></tr></table></figure>
<p>crontab 中使用绝对路径比较保险，<code>crontab -e</code> 加入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 0 1 * * /home/xxx/shell/renew_cert.sh &gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>
<p>这样以后证书每个月都会自动更新，一劳永逸。实际上，Let’s Encrypt 官方将证书有效期定为 90 天一方面是为了更安全，更重要的是鼓励用户采用自动化部署方案。</p>
<p>Let’s Encrypt 官方的新特性预告可以在<a href="https://letsencrypt.org/upcoming-features/" target="_blank" rel="external">这个页面</a>查看。</p>
<p>我个人建议：对于个人用户来说，如果非常在意证书兼容性，可以购买 RapidSSL Standard 或者 Comodo Positive SSL 这两种证书。其中 RapidSSL 证书一共才三级，比较小；Comodo Positive 有四级，但可以申请 ECC 证书；二者都有着不错的兼容性，也非常廉价（一年不到 10$）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Let’s Encrypt&lt;/a&gt;是由ISRG（Internet Security Research Group，互联网安全研究小组）提供服务，而 ISRG 是来自于美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛。&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
      <category term="WEB" scheme="https://www.kanshouce.com/categories/Server/WEB/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="https" scheme="https://www.kanshouce.com/tags/https/"/>
    
      <category term="web" scheme="https://www.kanshouce.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>这是目前最好用的，替换某字体的方法了</title>
    <link href="https://www.kanshouce.com/2017/08/08/fonts-replace/"/>
    <id>https://www.kanshouce.com/2017/08/08/fonts-replace/</id>
    <published>2017-08-08T09:19:38.000Z</published>
    <updated>2017-08-08T09:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于给朋友装了一些Wordpress，模版上使用的字体因为某些原因无法访问，这是大家共知的情况。</p>
<p>原360（libs.useso.com）和其他一些地方提供的字体代理因为各种原因不合适，比如不支持https等。</p>
<a id="more"></a>
<p>科大从2014年既提供了替代方案</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ajax.googleapis.com =&gt; ajax.lug.ustc.edu.cn</div><div class="line">fonts.googleapis.com =&gt; fonts.lug.ustc.edu.cn</div><div class="line">themes.googleusercontent.com =&gt; google-themes.lug.ustc.edu.cn</div></pre></td></tr></table></figure>
<p>这种方案支持单独站点某些字体的替换。</p>
<p>但是如果Wordpress每次升级会覆盖原来的<code>js</code>或<code>css</code>文件，如果服务器采用Nginx部署的，可以采用将<code>MIME type</code>强制替换方案。</p>
<p>Nginx配置文件参考，需要注意的是，不支持Gzip。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># disable gzip response, otherwise subs_filter cannot parse it</span></div><div class="line">proxy_set_header Accept-Encoding <span class="string">""</span>;</div><div class="line"></div><div class="line"><span class="comment">#subs_filter_types text/html text/css text/xml text/javascript;</span></div><div class="line">subs_filter_types text/css text/xml text/javascript;</div><div class="line">subs_filter //fonts.googleapis.com/ //fonts.lug.ustc.edu.cn/;</div><div class="line">subs_filter //ajax.googleapis.com/ //ajax.lug.ustc.edu.cn/;</div><div class="line">subs_filter //themes.googleusercontent.com/ //google-themes.lug.ustc.edu.cn/;</div><div class="line">subs_filter //fonts.gstatic.com/ //fonts-gstatic.lug.ustc.edu.cn/;</div><div class="line"></div><div class="line">proxy_connect_timeout 3s;</div><div class="line">error_page 500 502 504 @redirect;</div></pre></td></tr></table></figure>
<p><a href="https://gist.github.com/gaoyifan/680da074330d2c499d6b" target="_blank" rel="external">科大的配置文件完整版</a></p>
<p>另外，科大博客维护人员在Github上一个<a href="https://github.com/gaoyifan/china-operator-ip" target="_blank" rel="external">非常不错的项目</a>应该是目前最好的IP库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于给朋友装了一些Wordpress，模版上使用的字体因为某些原因无法访问，这是大家共知的情况。&lt;/p&gt;
&lt;p&gt;原360（libs.useso.com）和其他一些地方提供的字体代理因为各种原因不合适，比如不支持https等。&lt;/p&gt;
    
    </summary>
    
      <category term="WEB" scheme="https://www.kanshouce.com/categories/WEB/"/>
    
    
      <category term="web" scheme="https://www.kanshouce.com/tags/web/"/>
    
      <category term="google fonts" scheme="https://www.kanshouce.com/tags/google-fonts/"/>
    
      <category term="wordpress" scheme="https://www.kanshouce.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>国际空间站（ISS）传输SSTV庆祝业余无线电20周年</title>
    <link href="https://www.kanshouce.com/2017/08/06/iss-with-rtl-sdr/"/>
    <id>https://www.kanshouce.com/2017/08/06/iss-with-rtl-sdr/</id>
    <published>2017-08-06T09:45:22.000Z</published>
    <updated>2017-08-08T13:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年7月20日至24日，ISS（国际空间站）正在传播SSTV（慢扫描电视）图像，以庆祝ARISS（ISS的业余无线电）20周年。</p>
<p>ISS每年在庆祝的场合传播SSTV图像很多次。有关即将到来的ARISS活动的更多信息，可以访问他们的网站 <a href="ariss.org">ariss.org</a>。</p>
<p>在YouTube上有个歪果仁Tysonpower使用RTL-SDR，FM陷阱滤波器和V-Dipole天线，收集了ISS SSTV图像的视频和写作数据。<br><img src="https://pic.kanshouce.com/blog/2017-08-06-15039.gif" alt=""></p>
<p>如果希望看完整个过程，可以直接访问这个人的<a href="https://tysonpower.de/blog/sstv-from-the-iss-ariss-20th-anniversary-july-2017" target="_blank" rel="external">博客</a>，有详细的记载。</p>
<a id="more"></a>
<p>请注意，Tysonpower的YouTube视频是以德文叙述的，但如果您打开YouTube的隐藏式字幕，则默认情况下可以使用英文字幕，并打开谷歌的中文翻译功能。</p>
<p>在2015年，国际空间站（ISS）向当时正在过80岁生日的俄罗斯宇航员尤里加加林发送了SSTV图像。</p>
<p>欧洲的军装怎么说，还真是很耐看。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-ISS_SSTV_Yuri.jpg" alt=""></p>
<p>满满的IBM笔记本有没有，挂在墙上固定的各式工具看起来属于极为实用的风格（毕竟物体带上空间站的成本高昂的吓人）<br><img src="https://pic.kanshouce.com/blog/2017-08-06-issttt.jpg" alt="ISS上用于传输SSTV图像的计算机"></p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-iss_arissant22.jpg" alt="传输SSTV天线"></p>
<p>要解码图像，建议使用SDR＃并将音频管道传输到<a href="http://hamsoft.ca/pages/mmsstv.php" target="_blank" rel="external">MMSSTV</a>，一个免费的SSTV解码软件程序。为了从MMSSTV中获得最佳效果，建议在选项 - &gt;设置MMSTV-&gt; RX下启用“自动倾斜”和“自动重新同步”。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-MMSTV_settings.jpg" alt=""></p>
<p>国际空间站的部分追踪信息可以在这里在线跟踪它：</p>
<ul>
<li><a href="http://spotthestation.nasa.gov/sightings/" target="_blank" rel="external">http://spotthestation.nasa.gov/sightings/</a> </li>
<li><a href="http://www.isstracker.com/" target="_blank" rel="external">http://www.isstracker.com/</a></li>
<li><a href="http://www.mcc.rsa.ru/English/trassa.htm" target="_blank" rel="external">http://www.mcc.rsa.ru/English/trassa.htm</a></li>
</ul>
<p>另外，对懒癌晚期来说，这里有个非常有趣的图册集合，集合了大多数爱好者接收到的SSTV。</p>
<p><a href="http://spaceflightsoftware.com/ARISS_SSTV/index.php" target="_blank" rel="external">戳我抵达</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年7月20日至24日，ISS（国际空间站）正在传播SSTV（慢扫描电视）图像，以庆祝ARISS（ISS的业余无线电）20周年。&lt;/p&gt;
&lt;p&gt;ISS每年在庆祝的场合传播SSTV图像很多次。有关即将到来的ARISS活动的更多信息，可以访问他们的网站 &lt;a href=&quot;ariss.org&quot;&gt;ariss.org&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在YouTube上有个歪果仁Tysonpower使用RTL-SDR，FM陷阱滤波器和V-Dipole天线，收集了ISS SSTV图像的视频和写作数据。&lt;br&gt;&lt;img src=&quot;https://pic.kanshouce.com/blog/2017-08-06-15039.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果希望看完整个过程，可以直接访问这个人的&lt;a href=&quot;https://tysonpower.de/blog/sstv-from-the-iss-ariss-20th-anniversary-july-2017&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;，有详细的记载。&lt;/p&gt;
    
    </summary>
    
      <category term="SDR" scheme="https://www.kanshouce.com/categories/SDR/"/>
    
    
      <category term="RTL-SDR" scheme="https://www.kanshouce.com/tags/RTL-SDR/"/>
    
      <category term="ISS" scheme="https://www.kanshouce.com/tags/ISS/"/>
    
      <category term="SSTV" scheme="https://www.kanshouce.com/tags/SSTV/"/>
    
  </entry>
  
  <entry>
    <title>用RTL-SDR进行IMSI的捕获</title>
    <link href="https://www.kanshouce.com/2017/08/06/simple-imsi-catcher/"/>
    <id>https://www.kanshouce.com/2017/08/06/simple-imsi-catcher/</id>
    <published>2017-08-06T09:27:10.000Z</published>
    <updated>2017-08-08T13:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>事实上在HarckRF上捕获IMSI是非常容易的，在安卓系统上也有成堆的IMSI捕捉器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AIMSICD • Fight IMSI-Catcher, StingRay and silent SMS!</div><div class="line">https://github.com/CellularPrivacy/Android-IMSI-Catcher-Detector.git</div><div class="line">https://cellularprivacy.github.io/Android-IMSI-Catcher-Detector/</div><div class="line">https://opensource.srlabs.de/projects/mobile-network-assessment-tools/wiki/CatcherCatcher</div><div class="line"></div><div class="line">Netmonitor - Monitor GSM/CDMA/LTE network: current and neighboring cell infos, signal strength.</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>早些时候，在Youtube上有个用户上传了用RTL-SDR配合一段python的脚本捕捉IMSI的<a href="https://www.youtube.com/channel/UC4cMTOPJf_ixWyGW1u48yrw" target="_blank" rel="external">视频</a></p>
<p>视频中展示了他如何使用gr-gsm和Python脚本使用RTL-SDR来创建一个简单的IMSI捕获器。</p>
<p>IMSI代表国际移动用户身份，并且是识别GSM（2G）移动电话系统中的手机SIM卡的唯一号码。为了安全起见，IMSI号码通常仅在连接到新的基站时被传送。</p>
<p>很多国家的政府机构使用的更先进的IMSI捕获器使用基站信号强制IMSI一致被报道。这样他们可以跟踪手机的位置以及其他数据，比如谁打电话或什么时候打电话。</p>
<p>在视频中，Keld使用了一个名为<a href="https://github.com/Oros42/IMSI-catcher" target="_blank" rel="external">IMSI-Catcher</a>的Python脚本。此脚本在文本显示屏上显示检测到的IMSI号码，国家/地区和移动运营商。视频说明显示如何在Ubuntu上安装GR-GSM和IMSI-Catcher脚本。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-08-06-093512.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事实上在HarckRF上捕获IMSI是非常容易的，在安卓系统上也有成堆的IMSI捕捉器。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;AIMSICD • Fight IMSI-Catcher, StingRay and silent SMS!&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://github.com/CellularPrivacy/Android-IMSI-Catcher-Detector.git&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://cellularprivacy.github.io/Android-IMSI-Catcher-Detector/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;https://opensource.srlabs.de/projects/mobile-network-assessment-tools/wiki/CatcherCatcher&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Netmonitor - Monitor GSM/CDMA/LTE network: current and neighboring cell infos, signal strength.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SDR" scheme="https://www.kanshouce.com/categories/SDR/"/>
    
    
      <category term="RTL" scheme="https://www.kanshouce.com/tags/RTL/"/>
    
      <category term="IMSI" scheme="https://www.kanshouce.com/tags/IMSI/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7升级Openssl并支持HTTP2</title>
    <link href="https://www.kanshouce.com/2017/08/05/openssl-upgrade/"/>
    <id>https://www.kanshouce.com/2017/08/05/openssl-upgrade/</id>
    <published>2017-08-05T08:58:45.000Z</published>
    <updated>2017-08-08T13:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 7 默认带的openssl是1.0.1版本，开启HTTP2则必须升级1.1左右的版本。</p>
<p>本文仅适用CentOS7</p>
<p>以下为升级全过程</p>
<a id="more"></a>
<h1><span id="sheng-ji-openssl">升级OpenSSL</span></h1><p>查看当前openssl版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ openssl version</div></pre></td></tr></table></figure>
<p>查看输出版本</p>
<p>前往Openssl官方<a href="https://www.openssl.org/source/" target="_blank" rel="external">（戳我）</a>查看最新的openssl版本，make本文的时候最新版本为1.1.0f</p>
<p>下载并解压</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /home</div><div class="line">$ wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.1.0f.tar.gz</div><div class="line">$ tar -zxvf openssl-1.1.0f.tar.gz</div><div class="line">$ <span class="built_in">cd</span> openssl-1.1.0f</div></pre></td></tr></table></figure>
<p>动态编译Openssl，并安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./config zlib-dynamic</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<p>这里要注意，如果编译的时候增加了 <code>zlib-dynamic</code> 这个参数代表了动态编译，编译完成后，只需要执行下文中<code>#添加libssl.so.1.1</code>等两个步骤，因为openssl的执行目录和文件都已经就绪。</p>
<p>如果用默认的安装，那么此刻openssl默认被安装到了<code>/usr/local/</code>目录。</p>
<p>查看目前运行的Openssl目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">which</span> openssl</div></pre></td></tr></table></figure>
<p>开始升级（如果动态编译，可以从<code>#添加libssl.so.1.1</code>开始）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#把旧版本的openssl备份一下，下面的目录即是上面用which查出来的目录，每个人的服务器配置不一样，请依照情况执行。</span></div><div class="line">$ mv /usr/bin/openssl /usr/bin/openssl.bak</div><div class="line">$ mv /usr/include/openssl /usr/include/openssl.bak</div><div class="line"></div><div class="line"><span class="comment">#拷贝刚编译好的新版本的openssl-1.1.0f</span></div><div class="line">$ cp /usr/<span class="built_in">local</span>/bin/openssl /usr/bin/openssl</div><div class="line">$ cp -r /usr/<span class="built_in">local</span>/ssl /usr/include/openssl</div><div class="line"><span class="comment">#注意，1.1.0f版本 生成的文件的位置在/usr/local/ssl</span></div><div class="line"><span class="comment">#这里没有用ln软链的原因是因为如果使用ln可能在后续安装中造成其他软件的安装错误,比较常见的就是报[install_dev]错误</span></div><div class="line"></div><div class="line"><span class="comment">#添加libssl.so.1.1</span></div><div class="line">$ cp /usr/<span class="built_in">local</span>/lib64/libssl.so.1.1 /usr/lib64/libssl.so.1.1</div><div class="line">$ cp /usr/<span class="built_in">local</span>/lib64/libcrypto.so.1.1 /usr/lib64/libcrypto.so.1.1</div><div class="line"></div><div class="line"><span class="comment">#查看openssl版本</span></div><div class="line">$ openssl version</div><div class="line"></div><div class="line"><span class="comment">#重新加载动态链接库，这步比较重要，特别是下一步要升级nginx</span></div><div class="line">$ ldconfig -v</div></pre></td></tr></table></figure>
<p>至此，openssl已经成功升级。</p>
<h1><span id="sheng-ji-nginx-zhi-chi-http2">升级Nginx支持HTTP2</span></h1><h2><span id="sheng-ji">升级</span></h2><p>Nginx的升级相对比较简单</p>
<p>升级前最好<code>检查</code>下是否具备编译Nginx的条件，特别是以前很多采用<code>YUM</code>安装的懒癌晚期，可能没安装编译环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install gcc-c ++ pcre-devel zlib-devel make wget openssl-devel libxml2-devel libxslt-devel gd-devel perl-ExtUtils-Embed GeoIP-devel gperftools-devel</div></pre></td></tr></table></figure>
<p>以上基本把所需的依赖都装好了，如果在下面的编译环境中提示<code>Peal</code>的相关错误，可以考虑安装<code>cpan</code>，用cpan按照提示安装缺少的peal库。</p>
<p>开始升级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#看一下nginx版本与配置</span></div><div class="line">[root@sf3 ~]<span class="comment"># nginx -V</span></div><div class="line">nginx version: nginx/1.10.0   //这里输出的是当前版本</div><div class="line">built by gcc 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC) //编译用的Gcc版本</div><div class="line">built with OpenSSL 1.0.1e-fips 11 Feb 2013  //使用的openssl版本，我们本次升级主要针对的地方</div><div class="line">TLS SNI support enabled  //TLS支持是否打开</div><div class="line">configure arguments: [内容略去]  //编译参数</div></pre></td></tr></table></figure>
<p>最新稳定版本是1.10.2</p>
<p>官网地址：<a href="http://nginx.org" target="_blank" rel="external">http://nginx.org</a></p>
<p>升级步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#下载nginx最新版</span></div><div class="line">$ <span class="built_in">cd</span> /home</div><div class="line"><span class="variable">$wget</span> http://nginx.org/download/nginx-1.10.2.tar.gz</div><div class="line"><span class="comment">#解压源码</span></div><div class="line">$ tar zxvf nginx-1.10.2.tar.gz</div><div class="line"><span class="comment">#进入源码目录</span></div><div class="line">$ <span class="built_in">cd</span> nginx-1.10.2</div><div class="line"></div><div class="line"><span class="comment">#加上所需参数开始编译</span></div><div class="line">$ ./configure [这里copy上文提到的内容略去部分，或者根据你自己的情况进行配置] --with-openssl=/home/openssl-1.1.0f <span class="comment">#请注意，这条最重要，对应openssl源码解压后的路径</span></div><div class="line"></div><div class="line"><span class="comment">#执行make编译，但是不要执行make install</span></div><div class="line"></div><div class="line">$ make</div><div class="line"></div><div class="line"><span class="comment">#重命名nginx旧版本二进制文件，即sbin目录下的nginx（期间nginx并不会停止服务）</span></div><div class="line"><span class="comment">#每个人服务器的安装不太一样，执行前记得用which nginx看一下nginx所在目录</span></div><div class="line">$ mv /usr/sbin/nginx /usr/sbin/nginx.old</div><div class="line"></div><div class="line"><span class="comment">#然后拷贝一份新编译的二进制文件</span></div><div class="line">$ cp objs/nginx /usr/sbin/sbin/</div><div class="line"><span class="comment">#在源码目录执行make upgrade开始升级</span></div><div class="line">$ make upgrade</div><div class="line"></div><div class="line"><span class="comment">#完成后查看下版本</span></div><div class="line">$ nginx -V</div></pre></td></tr></table></figure>
<p>如果遇到错误，请参考本博客<a href="https://www.kanshouce.com/2017/08/01/nginx-php7/">上篇文章</a>，用YUM升级安装nginx到最新版本nginx，再进行编译。</p>
<h2><span id="pei-zhi-bu-fen">配置部分</span></h2><p>在nginx的<code>conf</code>文件里，对对应的站点进行配置，非常简单，只需要增加<code>ssl http2;</code>即可，比如说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listen 443 ssl http2 default_server;</div></pre></td></tr></table></figure>
<p>要验证http2是否生效可以安装个chrome插件<code>HTTP/2 and SPDY indicator</code>，如果开启了h2，那么会有一道蓝色的闪电，比如说，就像本站已经开启了：<br><img src="https://pic.kanshouce.com/blog/2017-08-06-2017-08-06%205.18.06.png" alt=""></p>
<h3><span id="tui-jian-de-pei-zhi">推荐的配置</span></h3><p>这里有个网站推荐给大家，可以生成被优化推荐的Nginx配置文件</p>
<p><a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="external">戳我抵达</a></p>
<h1><span id="yi-xie-ce-shi">一些测试</span></h1><p>除了上面提到的Chrome插件以外，如果服务器的openssl版本过低，可能导致chrom浏览器访问失败，原因是因为在去年google chrom51版本中google移除了NPN，只支持ALPN，所以导致协商失败。</p>
<p>用这条命令可以测试目前HTTP2服务是否支持ALPN</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl s_client -alpn h2 -servername imququ.com -connect kanshouce.com:443 &lt; /dev/null | grep <span class="string">'ALPN'</span></div></pre></td></tr></table></figure>
<p>如果提示 <code>unknown option -alpn</code>，说明本地的 OpenSSL 版本太低（可通过 <code>openssl version</code> 查看），请升级到 1.0.2+。如果不方便升级，也可以使用 <a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="external">Qualys SSL Labs’s SSL Server Test</a> 这个在线工具来测试。</p>
<p>如果结果包含 <code>ALPN protocol: h2</code>，说明服务端支持 ALPN，不受 Chrome 51+ 去掉 NPN 的影响。</p>
<p>如果结果包含 <code>No ALPN negotiated</code>，说明服务端不支持 ALPN，在 Chrome 51+ 中无法协商到 HTTP/2，需要尽快升级。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CentOS 7 默认带的openssl是1.0.1版本，开启HTTP2则必须升级1.1左右的版本。&lt;/p&gt;
&lt;p&gt;本文仅适用CentOS7&lt;/p&gt;
&lt;p&gt;以下为升级全过程&lt;/p&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Openssl" scheme="https://www.kanshouce.com/tags/Openssl/"/>
    
  </entry>
  
  <entry>
    <title>YUM安装php7与Nginx</title>
    <link href="https://www.kanshouce.com/2017/08/01/nginx-php7/"/>
    <id>https://www.kanshouce.com/2017/08/01/nginx-php7/</id>
    <published>2017-08-01T10:57:14.000Z</published>
    <updated>2017-08-08T13:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="ben-wen-gua-yong-ban-ben">本文适用版本</span></h1><p>服务器：centos 7.6 64x</p>
<p>SElinux：关闭</p>
<p>适用：YUM安装</p>
<h1><span id="an-zhuang-php7">安装PHP7</span></h1><h2><span id="shan-chu-jiu-ban-ben">删除旧版本</span></h2><p>首先检查之前用YUM安装的php版本与包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[server@name]<span class="comment"># yum list installed | grep php</span></div></pre></td></tr></table></figure>
<p>如果有安装过，根据GREP出的列表删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum remove php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-devel.x86_64 php56w-fpm.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 php56w-pear.noarch php56w-pecl-igbinary.x86_64 php56w-pecl-memcache.x86_64 php56w-pecl-redis.x86_64 php56w-process.x86_64 php56w-soap.x86_64 php56w-xml.x86_64</div></pre></td></tr></table></figure>
<p>每个空格删除一个</p>
<h2><span id="pei-zhi-an-zhuang-yuan">配置安装源</span></h2><p>以下是CentOS 7的源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm</div><div class="line">$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</div></pre></td></tr></table></figure>
<h2><span id="an-zhuang">安装</span></h2><p>安装php</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[server@name]<span class="comment"># yum install \</span></div><div class="line">php70w.x86_64 \</div><div class="line">php70w-cli.x86_64 \</div><div class="line">php70w-common.x86_64 \</div><div class="line">php70w-gd.x86_64 \</div><div class="line">php70w-ldap.x86_64 \</div><div class="line">php70w-mbstring.x86_64 \</div><div class="line">php70w-mcrypt.x86_64 \</div><div class="line">php70w-mysql.x86_64 \</div><div class="line">php70w-pdo.x86_64</div></pre></td></tr></table></figure>
<p>安装php-fpm</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install php70w-fpm</div></pre></td></tr></table></figure>
<p>非常简单，安装好后的配置文件在 <code>/etc/php.ini</code>内</p>
<p>如果需要安装php的其他版本，替换上面的70w为其他版本号即可。</p>
<h2><span id="pei-zhi-zi-dong-qi-dong">配置自动启动</span></h2><p>用centos7的systemctl任务管理配置自动启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ systemctl <span class="built_in">enable</span> php-fpm   //加入到系统服务中</div><div class="line">$ systemctl start php-fpm    //启动</div><div class="line">$ systemctl status php-fpm   //查看运行状态</div></pre></td></tr></table></figure>
<h1><span id="an-zhuang-nginx">安装Nginx</span></h1><p>在<code>/etc/yum.repos.d</code>目录下创建文件<code>nginx.repo</code>，输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#nginx.repo</span></div><div class="line"></div><div class="line">[nginx]</div><div class="line">name=nginx repo</div><div class="line">baseurl=http://nginx.org/packages/centos/6/<span class="variable">$basearch</span>/</div><div class="line">gpgcheck=0</div><div class="line">enabled=1</div></pre></td></tr></table></figure>
<p>其中，<code>baseurl</code>中的6是CentOS的主版本号，因为我的操作系统是CentOS 6.3。如果是CentOS 7，就应该是<code>http://nginx.org/packages/centos/7/$basearch/</code>。</p>
<p><code>enabled=1</code>表示这个库是开启的，用完之后可以把它关闭。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum install nginx  //安装使用</div><div class="line">$ yum update nginx   //因为加入了nginx源，升级可直接升级</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;&lt;span id=&quot;ben-wen-gua-yong-ban-ben&quot;&gt;本文适用版本&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;服务器：centos 7.6 64x&lt;/p&gt;
&lt;p&gt;SElinux：关闭&lt;/p&gt;
&lt;p&gt;适用：YUM安装&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;an-zhuan
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Centos" scheme="https://www.kanshouce.com/tags/Centos/"/>
    
      <category term="Nginx" scheme="https://www.kanshouce.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>为服务器SSH增加Google两步验证登陆</title>
    <link href="https://www.kanshouce.com/2017/07/31/google-linux-2F/"/>
    <id>https://www.kanshouce.com/2017/07/31/google-linux-2F/</id>
    <published>2017-07-31T06:38:43.000Z</published>
    <updated>2017-08-08T13:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="ben-wen-an-zhuang-huan-jing-centos-7-64-wei">本文安装环境： CentOS 7 64位</span></h2><a id="more"></a>
<h2><span id="an-zhuang-suo-xu-de-zhi-chi-huan-jing">安装所需的支持环境</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yum groupinstall <span class="string">"Development Tools"</span> -y         </div><div class="line">$ yum install pam-devel -y         </div><div class="line">$ yum install chrony -y     //这步Centos7是已经默认安装的</div></pre></td></tr></table></figure>
<h2><span id="chong-yao-kai-qi-shi-jian-tong-bu">【重要】开启时间同步</span></h2><p>由于GOOGLE的两步验证服务器端每次密钥生成依赖时间，所以务必执行本步骤，以确保时间是正确时间</p>
<p>编辑时间同步的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/chrony.conf</div></pre></td></tr></table></figure>
<p>在头部时间服务器列表中增加：<code>server 2.cn.pool.ntp.org iburst</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ systemctl restart chronyd  //重启时间服务 </div><div class="line">$ chronyc sources  //手动同步一下时间</div></pre></td></tr></table></figure>
<h2><span id="bian-yi-an-zhuang-gu-ge-liang-bu-yan-zheng">编译安装谷歌两步验证</span></h2><p>先从远端仓库拉回来代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/google/google-authenticator-libpam.git     </div><div class="line">$ <span class="built_in">cd</span> google-authenticator-libpam/</div></pre></td></tr></table></figure>
<p>编译、安装：          </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./bootstrap.sh</div><div class="line">$ ./configure</div><div class="line">$ make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2><span id="chong-yao-bu-zou">重要步骤</span></h2><p>将谷歌两步验证加入到ssh服务中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/pam.d/sshd</div></pre></td></tr></table></figure>
<p>在文件中<strong>头部</strong>增加：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auth required pam_google_authenticator.so</div></pre></td></tr></table></figure>
<p>配置ssh服务，开启两步验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure>
<p>找到<code>ChallengeResponseAuthentication no</code> 将<code>no</code>修改为<code>yes</code></p>
<h3><span id="chong-yao">重要</span></h3><p>按照默认安装，会报错，请将这个文件cp或者ln到目录，推荐使用ln方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp pam_google_authenticator.so /usr/lib64/security/</div></pre></td></tr></table></figure>
<p>重启ssh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ systemctl restart sshd</div></pre></td></tr></table></figure>
<p>开始配置谷歌两步验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ google-authenticator</div></pre></td></tr></table></figure>
<p>这里剩下一路回车即可，系统会生成密钥，可以用谷歌验证器扫描增加。</p>
<p>这里要注意的是在二维码生成后会现实几串应急密码，可以记录下来，在验证器失败的时候可以用临时应急密码登陆，但每使用一个失效一个。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文安装环境：-CentOS-7-64位&quot;&gt;&lt;a href=&quot;#本文安装环境：-CentOS-7-64位&quot; class=&quot;headerlink&quot; title=&quot;本文安装环境： CentOS 7 64位&quot;&gt;&lt;/a&gt;本文安装环境： CentOS 7 64位&lt;/h2&gt;
    
    </summary>
    
      <category term="Server" scheme="https://www.kanshouce.com/categories/Server/"/>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Centos" scheme="https://www.kanshouce.com/tags/Centos/"/>
    
      <category term="Google 2FC" scheme="https://www.kanshouce.com/tags/Google-2FC/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="https://www.kanshouce.com/2017/06/20/essay/"/>
    <id>https://www.kanshouce.com/2017/06/20/essay/</id>
    <published>2017-06-20T03:25:08.000Z</published>
    <updated>2017-08-08T13:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这只是一篇随笔。</p>
<a id="more"></a>
<h2><span id="wen-hua-kuai-can">文化快餐</span></h2><p>之前大概一直在看晓松奇谈，早期的奇葩说看过但始终觉得没甚意思，最近偶尔看到，才发现文化快餐流行到了一个令人惊讶的地步。</p>
<p>学习是一个修心的过程，人类大多数愉悦的反馈实际保持了能量守恒的定律，愉悦是痛苦或不快后上天给予的反馈。阅读和学习便是这样的一个过程，就像从初拾起跑步的痛苦到身心愉悦。</p>
<p>学习必然是痛苦的，就像上学的本质实际上是人在毕业之前父母偷懒把你送到监狱的一个普世现象。</p>
<p>因为生活的痛苦，所以人类总想找捷径，而一旦发现了捷径，便认为这是唯一的道路。</p>
<p>知识的本质是一场盛宴，特别是人有余力广博群书的时候。前几天看到文章讨论为什么中国的娱乐节目没有原创，细数了各种不是，初为认同，因为火热的娱乐节目确实版权不在中国。但看了奇葩说，我想，这是一个经典的案例，这是一个让人细思极恐的案例。</p>
<p>偶然窥见的那期没有看完，那期的辩题是这样的：</p>
<blockquote>
<p>奇葩村有一口愚人井，喝了井水的人，变得黑白不分，颠倒是非，全村都喝了，你喝不喝？</p>
</blockquote>
<p>后来看下去，便觉得这是一群聪明人，因为能把哲学初级入门题（铁轨问题）搬上来，又按照教材路线从不同的角度去演绎，更有甚者把入门的下一题（人是否存在问题）也揭开了一角。但这个问题在哲学教学上（可见哈佛公开课）是涉及了“死刑是否合理”的命题，其本质，这是一道政治题啊，细思极恐。前前后后，一堆口才卓著的文化人专注表演快两小时，我想，职业演员已经OUT了，什么叫深度？什么叫内涵？什么叫有文化？什么叫会玩？</p>
<p>所以，节目带来的思考便是，如果这代表了市场需要更高智商的节目来愚弄大众，那我们的教育还能跟的上么？愚民和对这个世界充满了解行家里手的结构已经越拉越大了么？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这只是一篇随笔。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NULLCON 2017：GNU RADIO+SDR，无人机劫持和其他IOT入侵问题</title>
    <link href="https://www.kanshouce.com/2017/06/16/Nullcon2017DroneHijacking/"/>
    <id>https://www.kanshouce.com/2017/06/16/Nullcon2017DroneHijacking/</id>
    <published>2017-06-16T13:20:05.000Z</published>
    <updated>2017-08-08T13:27:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nullcon（在印度举办的一个国际性安全会议）在今年3月初举行，最近有些演示文稿的视频已经在网上可以看到。</p>
<p>一个有趣的演讲是亚瑟·加皮洛夫（Arthur Garipov）关于“GNU RADIO+SDR，无人机劫持和其他IOT入侵问题”的演讲。在他的演讲中，他解释了他如何使用软件定义的无线电和GNU Radio基于nRF，攻击各种无人机以及其他IoT设备。演讲中他说：</p>
<blockquote>
<p>物联网正围绕着我们，但是否考虑过安全问题？还是大多数人已经遗忘了安全性（被视为）隐形？近些年来SDR（软件定义无线电）和GNU Radio可以回答这些问题。在本演示中，我们将会“重放”一些流行的无线设备。它们具有类似的协议，并且它们都没有对通讯数据进行加密。</p>
<p>我们将展示使用SDR和专有芯片设备找到它们是多么容易，以及如何使用简单的python脚本和GNU Radio来嗅探/拦截/干扰这些设备。</p>
<p>作为一个例子，我们将展示一个Mousejack攻击鼠标的无线加密狗，实现无线键盘键盘记录器，甚至包括无人机劫持。</p>
</blockquote>
<p>演讲人物介绍：<br>网络应用安全小组 高级专家，Artur生于1987年。他毕业于乌法国家航空技术大学，是OZNA的软件开发人员和独立安全研究员。他于2014年开始在Positive Technologies工作。目前他从事无线技术，移动系统和IoT的安全研究。他还是PHDays V和PHDays VI的MiTM Mobile竞赛、实践实验室的组织者。</p>
<p>谈话幻灯片可以从他们的<a href="http://nullcon.net/website/archives/goa-2017.php" target="_blank" rel="external">档案下载</a>。</p>
<a id="more"></a>
<p>关于无线网络的安全问题，必将被提上日程，无线为我们的生活带来了极大的便利，但是完全没有加密的无线设备通讯，确是当下非常严重的漏洞，而这种漏洞可能存活的时间会非常久。</p>
<p>曾经在一些安全网站、论坛看过一些千奇百怪的入侵方式，包括利用信号检测对室内进行绘图、通过硬盘灯闪烁读取数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nullcon（在印度举办的一个国际性安全会议）在今年3月初举行，最近有些演示文稿的视频已经在网上可以看到。&lt;/p&gt;
&lt;p&gt;一个有趣的演讲是亚瑟·加皮洛夫（Arthur Garipov）关于“GNU RADIO+SDR，无人机劫持和其他IOT入侵问题”的演讲。在他的演讲中，他解释了他如何使用软件定义的无线电和GNU Radio基于nRF，攻击各种无人机以及其他IoT设备。演讲中他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物联网正围绕着我们，但是否考虑过安全问题？还是大多数人已经遗忘了安全性（被视为）隐形？近些年来SDR（软件定义无线电）和GNU Radio可以回答这些问题。在本演示中，我们将会“重放”一些流行的无线设备。它们具有类似的协议，并且它们都没有对通讯数据进行加密。&lt;/p&gt;
&lt;p&gt;我们将展示使用SDR和专有芯片设备找到它们是多么容易，以及如何使用简单的python脚本和GNU Radio来嗅探/拦截/干扰这些设备。&lt;/p&gt;
&lt;p&gt;作为一个例子，我们将展示一个Mousejack攻击鼠标的无线加密狗，实现无线键盘键盘记录器，甚至包括无人机劫持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;演讲人物介绍：&lt;br&gt;网络应用安全小组 高级专家，Artur生于1987年。他毕业于乌法国家航空技术大学，是OZNA的软件开发人员和独立安全研究员。他于2014年开始在Positive Technologies工作。目前他从事无线技术，移动系统和IoT的安全研究。他还是PHDays V和PHDays VI的MiTM Mobile竞赛、实践实验室的组织者。&lt;/p&gt;
&lt;p&gt;谈话幻灯片可以从他们的&lt;a href=&quot;http://nullcon.net/website/archives/goa-2017.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;档案下载&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Hack" scheme="https://www.kanshouce.com/categories/Hack/"/>
    
    
      <category term="SDR" scheme="https://www.kanshouce.com/tags/SDR/"/>
    
      <category term="Hack" scheme="https://www.kanshouce.com/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>避免被判定为垃圾邮件，提高邮件被接受效率</title>
    <link href="https://www.kanshouce.com/2017/06/16/emailtester/"/>
    <id>https://www.kanshouce.com/2017/06/16/emailtester/</id>
    <published>2017-06-16T09:25:42.000Z</published>
    <updated>2017-08-08T13:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候采用外部免费的Email企业邮箱会遇到一些问题，比如会被一些外部邮箱判定为垃圾邮件，通过这个网站，可以改进这个问题。</p>
<p><code>http://www.mail-tester.com</code></p>
<p>网站每次访问会给出一个临时的邮件地址，向这个邮件地址发送邮件（比如说邀请用户注册的模版、找回密码模版等），发送完成后，可以看到邮件的评分结果。</p>
<p>这是一个有效提高邮件到达率的方法。</p>
<a id="more"></a>
<p><img src="https://pic.kanshouce.com/blog/2017-06-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A71111.png" alt=""></p>
<p>如图所示，最早的时候公司企业邮箱的评分非常低，在经过调整改进后，可以看到明显提升。</p>
<p><img src="https://pic.kanshouce.com/blog/2017-06-16-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-16%20%E4%B8%8B%E5%8D%885.24.18.png" alt=""></p>
<p>实际上此封邮件可以得到7分以上的评价，因为文件内容较少（不足2000字）等问题，没有得到分值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多时候采用外部免费的Email企业邮箱会遇到一些问题，比如会被一些外部邮箱判定为垃圾邮件，通过这个网站，可以改进这个问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://www.mail-tester.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网站每次访问会给出一个临时的邮件地址，向这个邮件地址发送邮件（比如说邀请用户注册的模版、找回密码模版等），发送完成后，可以看到邮件的评分结果。&lt;/p&gt;
&lt;p&gt;这是一个有效提高邮件到达率的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="https://www.kanshouce.com/tags/Server/"/>
    
      <category term="Email" scheme="https://www.kanshouce.com/tags/Email/"/>
    
  </entry>
  
  <entry>
    <title>需要注意的一些航空公司排名</title>
    <link href="https://www.kanshouce.com/2017/04/11/Refuseflights/"/>
    <id>https://www.kanshouce.com/2017/04/11/Refuseflights/</id>
    <published>2017-04-11T08:41:14.000Z</published>
    <updated>2017-08-08T13:28:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近发生了美联航致使地勤安保殴打顾客的<a href="http://www.ifanr.com/817369" target="_blank" rel="external">事件</a>，在这个事件中美联航自事发到CEO的公关策略上看实在不怎么高明。</p>
<p>就目前在Star Alliance接受了金卡服务5年的客户来说，暂时尚未遇到糟糕的服务。但是我的Star Alliance gold member已经到期，出于对此次事件的考虑，在未来的时间里，不再考虑Star Alliance的服务(但是在伊斯坦布尔Star Alliance那巨大功能齐全的贵宾室让人难以忘记)。</p>
<p>事实上，2015 年年底，外媒评选“全球服务最差的航空公司”榜单里，美联航（非廉航）名列其中，现摘抄名录，整理。</p>
<p><strong>全球服务最差的航空公司前十名</strong>（分数从低到高）</p>
<table>
<thead>
<tr>
<th>排名</th>
<th>航空公司</th>
<th>所属联盟</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>美国精神航空（Spirit）</td>
<td>／</td>
</tr>
<tr>
<td>2</td>
<td>易捷航空（easyJet）</td>
<td>／</td>
</tr>
<tr>
<td>3</td>
<td>美国忠实航空（Allegiant）</td>
<td>／</td>
</tr>
<tr>
<td>4</td>
<td>全美航空（US Airways）</td>
<td>寰宇一家</td>
</tr>
<tr>
<td>5</td>
<td>美鹰航空（American Eagle）</td>
<td>寰宇一家</td>
</tr>
<tr>
<td>6</td>
<td>美国边疆航空（Frontier）</td>
<td>／</td>
</tr>
<tr>
<td>7</td>
<td>美国联合航空（United Airlines）</td>
<td>星空联盟</td>
</tr>
<tr>
<td>8</td>
<td>中国国航（Air China）</td>
<td>星空联盟</td>
</tr>
<tr>
<td>9</td>
<td>意大利航空（Alitalia）</td>
<td>天合联盟</td>
</tr>
<tr>
<td>10</td>
<td>西班牙伊比利亚航空（Iberia）</td>
<td>寰宇一家</td>
</tr>
</tbody>
</table>
<p>建议在国际出发预定机票前检查这个清单，如果不幸因为价格问题而选中，这样可以有一个有准备的的心理预期，降低自己的预期，保证有一段优雅的旅途。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发生了美联航致使地勤安保殴打顾客的&lt;a href=&quot;http://www.ifanr.com/817369&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;事件&lt;/a&gt;，在这个事件中美联航自事发到CEO的公关策略上看实在不怎么高明。&lt;/p&gt;
&lt;p&gt;就目前
    
    </summary>
    
      <category term="Traveler" scheme="https://www.kanshouce.com/categories/Traveler/"/>
    
    
      <category term="Refuse flights" scheme="https://www.kanshouce.com/tags/Refuse-flights/"/>
    
      <category term="flights" scheme="https://www.kanshouce.com/tags/flights/"/>
    
  </entry>
  
</feed>
