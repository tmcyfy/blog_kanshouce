<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Louis,liuqichao@liuqichao.com"><title>koa-guide-v2 · 手册</title><meta name="description" content="由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份




中文文档
koa 简介
安装 koa
使用Babel来支持Async Functions


应用（Application）
级联代码（Cascading）
应用配置（Settings）
中间件（Middlew"><meta name="keywords" content="Life,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">手册</a></h3><div class="description"><p>Nothing lasts forever.</p></div></div></div><ul class="social-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><div class="footer"><div class="by_farbox"><a href="#">粤ICP备13034981号-2</a><div class="by_farbox"></div><sine>2016</sine><baidu>&lt;script&gt;var _hmt = _hmt || [];(function() {var hm = document.createElement(&quot;script&quot;);hm.src = &quot;https://hm.baidu.com/hm.js?81ba2fab00ebf90138468b27f1178db1&quot;;var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);})();&lt;/script&gt;</baidu></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li><li><a href="/reader">阅读者</a></li><li><a href="/node">Node</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>koa-guide-v2</a></h3></div><div class="post-content"><p>由于每次翻阅KOA的文档需要辛苦的爬到Github，从GIThub原版搬过来一份<br><a id="more"></a></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#zhong-wen-wen-dang">中文文档</a><ul>
<li><a href="#koa-jian-jie">koa 简介</a></li>
<li><a href="#an-zhuang-koa">安装 koa</a><ul>
<li><a href="#shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</a></li>
</ul>
</li>
<li><a href="#ying-yong-application">应用（Application）</a></li>
<li><a href="#ji-lian-dai-ma-cascading">级联代码（Cascading）</a></li>
<li><a href="#ying-yong-pei-zhi-settings">应用配置（Settings）</a></li>
<li><a href="#zhong-jian-jian-middleware">中间件（Middleware）</a></li>
<li><a href="#chang-yong-fang-fa">常用方法</a><ul>
<li><a href="#app-listen">app.listen(…)</a></li>
<li><a href="#app-callback">app.callback()</a></li>
<li><a href="#app-use-function">app.use(function)</a></li>
<li><a href="#app-keys">app.keys=</a></li>
</ul>
</li>
<li><a href="#cuo-wu-chu-li-error-handling">错误处理（Error Handling）</a></li>
<li><a href="#ying-yong-shang-xia-wen-context">应用上下文（Context）</a><ul>
<li><a href="#request-dui-xiang">Request 对象</a></li>
<li><a href="#response-dui-xiang">Response 对象</a></li>
<li><a href="#shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</a></li>
</ul>
</li>
<li><a href="#request">Request</a><ul>
<li><a href="#req-header">req.header</a></li>
<li><a href="#req-method">req.method</a></li>
<li><a href="#req-method">req.method=</a></li>
<li><a href="#req-length">req.length</a></li>
<li><a href="#req-url">req.url</a></li>
<li><a href="#req-url">req.url=</a></li>
<li><a href="#req-path">req.path</a></li>
<li><a href="#req-path">req.path=</a></li>
<li><a href="#req-querystring">req.querystring</a></li>
<li><a href="#req-querystring">req.querystring=</a></li>
<li><a href="#req-search">req.search</a></li>
<li><a href="#req-search">req.search=</a></li>
<li><a href="#req-host">req.host</a></li>
<li><a href="#req-type">req.type</a></li>
<li><a href="#req-query">req.query</a></li>
<li><a href="#req-query">req.query=</a></li>
<li><a href="#req-fresh">req.fresh</a></li>
<li><a href="#req-stale">req.stale</a></li>
<li><a href="#req-protocol">req.protocol</a></li>
<li><a href="#req-secure">req.secure</a></li>
<li><a href="#req-ip">req.ip</a></li>
<li><a href="#req-ips">req.ips</a></li>
<li><a href="#req-subdomains">req.subdomains</a></li>
<li><a href="#req-is-type">req.is(type)</a></li>
<li><a href="#req-accepts-type">req.accepts(type)</a></li>
<li><a href="#req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</a></li>
<li><a href="#req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</a></li>
<li><a href="#req-acceptslanguages-langs">req.acceptsLanguages(langs)</a></li>
</ul>
</li>
<li><a href="#response">Response</a><ul>
<li><a href="#res-header">res.header</a></li>
<li><a href="#res-status">res.status</a></li>
<li><a href="#res-status">res.status=</a></li>
<li><a href="#res-length">res.length=</a></li>
<li><a href="#res-length">res.length</a></li>
<li><a href="#res-body">res.body</a></li>
<li><a href="#res-body">res.body=</a></li>
<li><a href="#res-get-field">res.get(field)</a></li>
<li><a href="#res-set-field-value">res.set(field, value)</a></li>
<li><a href="#res-set-fields">res.set(fields)</a></li>
<li><a href="#res-remove-fields">res.remove(fields)</a></li>
<li><a href="#res-type">res.type</a></li>
<li><a href="#res-type">res.type=</a></li>
<li><a href="#res-redirect-url-alt">res.redirect(url, [alt])</a></li>
<li><a href="#res-attachment-filename">res.attachment([filename])</a></li>
<li><a href="#res-headersent">res.headerSent</a></li>
<li><a href="#res-lastmodified">res.lastModified</a></li>
<li><a href="#res-etag">res.etag=</a></li>
</ul>
</li>
<li><a href="#xing-neng-benchmarks">性能（Benchmarks）</a></li>
<li><a href="#xue-xi-zi-liao">学习资料</a></li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#mit-license">MIT license</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>




<h1><span id="zhong-wen-wen-dang">中文文档</span></h1><p>Koa，下一代 Node.js web 框架</p>
<h2><span id="koa-jian-jie">koa 简介</span></h2><p>由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p>
<h2><span id="an-zhuang-koa">安装 koa</span></h2><p>Koa需要支持ES2015和<code>async</code> function的node v7.6.0或更高版本。</p>
<p>您可以使用喜欢的依赖管理工具快速安装支持的node版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ nvm install 7</div><div class="line">$ npm i koa</div><div class="line">$ node my-koa-app.js</div></pre></td></tr></table></figure>
<h3><span id="shi-yong-babel-lai-zhi-chi-async-functions">使用Babel来支持Async Functions</span></h3><p>在node 7.6版本以下，如果你想在koa里使用<code>async</code> functions，我们推荐<a href="http://babeljs.io/docs/usage/require/" target="_blank" rel="external">babel</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">require(&apos;babel-core/register&apos;);</div><div class="line">// require the rest of the app that needs to be transpiled after the hook</div><div class="line">const app = require(&apos;./app&apos;);</div></pre></td></tr></table></figure>
<p>你至少要使用<a href="http://babeljs.io/docs/plugins/transform-async-to-generator/" target="_blank" rel="external">transform-async-to-generator</a> or <a href="http://babeljs.io/docs/plugins/transform-async-to-module-method/" target="_blank" rel="external">transform-async-to-module-method</a>插件，<br>来解析和转译async functions。例如，你可以在你的<code>.babelrc</code>文件里这样写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-async-to-generator"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你也可以在<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">env preset</a>里使用目标选项<code>&quot;node&quot;: &quot;current&quot;</code>。</p>
<hr>
<h2><span id="ying-yong-application">应用（Application）</span></h2><p>一个 Koa Application（以下简称 app）由一系列 generator 中间件组成。按照编码顺序在栈内依次执行，从这个角度来看，Koa app 和其他中间件系统（比如 Ruby Rack 或者 Connect/Express ）没有什么太大差别，不过，从另一个层面来看，Koa 提供了一种基于底层中间件编写「语法糖」的设计思路，这让设计中间件变得更简单有趣。</p>
<p>在这些中间件中，有负责内容协商（content-negotation）、缓存控制（cache freshness）、反向代理（proxy support）与重定向等等功能的常用中间件（详见 <a href="#%E4%B8%AD%E9%97%B4%E4%BB%B6middleware">中间件</a> 章节），但如前所述， Koa 内核并不会打包这些中间件，让我们先来看看 Koa 极其简单的 Hello World 应用程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果使用Koa 2的话：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Koa();</div><div class="line"></div><div class="line">app.use(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</div><div class="line">  ctx.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p><strong>译者注：</strong> 与普通的 function 不同，generator functions 以 <code>function*</code> 声明，以这种关键词声明的函数支持 <code>yield</code>。generator function是ECMAScript 6定义的新的语法，想了解其基本用法，以及Koa如何利用generator function达到在保持js代码异步特性的同时无需编写大量回调函数，可以参考<a href="http://blog.stevensanderson.com/2013/12/21/experiments-with-koa-and-javascript-generators/" target="_blank" rel="external">这篇文章</a>。</p>
<hr>
<h2><span id="ji-lian-dai-ma-cascading">级联代码（Cascading）</span></h2><p>Koa 中间件以一种非常传统的方式级联起来，你可能会非常熟悉这种写法。</p>
<p>在以往的 Node 开发中，频繁使用回调不太便于展示复杂的代码逻辑，在 Koa 中，我们可以写出真正具有表现力的中间件。与 Connect 实现中间件的方法相对比，Koa 的做法不是简单的将控制权依次移交给一个又一个的中间件直到程序结束，Koa 执行代码的方式有点像回形针，用户请求通过中间件，遇到 <code>yield next</code> 关键字时，会被传递到下一个符合请求的路由（downstream），在 <code>yield next</code> 捕获不到下一个中间件时，逆序返回继续执行代码（upstream）。</p>
<p>下边这个例子展现了使用这一特殊方法书写的 Hello World 范例：一开始，用户的请求通过 x-response-time 中间件和 logging 中间件，这两个中间件记录了一些请求细节，然后「穿过」 response 中间件一次，最终结束请求，返回 「Hello World」。</p>
<p>当程序运行到 <code>yield next</code> 时，代码流会暂停执行这个中间件的剩余代码，转而切换到下一个被定义的中间件执行代码，这样切换控制权的方式，被称为<br>downstream，当没有下一个中间件执行 downstream 的时候，代码将会逆序执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line"><span class="comment">// x-response-time</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (1) 进入路由</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (5) 再次进入 x-response-time 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);</div><div class="line">  <span class="comment">// (6) 返回 this.body</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// logger</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</div><div class="line">  <span class="comment">// (2) 进入 logger 中间件</span></div><div class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">yield</span> next;</div><div class="line">  <span class="comment">// (4) 再次进入 logger 中间件，记录2次通过此中间件「穿越」的时间</span></div><div class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// response</span></div><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// (3) 进入 response 中间件，没有捕获到下一个符合条件的中间件，传递到 upstream</span></div><div class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>在上方的范例代码中，中间件依次被执行的顺序已经在注释中标记出来。你也可以自己尝试运行一下这个范例，并打印记录下各个环节的输出与耗时。</p>
<p><strong>译者注：</strong> 「级联」这个词许多人也许在 CSS 中听说过，如果你不能理解为什么在这里使用这个词，可以将这种路由结构想象成 LESS 的继承嵌套书写方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.middleware1 &#123;</div><div class="line">  // (1) do some stuff</div><div class="line">  .middleware2 &#123;</div><div class="line">    // (2) do some other stuff</div><div class="line">    .middleware3 &#123;</div><div class="line">      // (3) NO next yield !</div><div class="line">      // this.body = &apos;hello world&apos;</div><div class="line">    &#125;</div><div class="line">    // (4) do some other stuff later</div><div class="line">  &#125;</div><div class="line">  // (5) do some stuff lastest and return</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上方的伪代码中标注了中间件的执行顺序，看起来是不是有点像 ruby 执行代码块（block）时 yield 的表现了？也许这能帮助你更好的理解 koa 运作的方式。</p>
<p><strong>译者注：</strong> 更加形象的图可以参考 <a href="https://docs.djangoproject.com/en/1.6/topics/http/middleware/" target="_blank" rel="external">Django Middleware</a></p>
<p><img src="https://raw.github.com/fengmk2/koa-guide/master/onion.png" alt="onion.png"></p>
<hr>
<h2><span id="ying-yong-pei-zhi-settings">应用配置（Settings）</span></h2><p>应用的配置是 app 实例的属性。目前来说，Koa 的配置项如下：</p>
<ul>
<li>app.name 应用名称</li>
<li>app.env 执行环境，默认是 <code>NODE_ENV</code> 或者 <code>&quot;development&quot;</code> 字符串</li>
<li>app.proxy 决定了哪些 <code>proxy header</code> 参数会被加到信任列表中</li>
<li>app.subdomainOffset 被忽略的 <code>.subdomains</code> 列表，详见下方 api</li>
</ul>
<hr>
<h2><span id="zhong-jian-jian-middleware">中间件（Middleware）</span></h2><ul>
<li><a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="external">koa-router</a></li>
<li><a href="https://github.com/koajs/trie-router" target="_blank" rel="external">trie-router</a></li>
<li><a href="https://github.com/koajs/route" target="_blank" rel="external">route</a></li>
<li><a href="https://github.com/koajs/basic-auth" target="_blank" rel="external">basic-auth</a></li>
<li><a href="https://github.com/koajs/etag" target="_blank" rel="external">etag</a></li>
<li><a href="https://github.com/koajs/compose" target="_blank" rel="external">compose</a></li>
<li><a href="https://github.com/koajs/static" target="_blank" rel="external">static</a></li>
<li><a href="https://github.com/koajs/static-cache" target="_blank" rel="external">static-cache</a></li>
<li><a href="https://github.com/koajs/session" target="_blank" rel="external">session</a></li>
<li><a href="https://github.com/koajs/compress" target="_blank" rel="external">compress</a></li>
<li><a href="https://github.com/koajs/csrf" target="_blank" rel="external">csrf</a></li>
<li><a href="https://github.com/koajs/logger" target="_blank" rel="external">logger</a></li>
<li><a href="https://github.com/koajs/mount" target="_blank" rel="external">mount</a></li>
<li><a href="https://github.com/koajs/send" target="_blank" rel="external">send</a></li>
<li><a href="https://github.com/koajs/error" target="_blank" rel="external">error</a></li>
</ul>
<hr>
<h2><span id="chang-yong-fang-fa">常用方法</span></h2><h3><span id="app-listen">app.listen(…)</span></h3><p>用于启动一个服务的快捷方法，以下范例代码在 3000 端口启动了一个空服务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">app.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>app.listen 是 http.createServer 的简单包装，它实际上这样运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>
<p>如果有需要，你可以在多个端口上启动一个 app，比如同时支持 HTTP 和 HTTPS：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</div><div class="line"><span class="keyword">var</span> app = koa();</div><div class="line"></div><div class="line">http.createServer(app.callback()).listen(<span class="number">3000</span>);</div><div class="line">http.createServer(app.callback()).listen(<span class="number">3001</span>);</div></pre></td></tr></table></figure>
<h3><span id="app-callback">app.callback()</span></h3><p>返回一个可被 <code>http.createServer()</code> 接受的程序实例，也可以将这个返回函数挂载在一个 Connect/Express 应用中。</p>
<h3><span id="app-use-function">app.use(function)</span></h3><p>将给定的 function 当做中间件加载到应用中，详见 <a href="#middleware">中间件</a> 章节</p>
<h3><span id="app-keys">app.keys=</span></h3><p>设置一个签名 Cookie 的密钥。这些参数会被传递给 <a href="https://github.com/jed/keygrip" target="_blank" rel="external">KeyGrip</a> 如果你想自己生成一个实例，也可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.keys = [<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>];</div><div class="line">app.keys = <span class="keyword">new</span> KeyGrip([<span class="string">'im a newer secret'</span>, <span class="string">'i like turtle'</span>], <span class="string">'sha256'</span>);</div></pre></td></tr></table></figure>
<p>注意，签名密钥只在配置项 <code>signed</code> 参数为真时才会生效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.cookies.set(<span class="string">'name'</span>, <span class="string">'tobi'</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</div></pre></td></tr></table></figure>
<h2><span id="cuo-wu-chu-li-error-handling">错误处理（Error Handling）</span></h2><p>除非 <code>NODE_ENV</code> 被配置为 <code>&quot;test&quot;</code>，Koa 都将会将所有错误信息输出到 <code>stderr</code>，也可以自定义「错误事件」来监听 Koa app 中发生的错误，比如记录错误日志：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当任何 <code>req</code> 或者 <code>res</code> 中出现的错误无法被回应到客户端时，Koa 会在第二个参数传入这个错误的上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, ctx</span>)</span>&#123;</div><div class="line">  log.error(<span class="string">'server error'</span>, err, ctx);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>任何错误有可能被回应到客户端，比如当没有新数据写入 socket 时，Koa 会默认返回一个 500 错误，并抛出一个 app 级别的错误到日志处理中间件中。</p>
<hr>
<h2><span id="ying-yong-shang-xia-wen-context">应用上下文（Context）</span></h2><p>Koa 的上下文封装了 request 与 response 对象至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。为了方便，你可以在 <code>ctx.request</code> 和 <code>ctx.response</code> 中访问到这些方法。</p>
<p>每一个请求都会创建一段上下文。在控制业务逻辑的中间件中，上下文被寄存在 <code>this</code> 对象中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>; <span class="comment">// 上下文对象</span></div><div class="line">  <span class="keyword">this</span>.request; <span class="comment">// Request 对象</span></div><div class="line">  <span class="keyword">this</span>.response; <span class="comment">// Response 对象</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了使用方便，许多上下文属性和方法都被委托代理到他们的 <code>ctx.request</code> 或 <code>ctx.response</code>，比如访问 <code>ctx.type</code> 和 <code>ctx.length</code> 将被代理到 <code>response</code> 对象，<code>ctx.path</code> 和 <code>ctx.method</code> 将被代理到 <code>request</code> 对象。</p>
<h3><span id="request-dui-xiang">Request 对象</span></h3><p>ctx.request 对象包括以下属性和别名方法，详见 <a href="#request">Request</a> 章节</p>
<ul>
<li>ctx.header</li>
<li>ctx.method</li>
<li>ctx.method=</li>
<li>ctx.url</li>
<li>ctx.url=</li>
<li>ctx.path</li>
<li>ctx.path=</li>
<li>ctx.query</li>
<li>ctx.query=</li>
<li>ctx.querystring</li>
<li>ctx.querystring=</li>
<li>ctx.length</li>
<li>ctx.host</li>
<li>ctx.fresh</li>
<li>ctx.stale</li>
<li>ctx.socket</li>
<li>ctx.protocol</li>
<li>ctx.secure</li>
<li>ctx.ip</li>
<li>ctx.ips</li>
<li>ctx.subdomains</li>
<li>ctx.is()</li>
<li>ctx.accepts()</li>
<li>ctx.acceptsEncodings()</li>
<li>ctx.acceptsCharsets()</li>
<li>ctx.acceptsLanguages()</li>
<li>ctx.get()</li>
</ul>
<h3><span id="response-dui-xiang">Response 对象</span></h3><p>ctx.response 对象包括以下属性和别名方法，详见 <a href="#response">Response</a> 章节</p>
<ul>
<li>ctx.body</li>
<li>ctx.body=</li>
<li>ctx.status</li>
<li>ctx.status=</li>
<li>ctx.length=</li>
<li>ctx.type</li>
<li>ctx.type=</li>
<li>ctx.headerSent</li>
<li>ctx.redirect()</li>
<li>ctx.attachment()</li>
<li>ctx.set()</li>
<li>ctx.remove()</li>
<li>ctx.lastModified=</li>
<li>ctx.etag=</li>
</ul>
<h3><span id="shang-xia-wen-dui-xiang-zhong-de-qi-ta-api">上下文对象中的其他 API</span></h3><ul>
<li>ctx.req: Node.js 中的 request 对象</li>
<li>ctx.res: Node.js 中的 response 对象，方法有:<ul>
<li>res.statusCode</li>
<li>res.writeHead()</li>
<li>res.write()</li>
<li>res.end()</li>
</ul>
</li>
<li>ctx.app: app 实例</li>
<li>ctx.state: 推荐的命名空间，用来保存那些通过中间件传递给视图的参数或数据。比如 <code>this.state.user = yield User.find(id);</code></li>
<li>ctx.cookies.get(name, [options]) 对于给定的 name ，返回响应的 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
</ul>
</li>
</ul>
</li>
<li>ctx.cookies.set(name, value, [options]) 对于给定的参数，设置一个新 cookie<ul>
<li>options<ul>
<li><code>signed</code> [boolean]</li>
<li><code>expires</code> [date]</li>
<li><code>path</code> [string] 默认为 <code>&#39;/&#39;</code></li>
<li><code>domain</code> [string]</li>
<li><code>secure</code> [boolean]</li>
<li><code>httpOnly</code> [boolean] 默认为 <code>true</code></li>
</ul>
</li>
</ul>
</li>
<li>ctx.throw(msg, [status]) 抛出常规错误的辅助方法，默认 status 为 500。</li>
</ul>
<p>以下几种写法都有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.throw(<span class="number">403</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'name required'</span>, <span class="number">400</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="number">400</span>, <span class="string">'name required'</span>)</div><div class="line"><span class="keyword">this</span>.throw(<span class="string">'something exploded'</span>)</div></pre></td></tr></table></figure>
<p>实际上，<code>this.throw(&#39;name required&#39;, 400)</code> 是此代码片段的简写方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'name required'</span>);</div><div class="line">err.status = <span class="number">400</span>;</div><div class="line"><span class="keyword">throw</span> err;</div></pre></td></tr></table></figure>
<p>需要注意的是，<code>ctx.throw</code> 创建的错误，均为用户级别错误（标记为err.expose），会被返回到客户端。</p>
<ul>
<li>ctx.assert(value, [msg], [status], [properties]) 用来断言的辅助方法，类似 Node 中的 <code>assert()</code> 方法。<code>this.assert(this.user, 401, &#39;User not found. Please login!&#39;);</code> 此方法由 <code>http-assert</code> 模块支持。</li>
</ul>
<hr>
<h2><span id="request">Request</span></h2><p>ctx.request 对象是对 Node 原生请求对象的抽象包装，提供了一些非常有用的方法。</p>
<p>详细的 Request 对象 API 如下：</p>
<h3><span id="req-header">req.header</span></h3><p>返回请求头</p>
<h3><span id="req-method">req.method</span></h3><p>返回请求方法</p>
<h3><span id="req-method">req.method=</span></h3><p>设置 req.method ，用于实现输入 <code>methodOverride()</code> 的中间件</p>
<h3><span id="req-length">req.length</span></h3><p>返回 req 对象的 <code>Content-Length</code> (Number)</p>
<h3><span id="req-url">req.url</span></h3><p>返回请求 url</p>
<h3><span id="req-url">req.url=</span></h3><p>设置请求 url，用于进行 url 重写</p>
<h3><span id="req-path">req.path</span></h3><p>返回请求 pathname</p>
<h3><span id="req-path">req.path=</span></h3><p>设置请求 pathname，如果原有 url 存在查询字符串，则保留这些查询。</p>
<h3><span id="req-querystring">req.querystring</span></h3><p>返回 url 中的查询字符串，去除了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-querystring">req.querystring=</span></h3><p>设置查询字符串，不包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search</span></h3><p>返回 url 中的查询字符串，包含了头部的 <code>&#39;?&#39;</code></p>
<h3><span id="req-search">req.search=</span></h3><p>设置查询字符串，包含 <code>&#39;?&#39;</code></p>
<h3><span id="req-host">req.host</span></h3><p>返回请求主机名，不包含端口；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Host</code>。</p>
<h3><span id="req-type">req.type</span></h3><p>返回 req 对象的 <code>Content-Type</code>，不包括 <code>charset</code> 属性，范例代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query</span></h3><p>返回经过解析的查询字符串，类似 Express 中的 req.query，当不存在查询字符串时，返回空对象。</p>
<p>当 url 包含查询字符串 <code>&quot;color=blue&amp;size=small&quot;</code> 时，返回如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">color</span>: <span class="string">'blue'</span>,</div><div class="line">  <span class="attr">size</span>: <span class="string">'small'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-query">req.query=</span></h3><p>设置给定的对象为查询对象。范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.query = &#123; <span class="attr">next</span>: <span class="string">'/login'</span> &#125;;</div></pre></td></tr></table></figure>
<h3><span id="req-fresh">req.fresh</span></h3><p>检查客户端请求的缓存是否是最新。当缓存为最新时，可编写业务逻辑直接返回 <code>304</code>，范例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'ETag'</span>, <span class="string">'123'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存是最新时</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fresh) &#123;</div><div class="line">  <span class="keyword">this</span>.status = <span class="number">304</span>;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当客户端缓存已过期时，返回最新的数据</span></div><div class="line"><span class="keyword">this</span>.body = <span class="keyword">yield</span> db.find(<span class="string">'something'</span>);</div></pre></td></tr></table></figure>
<h3><span id="req-stale">req.stale</span></h3><p>与 req.fresh 返回的结果正好相反</p>
<h3><span id="req-protocol">req.protocol</span></h3><p>返回请求协议名，如 <code>&quot;https&quot;</code> 或者 <code>&quot;http&quot;</code>；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-Proto</code>。</p>
<h3><span id="req-secure">req.secure</span></h3><p>判断请求协议是否为 HTTPS 的快捷方法，等同于 <code>this.protocol == &quot;https&quot;</code></p>
<h3><span id="req-ip">req.ip</span></h3><p>返回请求IP；当 <code>app.proxy</code> 设置为 <code>true</code> 时，支持 <code>X-Forwarded-For</code>。</p>
<h3><span id="req-ips">req.ips</span></h3><p>返回请求IP列表，仅当 <code>app.proxy</code> 设置为 <code>true</code> ，并存在 <code>X-Forwarded-For</code> 列表时，否则返回空数组。</p>
<h3><span id="req-subdomains">req.subdomains</span></h3><p>返回请求对象中的子域名数组。子域名数组会自动由请求域名字符串中的 <code>.</code> 分割开，在没有设置自定义的 <code>app.subdomainOffset</code> 参数时，默认返回根域名之前的所有子域名数组。</p>
<p>例如，当请求域名为 <code>&quot;tobi.ferrets.example.com&quot;</code> 时候，返回 <code>[&quot;ferrets&quot;, &quot;tobi&quot;]</code>，数组顺序是子代域名在前，孙代域名在后。</p>
<p>此例中，如果设置了自定义的 <code>app.subdomainOffset</code> 为 <code>3</code>，将忽略三级域名，返回 <code>[&quot;tobi&quot;]</code>。</p>
<h3><span id="req-is-type">req.is(type)</span></h3><p>判断请求对象中 <code>Content-Type</code> 是否为给定 type 的快捷方法，如果不存在 <code>request.body</code>，将返回 <code>undefined</code>，如果没有符合的类型，返回 <code>false</code>，除此之外，返回匹配的类型字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客户端 Content-Type: text/html; charset=utf-8</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; 'html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'text/*'</span>, <span class="string">'text/html'</span>); <span class="comment">// =&gt; 'text/html'</span></div><div class="line"></div><div class="line"><span class="comment">// 客户端 Content-Type 为 application/json 时：</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'json'</span>, <span class="string">'urlencoded'</span>); <span class="comment">// =&gt; 'json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'application/json'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>, <span class="string">'application/*'</span>); <span class="comment">// =&gt; 'application/json'</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.is(<span class="string">'html'</span>); <span class="comment">// =&gt; false</span></div></pre></td></tr></table></figure>
<p>又如，下方的代码使用 <code>req.is(type)</code>，仅当请求类型为图片时才进行操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.is(<span class="string">'image/*'</span>)) &#123;</div><div class="line">  <span class="comment">// process</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">this</span>.throw(<span class="number">415</span>, <span class="string">'images only!'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3><span id="req-accepts-type">req.accepts(type)</span></h3><p>判断请求对象中 <code>Accept</code> 是否为给定 type 的快捷方法，当匹配到符合的类型时，返回最匹配的类型，否则返回 <code>false</code>（此时服务器端应当返回 406 “Not Acceptable” ），传入参数可以是字符串或者数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept: text/html</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>);</div><div class="line"><span class="comment">// =&gt; "html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'text/html'</span>);</div><div class="line"><span class="comment">// =&gt; "text/html"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'json'</span>, <span class="string">'text'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'application/json'</span>);</div><div class="line"><span class="comment">// =&gt; "application/json"</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'image/png'</span>);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'png'</span>);</div><div class="line"><span class="comment">// =&gt; undefined</span></div><div class="line"></div><div class="line"><span class="comment">// Accept: text/*;q=.5, application/json</span></div><div class="line"><span class="keyword">this</span>.accepts([<span class="string">'html'</span>, <span class="string">'json'</span>]);</div><div class="line"><span class="keyword">this</span>.accepts(<span class="string">'html'</span>, <span class="string">'json'</span>);</div><div class="line"><span class="comment">// =&gt; "json"</span></div></pre></td></tr></table></figure>
<p>注意，当请求头中不包含 Accept 属性时，给定的第一个 type 将会被返回。</p>
<h3><span id="req-acceptsencodings-encodings">req.acceptsEncodings(encodings)</span></h3><p>判断客户端是否接受给定的编码方式的快捷方法，当有传入参数时，返回最应当返回的一种编码方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings(<span class="string">'gzip'</span>, <span class="string">'deflate'</span>);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.acceptsEncodings([<span class="string">'gzip'</span>, <span class="string">'deflate'</span>]);</div><div class="line"><span class="comment">// =&gt; "gzip"</span></div></pre></td></tr></table></figure>
<p>当没有传入参数时，返回客户端的请求数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Accept-Encoding: gzip, deflate</span></div><div class="line"><span class="keyword">this</span>.acceptsEncodings();</div><div class="line"><span class="comment">// =&gt; ["gzip", "deflate"]</span></div></pre></td></tr></table></figure>
<h3><span id="req-acceptscharsets-charsets">req.acceptsCharsets(charsets)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<h3><span id="req-acceptslanguages-langs">req.acceptsLanguages(langs)</span></h3><p>使用方法同 req.acceptsEncodings(encodings)</p>
<hr>
<h2><span id="response">Response</span></h2><p>详细的 Response 对象 API 如下：</p>
<h3><span id="res-header">res.header</span></h3><p>获取返回头</p>
<h3><span id="res-status">res.status</span></h3><p>获取返回状态</p>
<h3><span id="res-status">res.status=</span></h3><p>设置返回状态，可用状态如下：</p>
<ul>
<li>100 “continue”</li>
<li>101 “switching protocols”</li>
<li>102 “processing”</li>
<li>200 “ok”</li>
<li>201 “created”</li>
<li>202 “accepted”</li>
<li>203 “non-authoritative information”</li>
<li>204 “no content”</li>
<li>205 “reset content”</li>
<li>206 “partial content”</li>
<li>207 “multi-status”</li>
<li>300 “multiple choices”</li>
<li>301 “moved permanently”</li>
<li>302 “moved temporarily”</li>
<li>303 “see other”</li>
<li>304 “not modified”</li>
<li>305 “use proxy”</li>
<li>307 “temporary redirect”</li>
<li>400 “bad request”</li>
<li>401 “unauthorized”</li>
<li>402 “payment required”</li>
<li>403 “forbidden”</li>
<li>404 “not found”</li>
<li>405 “method not allowed”</li>
<li>406 “not acceptable”</li>
<li>407 “proxy authentication required”</li>
<li>408 “request time-out”</li>
<li>409 “conflict”</li>
<li>410 “gone”</li>
<li>411 “length required”</li>
<li>412 “precondition failed”</li>
<li>413 “request entity too large”</li>
<li>414 “request-uri too large”</li>
<li>415 “unsupported media type”</li>
<li>416 “requested range not satisfiable”</li>
<li>417 “expectation failed”</li>
<li>418 “i’m a teapot”</li>
<li>422 “unprocessable entity”</li>
<li>423 “locked”</li>
<li>424 “failed dependency”</li>
<li>425 “unordered collection”</li>
<li>426 “upgrade required”</li>
<li>428 “precondition required”</li>
<li>429 “too many requests”</li>
<li>431 “request header fields too large”</li>
<li>500 “internal server error”</li>
<li>501 “not implemented”</li>
<li>502 “bad gateway”</li>
<li>503 “service unavailable”</li>
<li>504 “gateway time-out”</li>
<li>505 “http version not supported”</li>
<li>506 “variant also negotiates”</li>
<li>507 “insufficient storage”</li>
<li>509 “bandwidth limit exceeded”</li>
<li>510 “not extended”</li>
<li>511 “network authentication required”</li>
</ul>
<h3><span id="res-length">res.length=</span></h3><p>设置返回头的 <code>Content-Length</code> 属性</p>
<h3><span id="res-length">res.length</span></h3><p>返回返回头的 <code>Content-Length</code> 属性，当不存在 <code>Content-Length</code> 属性时，根据 <code>res.body</code> 推断</p>
<h3><span id="res-body">res.body</span></h3><p>获取 res.body，当 res.body 为 null ，但返回状态仍为 200 时，koa 将会返回 404 页面。</p>
<h3><span id="res-body">res.body=</span></h3><p>设置请求返回的主要内容，可以是以下几种类型：</p>
<ul>
<li><p>string</p>
<p>Content-Type 将默认设置为 text/html 或者 text/plain，默认字符集是 utf-8，Content-Length 也将一并设置</p>
</li>
<li><p>Buffer</p>
<p>Content-Type 将默认设置为 application/octet-stream，Content-Length 也将一并设置</p>
</li>
<li><p>Stream</p>
<p>Content-Type 将默认设置为 application/octet-stream</p>
</li>
<li><p>Object</p>
<p>Content-Type 将默认设置为 application/json<br>注意：默认的json返回会添加空格，如果你希望压缩json返回中的空格，可以这样配置：<code>app.jsonSpaces = 0</code></p>
</li>
<li><p>null</p>
</li>
</ul>
<h3><span id="res-get-field">res.get(field)</span></h3><p>获取指定的返回头属性，属性名称区分大小写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etag = <span class="keyword">this</span>.get(<span class="string">'ETag'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-field-value">res.set(field, value)</span></h3><p>使用给定的参数设置一个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</div></pre></td></tr></table></figure>
<h3><span id="res-set-fields">res.set(fields)</span></h3><p>使用给定的对象一次设置多个返回头属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.set(&#123;</div><div class="line">  <span class="string">'Etag'</span>: <span class="string">'1234'</span>,</div><div class="line">  <span class="string">'Last-Modified'</span>: date</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3><span id="res-remove-fields">res.remove(fields)</span></h3><p>删除指定的返回头属性</p>
<h3><span id="res-type">res.type</span></h3><p>获取返回头中的 Content-Type，不包括 <code>&quot;charset&quot;</code> 等属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ct = <span class="keyword">this</span>.type;</div><div class="line"><span class="comment">// =&gt; "image/png"</span></div></pre></td></tr></table></figure>
<h3><span id="res-type">res.type=</span></h3><p>使用字符串或者文件后缀设定返回的 Content-Type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.type = <span class="string">'text/plain; charset=utf-8'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'image/png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'.png'</span>;</div><div class="line"><span class="keyword">this</span>.type = <span class="string">'png'</span>;</div></pre></td></tr></table></figure>
<p>注意：当使用文件后缀指定时，koa 会默认设置好最匹配的编码字符集，比如当设定 <code>res.type = &#39;html&#39;</code> 时，koa 会默认使用 <code>&quot;utf-8&quot;</code> 字符集。但当明确使用 <code>res.type = &#39;text/html&#39;</code> 指定时，koa 不会自动设定字符集。</p>
<h3><span id="res-redirect-url-alt">res.redirect(url, [alt])</span></h3><p>返回一个 <code>302</code> 跳转到给定的 url，您也可以使用关键词 <code>back</code> 来跳转到该 url 的上一个页面（refer），当没有上一个页面时，默认会跳转到 ‘/‘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'back'</span>, <span class="string">'/index.html'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/login'</span>);</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'http://google.com'</span>);</div></pre></td></tr></table></figure>
<p>如果你需要覆盖 <code>302</code> 状态码，并在跳转时返回一些文案，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.status = <span class="number">301</span>;</div><div class="line"><span class="keyword">this</span>.redirect(<span class="string">'/cart'</span>);</div><div class="line"><span class="keyword">this</span>.body = <span class="string">'Redirecting to shopping cart'</span>;</div></pre></td></tr></table></figure>
<h3><span id="res-attachment-filename">res.attachment([filename])</span></h3><p>设置返回熟悉 Content-Disposition 为 <code>&quot;attachment&quot;</code>，并告知客户端进行下载。</p>
<h3><span id="res-headersent">res.headerSent</span></h3><p>判断一个响应头是否已经发送到客户端，通常用来检测客户端是否收到了错误信息。</p>
<h3><span id="res-lastmodified">res.lastModified</span></h3><p>如果返回头中存在 Last-Modified 属性，则返回它。</p>
<h4><span id="res-lastmodified">res.lastModified=</span></h4><p>设置返回头中的 Last-Modified 属性，可以使用时间对象或者时间字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.lastModified = <span class="keyword">new</span> <span class="built_in">Date</span>();</div></pre></td></tr></table></figure>
<h3><span id="res-etag">res.etag=</span></h3><p>设置返回头的 Etag 字段。koa 不提供关于 Etag 的获取方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.response.etag = crypto.createHash(<span class="string">'md5'</span>).update(<span class="keyword">this</span>.body).digest(<span class="string">'hex'</span>);</div></pre></td></tr></table></figure>
<hr>
<h2><span id="xing-neng-benchmarks">性能（Benchmarks）</span></h2><p>挂载不同数量的中间件，wrk 得出 benchmarks 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">1 middleware</div><div class="line">8367.03</div><div class="line"></div><div class="line">5 middleware</div><div class="line">8074.10</div><div class="line"></div><div class="line">10 middleware</div><div class="line">7526.55</div><div class="line"></div><div class="line">15 middleware</div><div class="line">7399.92</div><div class="line"></div><div class="line">20 middleware</div><div class="line">7055.33</div><div class="line"></div><div class="line">30 middleware</div><div class="line">6460.17</div><div class="line"></div><div class="line">50 middleware</div><div class="line">5671.98</div><div class="line"></div><div class="line">100 middleware</div><div class="line">4349.37</div></pre></td></tr></table></figure>
<p>一般来说，我们通常要使用约50个中间件，按这个标准计算，单应用可支持 340,260 请求/分钟，即 20,415,600 请求/小时，也就是约 4.4 亿 请求/天。</p>
<hr>
<h2><span id="xue-xi-zi-liao">学习资料</span></h2><p>发现更多第三方的 koa 中间件，或者一起来参与社区的讨论和建设吧：</p>
<ul>
<li><a href="https://github.com/koajs/koa" target="_blank" rel="external">GitHub repository</a></li>
<li><a href="https://github.com/koajs/examples" target="_blank" rel="external">Examples</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Middleware</a></li>
<li><a href="https://github.com/koajs/koa/wiki" target="_blank" rel="external">Wiki</a></li>
<li><a href="https://plus.google.com/communities/101845768320796750641" target="_blank" rel="external">G+ Community</a></li>
<li><a href="https://groups.google.com/forum/#!forum/koajs" target="_blank" rel="external">Mailing list</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/guide.md" target="_blank" rel="external">Guide</a></li>
<li><a href="https://github.com/koajs/koa/blob/master/docs/faq.md" target="_blank" rel="external">FAQ</a></li>
</ul>
<hr>
<h2><span id="contributing">Contributing</span></h2><ul>
<li>Fork this repo</li>
<li>Clone your repo</li>
<li>Install dependencies</li>
<li>Checkout a feature branch</li>
<li>Feel free to add your features</li>
<li>Make sure your features are fully tested</li>
<li>Open a pull request, and enjoy &lt;3</li>
</ul>
<h2><span id="mit-license">MIT license</span></h2><p>Copyright (c) 2013 turing &lt;o.u.turing@gmail.com&gt;</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in<br>all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN<br>THE SOFTWARE.</p>
<hr>
<p><img src="https://cdn1.iconfinder.com/data/icons/windows8_icons_iconpharm/26/doctor.png" alt="docor"></p>
<p>Generated using <a href="https://github.com/guo-yu/docor.git" target="_blank" rel="external">docor</a> @ 0.1.0. brought to you by <a href="https://github.com/guo-yu" target="_blank" rel="external">Guo Yu</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-10</span><i class="fa fa-tag"></i><a href="/categories/node-js/" title="node.js" class="tag">node.js </a><a href="/tags/guide/" title="guide" class="tag">guide </a><a href="/tags/Koa/" title="Koa" class="tag">Koa </a></div></div></div></div><div class="mailcommint">请注意：我们关闭了评论，因为采用邮件或许交流速度更快。 Click ><a href="mailto:liuqichao@liuqichao.com?subject=Commint: koa-guide-v2" class="a">Send Mail</a></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://www.kanshouce.com/2017/08/10/koa-guide-v2/,手册,koa-guide-v2,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/10/egg-static/" title="egg-static 中文说明" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/08/Adobe-acrobat-U/" title="招行办理深圳工商局U盾签名爬坑" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/custom.js"></script></body></html>